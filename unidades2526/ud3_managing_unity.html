<!DOCTYPE html>
<html lang="es-ES">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD3.- Managing Unity</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">    
      
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Manejo de Unity">1.- Manejo de Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Añadir GameObjects a la escena">2.- Añadir GameObjects a la escena</a>
      <a href="#sMateriales" title="3.- Materiales">3.- Materiales</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- Componentes de GameObject">4.- Componentes de GameObject</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- La clase GameObject">7.- La clase GameObject</a>
      <a href="#sEl_componente_Transform" title="8.- El componente Transform">8.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="9.- La clase Input Manager (legacy)">9.- La clase Input Manager (legacy)</a>
    </div>
    <div class="fila">
      <a href="#sInput_System_Package" title="10.- Input System Package">10.- Input System Package</a>
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="11.- Movimiento cinemático y físico">11.- Movimiento cinemático y físico</a>
      <a href="#sColisiones" title="12.- Colisiones">12.- Colisiones</a>      
    </div>
    <div class="fila">      
      <a href="#sMetodos_Intersantes" title="13.- Métodos interesantes">13.- Métodos interesantes</a>
      <a href="#sComponenteCharacterController" title="14.- Componente CharacterController">14.- Componente CharacterController</a>
      <a href="#sCamaraprofesional" title="15.- Cámara profesional">15.- Cámara profesional</a>      
    </div>    
    <div class="fila">  
      <a href="#sMovimientoProgramado" title="16.- Movimiento programado">16.- Movimiento programado</a>    
      <a href="#sRaycast" title="17.- Raycast">17.- Raycast</a>
      <a href="#sNPCs" title="18.- NPCs">18.- NPCs</a>
    </div>
    <div class="fila">      
      <a href="#sCambiodeescenas" title="19.- Cambio de escenas">19.- Cambio de escenas</a>
      <a href="#sPlayerPrefs" title="20.- PlayerPrefs">20.- PlayerPrefs</a>
      <a href="#sMenus" title="21.- Menús">21.- Menús</a>      
    </div>
    <div class="fila">
      <a href="#sComunicacion" title="22.- Comunicación entre GameObjects">22.- Comunicación entre GameObjects</a>
      
    </div>
    
  </nav> <!-- BTM_MENU-->
  
  <h1>UD3.- Gestión de Unity</h1> 

  
  <div class="main-menu">  
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Manejo de Unity">1.- Manejo de Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Añadir GameObjects a la escena">2.- Añadir GameObjects a la escena</a>
      <a href="#sMateriales" title="3.- Materiales">3.- Materiales</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- Componentes de GameObject">4.- Componentes de GameObject</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- La clase GameObject">7.- La clase GameObject</a>
      <a href="#sEl_componente_Transform" title="8.- El componente Transform">8.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="9.- La clase Input Manager (legacy)">9.- La clase Input Manager (legacy)</a>
    </div>
    <div class="fila">
      <a href="#sInput_System_Package" title="10.- Input System Package">10.- Input System Package</a>
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="11.- Movimiento cinemático y físico">11.- Movimiento cinemático y físico</a>
      <a href="#sColisiones" title="12.- Colisiones">12.- Colisiones</a>      
    </div>
    <div class="fila">      
      <a href="#sMetodos_Intersantes" title="13.- Métodos interesantes">13.- Métodos interesantes</a>
      <a href="#sComponenteCharacterController" title="14.- Componente CharacterController">14.- Componente CharacterController</a>
      <a href="#sCamaraprofesional" title="15.- Cámara profesional">15.- Cámara profesional</a>      
    </div>    
    <div class="fila">  
      <a href="#sMovimientoProgramado" title="16.- Movimiento programado">16.- Movimiento programado</a>    
      <a href="#sRaycast" title="17.- Raycast">17.- Raycast</a>
      <a href="#sNPCs" title="18.- NPCs">18.- NPCs</a>
    </div>
    <div class="fila">      
      <a href="#sCambiodeescenas" title="19.- Cambio de escenas">19.- Cambio de escenas</a>
      <a href="#sPlayerPrefs" title="20.- PlayerPrefs">20.- PlayerPrefs</a>
      <a href="#sMenus" title="21.- Menús">21.- Menús</a>      
    </div>
    <div class="fila">
      <a href="#sComunicacion" title="22.- Comunicación entre GameObjects">22.- Comunicación entre GameObjects</a>
      <a class="relleno"></a>
      <a class="relleno"></a>
    </div>
  </div>


  <section class="apartado">
    <a id="sManejo_de_Unity"></a>
    <h2>Manejo de Unity</h2>
    <p>Es muy importante aprender cómo funciona la ventana <span class="negrita">Scene View</span> para trabajar correctamente con los <span class="negrita">GameObjects</span>.</p>
    
    <p>La <span class="negrita">Scene View</span> es donde ves los objetos que forman parte de la escena.</p>
    
    <p>En esta ventana suelen aparecer <span class="negrita">gizmos</span>. Un gizmo es un gráfico que ayuda al desarrollador mostrando información de un GameObject dentro de la escena.</p>
    
    <p>Por ejemplo, si seleccionas la luz de la escena, verás un gizmo que indica la dirección de la luz.</p>
    <a href="UD3/images/ud3-2024-01-25-11-22-45.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-11-22-45.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>El sistema de coordenadas permite posicionar todos los GameObjects en la escena.</p>
    
    <p>Cada GameObject tendrá coordenadas que indican su posición.</p>
    
    <p>Unity utiliza un sistema <span class="negrita">Y-Up</span>:
      <ul>
        <li><span class="negrita">x</span>: eje horizontal</li>
        <li><span class="negrita">y</span>: eje vertical</li>
        <li><span class="negrita">z</span>: eje de profundidad</li>
      </ul>
    </p>
    <a href="UD3/images/ud3-2024-01-25-11-59-29.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-11-59-29.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Unreal y Blender usan Z-Up (el eje vertical es <span class="negrita">z</span> y el de profundidad es <span class="negrita">y</span>).</p>
    <p>En la <span class="negrita">esquina superior derecha</span> de Scene View aparece un <span class="negrita">Scene Gizmo</span> muy útil que indica la dirección desde la que se está viendo la escena.</p>
    <a href="UD3/images/ud3-2024-01-25-12-00-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-00-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Al hacer clic en los conos cambias la vista para alinearla con ese eje.</p>

    
    <p>Debajo del gizmo se muestra la vista actual, que puede indicar “Persp” u otra dirección como “Back”. Si haces clic en el cubo central o en el texto de la vista actual, cambias a vista isométrica.</p>
    
    <p>Si desarrollas en 3D, la vista cambiará constantemente; si desarrollas en 2D, la vista por defecto puede no ser la adecuada y conviene cambiarla.</p>
    
    <p>En la parte superior de la ventana están estas herramientas:</p>
    

    <a href="UD3/images/UD3_2025-09-24-12-27-55.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-24-12-27-55.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    
    <p>A la izquierda:
      <ul>
        <li><span class="negrita">Center / Pivot</span>: determina si el <em>manejador</em> de transformación se coloca en el centro de la selección (<em>Center</em>) o en el <em>pivote</em> propio de cada objeto (<em>Pivot</em>).</li>
        <li><span class="negrita">Global / Local</span>: controla si los ejes de transformación usan las coordenadas globales del mundo (<em>Global</em>) o los ejes locales del objeto (<em>Local</em>).</li>
        <li>Conmutador de cuadrícula (mostrar/ocultar).</li>
        <li>Ajuste a cuadrícula (<em>Snap</em>) al mover.</li>
        <li>Pasos del <em>snap</em> al mover un GameObject.</li>
      </ul>
    </p>
    
    <p>A la derecha:
      <ul>
        <li>Modo de visualización de los GameObjects (sólido, <em>wireframe</em>, etc.).</li>
        <li>Cambiar entre vista 3D u ortográfica 2D.</li>
        <li>Conmutar la iluminación de la escena.</li>
        <li>Conmutar el sonido.</li>
        <li>Conmutar efectos (cielo, niebla, etc.).</li>
        <li>Mostrar/ocultar recuento de GameObjects ocultos.</li>
        <li>Configuración de cámara de la vista.</li>
        <li>Visibilidad de <em>gizmos</em>.</li>
      </ul>
    </p>
    
    <p>En la esquina superior izquierda tienes las herramientas para navegar y manipular GameObjects:</p>
    <a href="UD3/images/ud3-2024-01-25-12-09-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-09-50.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Estas herramientas muestran un <span class="negrita">gizmo</span> sobre el GameObject seleccionado que facilita la manipulación.</p>
    <a href="UD3/images/ud3-2024-01-25-12-11-24.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-11-24.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <a href="UD3/images/movement_shample.gif" target="_BLANK"><figure><img src="UD3/images/movement_shample.gif" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Todos los GameObjects tienen un <span class="negrita">pivot</span>, desde el que se aplican los cambios.</p>
    
    <p>Por defecto, el <span class="negrita">pivot</span> está en el centro del GameObject, por eso el gizmo de las herramientas parte del centro del objeto seleccionado.</p>
    
      <a href="UD3/images/ud3-2024-01-25-13-50-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-50-41.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>El <span class="negrita">pivot</span> no puede moverse dentro de Unity (sí puedes ajustarlo en un DCC (<span class="cursiva">Digital content creation</span>) como Blender o usar un GameObject vacío como offset).</p>
    
      <h3>Mover la cámara de Scene View</h3>
    
      <p class="sub-section">Con teclado:</p>
      <p>
        <ul>
          <li><span class="negrita">W / A / S / D</span> + botón derecho mantenido: desplazamiento libre (<em>fly</em>).</li>
          <li><span class="negrita">Q / E</span>: bajar / subir.</li>
          <li><span class="negrita">F</span>: centrar la vista en el objeto seleccionado (<em>Frame Selected</em>).</li>
          <li><span class="negrita">Shift</span>: aumenta la velocidad de desplazamiento.</li>
        </ul>
      </p>
      
      
      <p class="sub-section">Con ratón:</p>
      <p>
        <ul>
          <li>Con la herramienta mano seleccionada <img style="vertical-align: baseline"  src="UD3/images/ud_3-2024-09-30-10-53-07.png" />, clic y arrastrar: desplazamiento horizontal/vertical (pan).</li>
          <li>Botón central (rueda): <em>pan</em>.</li>
          <li>Rueda: <em>zoom</em> (acercar/alejar).</li>
          <li>Botón derecho mantenido: rotar la cámara sobre su eje.</li>
          <li><span class="negrita">Alt</span> + botón izquierdo: orbitar alrededor del punto de mira.</li>
          <li><span class="negrita">Alt</span> + botón derecho: <em>dolly</em> (zoom continuo).</li>
        </ul>
      </p>
    
      <p>Cualquier GameObject puede alinearse con la vista.</p>
    
      <p>Esto es útil con cámaras porque permite alinear la <span class="negrita">Camera</span> a la vista para que, al ejecutar el juego, sea esa la vista mostrada.</p>
      
      <a href="UD3/images/ud3-2024-01-25-13-53-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-53-48.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      
      <p>Como se ha comentado, si desarrollas un juego 2D conviene cambiar la vista de escena para que coincida con la vista del juego, donde el eje <span class="negrita">z</span> es horizontal y el <span class="negrita">y</span> vertical.</p>
      <a href="UD3/images/ud3-2024-01-25-13-54-45.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-54-45.png" /><br><figcaption></figcaption></figure></a>
      <br>

      <section class="marco-t tip">
        <span class="icono info"></span>
        <strong>Consejos útiles (Unity 6.x):</strong>
        <ul>
          <li><em>Vertex Snap</em>: mantén <span class="negrita">V</span> para arrastrar el gizmo al vértice más cercano y alinear objetos con precisión.</li>
          <li><em>Grid &amp; Snap</em>: ajusta los pasos desde <span class="negrita">Edit &rarr; Grid and Snap Settings</span>; mantén <span class="negrita">Ctrl</span> mientras arrastras para forzar el <em>snap</em>.</li>
          <li><em>Align with View</em>: con una <span class="negrita">Camera</span> seleccionada, usa <span class="negrita">Ctrl + Shift + F</span> para igualarla a la vista actual.</li>
        </ul>
      </section>
      <section class="marco-b"></section>
      
  </section><!-- End section Manejo de Unity-->

  
  
  <section class="apartado">
    <a id="sAgregando_GameObjects_a_la_escena"></a>
    <h2>Añadir GameObjects a la escena</h2>
    
    <p>Para añadir GameObjects a la escena, puedes hacer clic derecho en la zona de elementos de la escena (jerarquía) o seleccionar la opción correspondiente en el menú <span class="negrita">GameObject</span>.</p>
    
    <p>Desde el menú también tienes acciones para aplicar sobre un GameObject si está seleccionado.</p>
    <a href="UD3/images/ud3-2024-01-25-13-56-44.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-56-44.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Según el tipo de proyecto, habrá distintos tipos de GameObjects disponibles para añadir a la escena (puedes ampliar el catálogo añadiendo paquetes desde el <span class="negrita">Package Manager</span>).</p>
    
    <p>Se pueden añadir GameObjects vacíos, que sirven para agrupar otros GameObjects y ayudan a mantener organizada la jerarquía.</p>
    
    <p>También hay objetos 3D, que serán los primeros que utilicemos en clase.</p>
    
    <a href="UD3/images/ud3-2024-01-25-13-58-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-58-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-01-25-13-59-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-59-21.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Al añadir un GameObject a la escena, puedes renombrarlo desde la jerarquía (más tarde también puedes renombrarlo con clic derecho sobre él en la jerarquía).</p>
    
    <p>Además, cuando se añade, el GameObject se posiciona en el centro de la escena, independientemente de sus coordenadas anteriores.</p>
    <a href="UD3/images/ud3-2024-01-25-14-00-24.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-00-24.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Al seleccionar el GameObject en el Inspector, puedes ver sus componentes, incluyendo <span class="r-word">Transform</span>, que indica los valores de <span class="negrita">posición, rotación y escala</span>.</p>
    
    <p>Los GameObjects se añaden a la jerarquía como hijos de la escena.</p>
    
    <p>En la jerarquía, puedes organizar GameObjects dentro de otros arrastrándolos sobre el que deba contenerlos o sacándolos del que los contiene.</p>
    
    <p>Si haces clic derecho sobre un objeto en la jerarquía y añades un GameObject, se añadirá directamente como hijo del seleccionado.</p> 
    <a href="UD3/images/ud3-2024-01-25-14-01-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-01-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <section class="marco-t warn">
      <span class="icono warning"> </span>Todas las modificaciones realizadas a un GameObject afectan a todos los GameObjects que contiene en la jerarquía.
    </section>
    <section class="marco-b">
        
    </section>
    
    <h3>Punto de pivot de un GameObject</h3>
    <p><span class="negrita">Todos los GameObjects tienen un punto de pivot situado en su centro.</span></p>
    
    <p>Las coordenadas de este pivot en la escena son las que usa Unity para efectuar todos los cálculos necesarios.</p>
    
    <p>El pivot <span class="negrita">no puede moverse</span> dentro de Unity. (Salvo ajustándolo en programas de diseño como Blender.)</p>
    
    <p>El pivot también es la referencia cuando un GameObject sigue a otro; por ejemplo, una cámara que sigue a un personaje. En ese caso, la cámara seguirá el pivot del GameObject.</p>
    
    <p>Si quieres un centro de seguimiento diferente, puedes crear un GameObject vacío, añadirlo al GameObject principal en las coordenadas deseadas y hacer que la cámara siga al GameObject vacío.</p>
    
    <h3>Modificar GameObjects</h3>
    <p>Para modificar un GameObject debes seleccionarlo, ya sea desde la jerarquía o haciendo clic sobre él en la vista de la escena.</p>
    
    <p>Si haces doble clic en un GameObject de la jerarquía, además de seleccionarlo, la vista se centrará en él.</p>
    
    <p>Si haces clic en un GameObject en la vista de la escena, lo seleccionas y centras la vista donde has pulsado.</p>
    
    <p><span class="negrita">Todas las modificaciones de un GameObject usan el pivot como referencia.</span></p>
    
    <p>Hay varias formas de modificar un GameObject en la escena:</p>
    
    <p class="sub-section">Cambiar manualmente sus valores en el Inspector</p>
    
    <a href="UD3/images/ud3-2024-01-25-14-06-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-06-47.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Puedes colocar el GameObject en el origen de coordenadas (0,0,0).</p>
    
    <a href="UD3/images/ud3-2024-01-25-14-07-26.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-07-26.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Esta acción puede ser problemática porque el pivot está centrado por defecto. Al mover a (0,0,0), el GameObject puede quedar como en la imagen, con la mitad por debajo del punto (0,0,0).</p>
    <a href="UD3/images/ud3-2024-01-25-14-07-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-07-47.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p class="sub-section">Usar el Inspector pasando el cursor por una coordenada</p>
    <p>El cursor cambiará y podrás hacer clic y arrastrar para variar el valor.</p>
    <a href="UD3/images/ud3-2024-01-25-14-08-44.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-08-44.png" /><br><figcaption></figcaption></figure></a>
    <br>

    <a href="UD3/images/Desplazamiento.gif" target="_BLANK"><figure><img src="UD3/images/Desplazamiento.gif" /><br><figcaption></figcaption></figure></a>
    <br>
    <p class="sub-section">Con las herramientas mencionadas antes</p>
    <p>Puedes modificar un GameObject usando el ratón.</p>
    
    <p>Al seleccionarlo aparece un gizmo y, al interactuar con él con el ratón, podrás realizar las acciones necesarias.</p>
    
    <p>Cada gizmo funciona de forma distinta.</p>
    <a href="UD3/images/ud3-2024-01-25-14-09-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-09-56.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Movimiento solo en el eje X</p>
    <a href="UD3/images/ud3-2024-01-25-14-10-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-10-56.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Movimiento en los ejes no Y (plano X, Z):</p>
    <a href="UD3/images/ud3-2024-01-25-14-10-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-10-43.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Al usar herramientas con gizmos puedes utilizar <span class="negrita">snaps</span>.</p>
    
    <p>Los pasos por defecto del <em>snap</em> pueden cambiarse:</p>
    <a href="UD3/images/UD3_2025-09-24-13-17-53.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-24-13-17-53.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Para aplicar el <em>snap</em> mientras usas los gizmos, mantén pulsada la tecla <span class="negrita">Ctrl</span>.</p>
    
    <p>Todas las modificaciones usan el pivot como referencia.</p>
    
    <p>Puedes ajustar el punto de referencia a un vértice de la malla del GameObject. Para ello, pulsa la tecla <span class="negrita">V</span> tras seleccionar la herramienta.</p>
    
    <p>Al pulsar <span class="negrita">V</span>, verás que el gizmo se mueve al vértice más cercano al pasar el ratón sobre el GameObject.</p>
    
    <p>Esta acción se conoce como <em>vertex snap</em> y permite alinear GameObjects haciendo coincidir un vértice con el vértice de otro GameObject.</p>
    
    <a href="UD3/images/ud3-2024-01-26-09-29-17.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-29-17.png" /><br><figcaption></figcaption></figure></a>
    <br>

    <a href="UD3/images/VertexSnap.gif" target="_BLANK"><figure><img src="UD3/images/VertexSnap.gif" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Unidades de medida</h3>
    <p>Por defecto, las unidades de medida en Unity son:
      <ul>
        <li><span class="negrita">Distancias</span>: metros.</li>
        <li><span class="negrita">Tamaños</span>: metros.</li>
        <li><span class="negrita">Peso (masa)</span>: kilogramos.</li>
        <li><span class="negrita">Tiempo</span>: segundos.</li>
      </ul>
    </p>
    
    <p>Es importante tenerlo en cuenta, ya que el comportamiento de los GameObjects con física depende de su tamaño y su masa.</p>
    
  </section><!-- End section Agregando GameObjects -->
  
  <section class="apartado">
    <a id="sMateriales"></a>
    <h2>Materiales</h2>
    <p>Los <span class="negrita">Materiales</span> permiten dar apariencia a los GameObjects.</p>
    
    <p>Para crear un material, haz clic derecho en el gestor de archivos y selecciona <span class="negrita">Create &rarr; Material</span>. Al crearlo podrás asignarle un nombre.</p>
    <a href="UD3/images/ud3-2024-01-26-09-32-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-32-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Es importante recordar que, para mantener la organización, los materiales deberían colocarse en una carpeta llamada <span class="inline-folder">Materials</span> dentro de <span class="inline-folder">Assets</span>.</p>
    
    <p>Un material en el gestor de archivos se representa con una esfera y, según la configuración aplicada en el Inspector, tendrá una apariencia diferente.</p>
       
    <a href="UD3/images/UD3_2025-09-24-13-22-40.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-24-13-22-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Con una buena configuración puedes conseguir materiales realistas.</p>
    
    <p>También puedes obtener materiales desde la <span class="negrita">Unity Asset Store</span> y desde repositorios en Internet.</p>
    <a href="UD3/images/UD3_2025-09-24-13-24-02.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-24-13-24-02.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Puedes aplicar un material a un GameObject de varias maneras:
      <ul>
        <li>Arrastrando el material sobre el GameObject en la jerarquía.</li>
        <li>Arrastrándolo sobre el GameObject en la vista de la escena.</li>  
        <li>Arrastrándolo al GameObject en el Inspector, en la zona de “Add Component”.</li>
      </ul>
    </p>
    
    <a href="UD3/images/ud3-2024-01-26-09-54-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-54-59.png" /><br><figcaption></figcaption></figure></a>
    <br>

<a href="UD3/images/ApplyMaterials.gif" target="_BLANK"><figure><img src="UD3/images/ApplyMaterials.gif" /><br><figcaption></figcaption></figure></a>
    <br>
    <div class="tarea">
      <span class="negrita subrayado">Actividad 1</span>: Crea 3 materiales y aplícalos a los cubos como en la imagen anterior.</div>
    <br>
    <h3>Materiales físicos</h3>
    <p>Los materiales físicos (<span class="negrita">Physic Material</span>) permiten controlar cómo interactúan físicamente los GameObjects cuando colisionan entre sí.</p>
    
    <p>Se usan habitualmente para que los GameObjects reboten o para generar fricción entre ellos.</p>
    
    <p>Para crear un material físico, haz clic derecho en el gestor de archivos y elige <span class="negrita">Create &rarr; Physic Material</span>.</p>
    
    <p>Al crearlo deberás darle un nombre.</p>
    <a href="UD3/images/ud3-2024-01-26-10-05-23.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-05-23.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Los parámetros que pueden configurarse en un material físico son:</p>
    <a href="UD3/images/ud3-2024-01-26-10-05-53.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-05-53.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Puedes aplicar un material físico a un GameObject de varias formas:
      <ul>
        <li>Arrastrando el material sobre el GameObject en la jerarquía.</li>
        <li>Arrastrándolo sobre el GameObject en la vista de la escena.</li>
        <li>Arrastrándolo al GameObject en el Inspector, en la zona “Add Component”.</li>
      </ul>
    </p>
    
    <a href="UD3/images/ud3-2024-01-26-10-06-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-06-48.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 2: Construcción de la escena</span> <br>
        Crea un proyecto 3D en Unity llamado <span class="subrayado">SceneTuNombre</span>. <br>
        Configura la vista de cámara como si desarrollaras un juego 2D (eje Z hacia el fondo).<br>
        Añade un plano a la escena y modifica su tamaño para que sea poco profundo pero muy ancho (como una plataforma horizontal de izquierda a derecha). <br>
        Añade un cubo, una esfera, una cápsula y un cilindro a la escena. Ordénalos como quieras, pero todos deben compartir la misma coordenada Z que el plano. <br>
        Solo un objeto debe tocar la superficie del plano. <br>
        De los GameObjects que no tocan el plano, coloca uno alineado en Z con el que sí toca, desplázalo ligeramente en X (por encima del otro) y pon su Y más alta, en la parte superior de la escena. <br>
        Crea 5 materiales con colores y apariencias distintas y asigna cada uno a un GameObject. <br>
    
        Coloca la vista en un ángulo distinto al de la cámara: puedes rotarla y moverla, pero deben aparecer el plano y todos los objetos.
        <span class="oculto">Haz una captura de la vista de escena y nómbrala TuNombreUnity1.png</span>
        <span class="oculto">Haz una captura de la vista de juego durante la ejecución; nómbrala TuNombreUnity2.png. Comprime ambas capturas en un .rar o .zip llamado TuNombre y adjúntalo a la tarea.</span>
      </p>
    </div>
    
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 3: Eventos de MonoBehaviour</span> <br>
        Abre el proyecto SceneTuNombre. <br>
        Crea un script llamado <span class="negrita">EventsScript</span> y asígnalo al GameObject que está tocando la superficie. <br>
        En el script, añade instrucciones para mostrar mensajes en la consola con <span class="negrita">Debug.Log</span> para los eventos: <span class="negrita">Start</span>, <span class="negrita">Update</span>, <span class="negrita">OnMouseEnter</span> (cuando el ratón está sobre el GameObject) y <span class="negrita">OnMouseDrag</span> (cuando se hace clic y se arrastra el GameObject). <br>
        Los mensajes deben seguir el formato: "TuNombre (NombreEvento): TuMensaje".<br>
        <span class="oculto">
        Haz clic en el script en el gestor de archivos para que el código aparezca en el Inspector; ejecuta el juego y toma una captura donde se vea la consola y el Inspector (recuerda activar la opción <span class="negrita">Collapse</span> en la consola).
        Nombra la captura TuNombreUnity3.png. <br>
        Comprime la captura en un .rar o .zip llamado TuNombre y adjúntalo a la tarea.</span>
      </p>
    </div>
    <section class="marco-t inf">
      <span class="icono info"> </span> <span class="r-word">OnMouseEnter</span>  y <span class="r-word">OnMouseDrag</span>  son métodos del antiguo <span class="cursiva">input system</span>, que por defecto en la versión nueva de Unity está desactivado, o mejor dicho está sólo habilitado el nuevo.
      <span class="negrita">OJO reiniciará unity</span> 
      </section>
    <section class="marco-b">
        <p></p>Para activarlo ve a <span class="negrita">Edit &rarr; Project Settings &rarr; Player &rarr; Other Settings &rarr; Active Input Handling</span> y seleccionamos 
    <span class="negrita">both</span> para tener compatibilidad con el sistema antiguo. 
    En los apuntes veremos ambos sistemas, aunque el sistema antiguo está quedando en desuso por compatibilidad con proyectos antiguos</p>
    <a href="UD3/images/UD3_2025-09-24-19-09-57.png"><figure><img src="UD3/images/UD3_2025-09-24-19-09-57.png" /><br><figcaption>Activar ambos sistemas input</figcaption></figure></a>
    <br>
    
    </section>
      
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 4: Gravedad</span> <br>
        Abre el proyecto SceneTuNombre. <br>
        Uno de los GameObjects está alineado verticalmente con el que tocaba la superficie. Añade un componente <span class="negrita">Rigidbody</span> al objeto situado en la parte superior de la escena. <br>
        Ejecuta el juego y observa qué ocurre. <br>
        Cambia la <span class="negrita">masa</span> de ese GameObject y vuelve a ejecutar para observar los cambios.<br>
        Ajusta otros parámetros del <span class="negrita">Rigidbody</span> y ejecuta para ver qué pasa. <br>
        <div class="oculto">Haz una captura de la ventana de juego antes de que caiga el cubo y nómbrala TuNombreUnity4.png. <br>
          Haz una captura cuando el cubo golpee al objeto inferior y nómbrala TuNombreUnity5.png. <br>
          Haz una captura cuando el cubo se detenga y nómbrala TuNombreUnity6.png. <br>
          Comprime las capturas en un .rar o .zip llamado TuNombre y adjúntalas a la tarea.</div>
      </p>
    </div>

    <br><br>
    <a href="UD3/images/demo_act_2_4.gif" target="_BLANK"><figure><img src="UD3/images/demo_act_2_4.gif" /><br><figcaption></figcaption></figure></a>
    
  </section><!-- End section Materials -->

  
  <!--*********************************************************Componentes de GameObject***********************************************************-->
<section class="apartado">
  <a id="sComponentes_de_GameObject"></a>
  <h2>Componentes de GameObject</h2>
  <p>Los GameObjects pueden contener distintos componentes.</p>
  
  <p>Como mínimo, todos los GameObjects tienen el componente <span class="negrita">Transform</span>, que indica la posición, rotación y escala del GameObject.</p>
  
  <p>Los GameObjects geométricos suelen tener una <span class="negrita">malla (Mesh)</span> y un <span class="negrita">Mesh Renderer</span> para poder dibujarse.</p>
  
  <p>Para detectar colisiones, los GameObjects utilizan un <span class="negrita">Collider</span>.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-00-53.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-00-53.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Puedes añadir otros componentes desde el <span class="negrita">Menú &rarr; GameObject</span> o desde el Inspector con el botón <span class="negrita">“Add Component”</span> al final.</p>
  
  <p>Al pulsar <span class="negrita">“Add Component”</span> se abre un buscador para escribir el nombre del componente que necesitas.</p>
  <a href="UD3/images/ud3-2024-01-26-10-02-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-02-02.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Cuando un GameObject debe verse afectado por la <span class="negrita">física</span> (gravedad, fuerzas, etc.), necesita un componente <span class="r-word">Rigidbody</span>.</p>
  
  <p>En el <span class="negrita">Rigidbody</span> se configura la <span class="negrita">masa</span> del GameObject (entre otros parámetros).</p>
  <a href="UD3/images/ud3-2024-01-26-10-03-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-03-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
</section><!-- End section Componentes de GameObject-->

<!--*********************************************************UI (Interfaz de usuario)***********************************************************-->
<section class="apartado">
  <a id="sUI"></a>
  <h2>UI (Interfaz de usuario)</h2>
  <p>La interfaz de usuario (UI) está formada por elementos añadidos a la escena para mostrar información o interactuar con el jugador.</p>
  
  <p>Con la UI puedes crear menús y el <span class="negrita">HUD</span> (Head-Up Display).</p>
  
  <p>Puede construirse con GameObjects 2D o 3D, aunque lo habitual es usar GameObjects 2D.</p>
  
  <p>Entre los GameObjects de UI están: texto, imágenes, deslizadores, barras de desplazamiento, botones o campos de texto.</p>
  
  <p>Los GameObjects de UI deben ser hijos de un <span class="negrita">Canvas</span>.</p>
  
  <p>Si añades un GameObject de UI y no existe <span class="negrita">Canvas</span> en la escena, Unity creará uno automáticamente.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-09-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-09-35.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <h3>UI — Texto</h3>
  <p>Hay dos GameObjects principales para añadir texto:</p>
  <ul>
    <li><span class="negrita">Text</span>: texto básico con opciones limitadas. (Ya no aparece en las nuevas versiones)</li>
    <li><span class="negrita">TextMeshPro</span>: texto avanzado con muchas opciones.</li>
  </ul>
  
  <p>Existen otros GameObjects de MeshPro que mejoran los tipos primitivos.</p>
  
  <p>Se recomienda usar <span class="negrita">TextMeshPro</span> siempre que sea posible.</p>
  <a href="UD3/images/ud3-2024-01-26-10-11-13.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-11-13.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>La primera vez que añadas un <span class="negrita">TextMeshPro</span> al proyecto, aparecerá una ventana para importar los paquetes necesarios. Pulsa <span class="cursiva">“Import TMP Essentials”</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-12-31.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-12-31.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para que los elementos del Canvas se muestren correctamente en pantalla, ajusta en el Inspector:</p>
  <ul>
    <li><span class="negrita">Render Mode</span>: <span class="negrita">Screen Space - Camera</span>.</li>
    <li>Arrastra la cámara de la jerarquía al campo <span class="negrita">Render Camera</span>.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-26-10-14-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-14-41.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-15-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-15-02.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/demo_canvas_text.gif" target="_BLANK"><figure><img src="UD3/images/demo_canvas_text.gif" /><br><figcaption></figcaption></figure></a>
  <br>

  <h3>UI — Imágenes (Sprites)</h3>
  <p>Para añadir imágenes a la UI, dichas imágenes deben ser <span class="d-word">sprites</span>.</p>
  
  <p>Un sprite es una imagen de mapa de bits que representa una unidad mínima (por ejemplo, el gráfico de un botón o de un personaje).</p>
  
  <p>Una imagen puede contener uno o varios sprites.</p>
  
  <p>Cada sprite puede añadirse a la escena como GameObject independiente.</p>
  
  <p>Si una imagen agrupa varios sprites, <span class="negrita">optimiza</span> la carga de recursos.</p>
  
  <p>Los sprites se usan para componer personajes completos y animar partes por separado, o para animaciones por <span class="cursiva">frames</span> cambiando el sprite de un GameObject.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-28-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-28-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Primer paso: añade el paquete <span class="negrita">2D Sprite</span> desde <span class="negrita">Menú &rarr; Window &rarr; Package Manager &rarr; Package Manager</span>.</p>

  <a href="UD3/images/UD3_2025-09-24-15-03-29.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-24-15-03-29.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Esto instala la herramienta <span class="negrita">Sprite Editor</span>.</p>
  
  <p>Después, arrastra las imágenes al gestor de archivos dentro de una carpeta <span class="inline-folder">Sprites</span>.</p>
  
  <p>Selecciona la imagen y en el Inspector cambia <span class="negrita">Texture Type</span> a <span class="negrita">Sprite (2D and UI)</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-31-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-31-40.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Así aparecerá el botón <span class="negrita">Sprite Editor</span>. Al abrirlo, podrás crear el sprite desde la imagen.</p>
  
  <p>Si la imagen solo contiene un sprite y dejas el modo <span class="cursiva">Single</span>, al abrir el editor se convertirá automáticamente.</p>
  
  <p>Cuando una imagen se convierte en sprite, aparece una flecha en su previsualización dentro del gestor de archivos.</p>
  <a href="UD3/images/ud3-2024-01-26-10-32-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-32-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>El editor permite modificar el sprite.</p>
  <a href="UD3/images/ud3-2024-01-26-10-33-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-33-21.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si la imagen contiene varios sprites, establece <span class="negrita">Sprite Mode</span> en <span class="negrita">Multiple</span>. Es importante que el fondo de la imagen sea transparente.</p>
  <a href="UD3/images/ud3-2024-01-26-10-34-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-34-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>En el editor podrás seleccionar y nombrar manualmente cada sprite.</p>
  <a href="UD3/images/ud3-2024-01-26-10-35-15.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-35-15.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>La opción <span class="negrita">Trim</span> ajusta el contorno al contenido (mejor con fondo transparente).</p>
  <a href="UD3/images/ud3-2024-01-26-10-35-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-35-48.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="negrita">Outline Tolerance</span> y <span class="negrita">Generate</span> puedes generar el contorno; pulsa <span class="negrita">Apply</span> para guardar.</p>
  <a href="UD3/images/ud3-2024-01-26-10-37-14.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-37-14.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si los sprites están en una rejilla, usa el menú <span class="negrita">Slice</span>:</p>
  <ul>
    <li><span class="negrita">Automatic</span>: detecta sprites por contenido.</li>
    <li><span class="negrita">Grid By Cell Size</span>: especifica el tamaño de celda.</li>
    <li><span class="negrita">Grid By Cell Count</span>: especifica filas y columnas.</li>
  </ul>
  <p>Después pulsa <span class="negrita">Slice</span> para generarlos.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-39-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-39-10.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-39-17.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-39-17.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-40-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-40-12.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para hojas de animación, revisa el <span class="negrita">pivot</span> que usa cada sprite para que la animación funcione correctamente (a menudo está en el centro, pero puede variar).</p>
  
  <p>Al desplegar la flecha de la imagen en el gestor de archivos verás la lista de sprites y sus nombres.</p>
  <a href="UD3/images/ud3-2024-01-26-10-41-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-41-11.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para usar un sprite, arrástralo a la jerarquía o a la vista de la escena para crear un GameObject que lo muestre.</p>
  <a href="UD3/images/ud3-2024-01-26-10-52-04.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-52-04.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>También puedes crear un GameObject <span class="negrita">UI &rarr; Image</span> y asignar el sprite arrastrándolo a <span class="negrita">Source Image</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-52-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-52-56.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-53-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-53-10.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
</section><!-- End section UI (Interfaz de usuario) -->

<!--*********************************************************Prefabs***********************************************************-->
<section class="apartado">
  <a id="sPrefabs"></a>
  <h2>Prefabs</h2>
  <p>Un <span class="r-word">Prefab</span> es un GameObject con todas sus características (tamaño, rotación, escala, materiales, texturas, física, etc.) guardadas como un <span class="negrita">asset</span>.</p>
  
  <p>Una vez guardado como prefab, <span class="negrita">puede instanciarse desde un script</span>.</p>
  
  <p>Ejemplo típico: objetos que sueltan los enemigos al desaparecer.</p>
  
  <p>Los prefabs son fáciles de exportar para reutilizarlos en otros proyectos.</p>
  
  <p>Para crear un prefab, arrastra el objeto desde la jerarquía al gestor de archivos.</p>
  
  <p>Por organización, coloca los prefabs en la carpeta <span class="inline-folder">Prefabs</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-55-31.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-55-31.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>En la jerarquía, un GameObject que proviene de un prefab aparece con el nombre en <span class="negrita">azul</span>.</p>
  
  <p>En el gestor de archivos verás la previsualización del prefab.</p>
  <a href="UD3/images/ud3-2024-01-26-10-56-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-56-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Seleccionando el prefab, el Inspector muestra sus características y componentes.</p>
  <a href="UD3/images/ud3-2024-01-26-10-56-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-56-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Un GameObject de la escena que proviene de un prefab puede modificarse sin afectar al prefab original.</p>
  <a href="UD3/images/ud3-2024-01-26-10-57-23.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-57-23.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para editar el prefab en sí, haz doble clic en el asset del prefab.</p>
  
  <p>Los cambios en el prefab se replicarán en todos los GameObjects instanciados a partir de él.</p>
  <a href="UD3/images/ud3-2024-01-26-10-57-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-57-56.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Puedes añadir tantas copias de un prefab a la escena como necesites.</p>
  
  <p>Desde un script, también puedes instanciar prefabs en tiempo de ejecución.</p>
  <a href="UD3/images/ud3-2024-01-26-10-58-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-58-35.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <hr><br>
  <div class="tarea">
    <p><span class="subrayado negrita">Actividad 5. Imágenes y Prefabs</span> <br>
      Abre el proyecto <span class="subrayado">SceneTuNombre</span>. <br>
      Añade un GameObject Cubo, crea un material nuevo y asígnalo. <br>
      Crea 5 copias de ese cubo y ordénalas formando una figura (puedes rotar y escalar). <br>
      Crea un GameObject vacío y agrupa en él los 6 cubos (cuida las coordenadas). <br>
      Crea un Prefab a partir de ese GameObject vacío. <br>
      Añade un texto a la escena con tu nombre. <br>
      Añade una foto tipo carné tuya (actual). <br><br>
      <div class="oculto">Haz una captura de toda la ventana de Unity durante la ejecución, donde se vea el prefab en el gestor de archivos y los GameObjects en la vista de escena. Nómbrala <span class="negrita">TuNombreUnity7.png</span>.<br>
      Comprime la captura en un .rar o .zip llamado <span class="negrita">TuNombre</span> y adjúntalo a la tarea.</div>
    </p>
  </div>
</section><!-- End section Prefabs-->

<!--*********************************************************La clase GameObject***********************************************************-->
<section class="apartado">
  <a id="sLa_Clase_GameObject"></a>
  <h2>La clase GameObject</h2>

  <h3>Acceder a las propiedades de un GameObject</h3>
  <p>Desde un script añadido a un GameObject puedes acceder a las propiedades del propio GameObject y a todos los componentes que tenga.</p>
  
  <p>Para ello se usa la variable <span class="r-word">gameObject</span> (en minúscula), que <span class="negrita">se inyecta automáticamente</span> al heredar de <span class="r-word">MonoBehaviour</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-10-56-27.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-56-27.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <a href="UD3/images/ud3-2024-01-29-10-56-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-56-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <a href="UD3/images/ud3-2024-01-29-10-57-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-57-11.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <a href="UD3/images/ud3-2024-01-29-10-57-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-57-50.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Todos los GameObjects tienen al menos un componente <span class="negrita">Transform</span> (posición, rotación y escala).</p>
  
  <p>Como está presente en <span class="subrayado">todos</span> los GameObjects, Unity inyecta directamente la propiedad <span class="negrita">transform</span>, que puedes usar tal cual o acceder a través de <span class="negrita">gameObject.transform</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-00-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-00-07.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para acceder a un <span class="negrita">componente distinto de Transform</span>, declara una propiedad y asígnale el componente con <span class="negrita">GetComponent</span>.</p>
  
  <p>Por ejemplo, para acceder al componente <span class="negrita">Collider</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-01-57.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-01-57.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <h3>Acceder a otros GameObjects</h3>
  <p>Para acceder a otros GameObjects desde un script, <span class="negrita">declara una propiedad de tipo GameObject</span> y <span class="negrita">asigna el GameObject deseado</span> (ej.: <span class="negrita">SphereGO</span> &rarr; <span class="negrita">G</span>ame<span class="negrita">O</span>bject).</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-03-58.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-03-58.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Formas de asignar el GameObject a la propiedad:</p>
  <ul>
    <li>Si la propiedad es <span class="negrita">public</span>, puedes <span class="negrita">arrastrar y soltar</span> el GameObject desde la jerarquía al campo del Inspector.
      <a href="UD3/images/ud3-2024-01-29-11-06-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-06-10.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>Desde el propio script, usando <span class="negrita">GameObject.Find</span> para buscar por <span class="negrita">nombre</span> (habitualmente con propiedad privada).
      <a href="UD3/images/ud3-2024-01-29-11-07-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-07-41.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>Asignando <span class="negrita">tags</span> a GameObjects y usando <span class="r-word">GameObject.FindGameObjectsWithTag</span> para buscar por <span class="negrita">tag</span>.
      <a href="UD3/images/ud3-2024-01-29-11-09-22.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-09-22.png" /><br><figcaption></figcaption></figure></a>
      <br><br>
      <p>En este caso, la variable <span class="negrita">debe ser un array</span>, ya que puede haber más de un GameObject con esa etiqueta.</p>
      <a href="UD3/images/ud3-2024-01-29-11-11-20.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-11-20.png" /><br><figcaption></figcaption></figure></a>
      <br>
<section><pre><code class="language-csharp">public class Test : MonoBehaviour
{
    public GameObject[] blueCubesGO;

    // Start is called before the first frame update
    void Start()
    {
        blueCubesGO = GameObject.FindGameObjectsWithTag("blueCubes");
        foreach (GameObject cubeGO in blueCubesGO)
        {
            Debug.Log("Cubo: " + cubeGO.name );
        }
    }

    // Update is called once per frame
    void Update(){
    }
}</code></pre>
</section><br><br>
      <a href="UD3/images/ud3-2024-01-29-11-12-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-12-54.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
  </ul>
  
  <p>Al acceder a otros GameObjects, también puedes usar sus componentes. Por ejemplo, este script (añadido a la <span class="negrita">Main Camera</span>) accede a un <span class="negrita">TextMeshProUGUI</span> y actualiza su texto.</p>
  
  <p>Para ello, arrastra el GameObject con el TextMeshProUGUI al campo correspondiente del Inspector (tras seleccionar la cámara).</p>
<section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class Test : MonoBehaviour
{
    public int points = 0;

    public TextMeshProUGUI pointsTMP;
    // Start is called before the first frame update
    void Start()
    {
        pointsTMP.text ="Points: " + points;
    }

    // Update is called once per frame
    void Update()
    {
        //Este método es del antiguo Input System
        if(Input.GetKeyDown(KeyCode.Space)){
            pointsTMP.text ="Points: " + ++points;
        }
    }
}</code></pre>
</section><br><br>

  <h3>Acceder a componentes de otros GameObjects</h3>
  <p>Una vez tienes la referencia a otro GameObject con cualquiera de las técnicas anteriores, puedes acceder a sus componentes mediante <span class="negrita">GetComponent</span>, igual que haces con el GameObject actual.</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-15-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-15-43.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si la propiedad que expone el componente es pública, <span class="negrita">al arrastrar el GameObject</span> al campo del Inspector, <span class="negrita">Unity asignará automáticamente el tipo de componente</span> correcto.</p>
  <a href="UD3/images/ud3-2024-01-29-11-16-38.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-16-38.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>También puedes acceder a scripts en otros GameObjects obteniendo la referencia al objeto destino y pidiendo el componente con el <span class="negrita">nombre del script</span>.</p>
  
  <p>Usa cualquiera de las técnicas previas para obtener esa referencia.</p>
  <a href="UD3/images/ud3-2024-01-29-11-18-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-18-28.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <p>Otro método para acceder a un componente de otro GameObject es definiendo la propiedad que almacenará el componente con <span class="negrita">[SerializeField]</span>
     y arrastrar todo el GameObject a la casilla del inspector.</p>

  <p>Unity reconocerá que se quiere un componente determinado y lo asignará directamente.</p>
  
  <a href="UD3/images/UD3_2025-09-27-23-46-43.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-23-46-43.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  

  
</section><!-- End section La clase GameObject-->


  
  <!--*********************************************************El componente Transform***********************************************************-->
<section class="apartado">
  <a id="sEl_componente_Transform"></a>
  <h2>El componente Transform</h2>
  <p>El componente <span class="r-word">Transform</span> se compone de tres elementos:
    <ul>
      <li><span class="negrita">Position</span></li>
      <li><span class="negrita">Rotation</span></li>
      <li><span class="negrita">Scale</span></li>
    </ul>
  </p>
  <a href="UD3/images/ud3-2024-01-29-11-20-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-20-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Cada elemento especifica un valor para cada coordenada, a las que se puede acceder como se mostró antes.</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-20-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-20-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <p>Para modificar <span class="negrita">posición</span>, <span class="negrita">rotación</span> y <span class="negrita">escala</span> se usan objetos de la clase <span class="r-word">Vector3</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-22-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-22-06.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>El código de la imagen representa las coordenadas: x=3, y=8, z=1.</p>
  
  <p>Los parámetros aceptados son números decimales (<span class="cursiva">float</span>), aunque también se pueden usar enteros.</p>
  
  <p>Si indicas un número decimal, debes añadir la letra <span class="negrita">f</span> al final:</p>
  <a href="UD3/images/ud3-2024-01-29-11-22-20.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-22-20.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Cambiar la posición de un GameObject</h3>
  <p>Para <span class="negrita">cambiar la posición</span> de un GameObject:</p>
  <ul>
    <li>
      Asigna <span class="negrita">un nuevo Vector3</span> a la propiedad <span class="negrita">position</span> de su <span class="negrita">Transform</span>:
      <a href="UD3/images/ud3-2024-01-29-11-23-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-23-18.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>
      Realiza operaciones sobre la propiedad <span class="negrita">position</span> del <span class="negrita">Transform</span> usando un <span class="negrita">Vector3</span>:
      <a href="UD3/images/ud3-2024-01-29-11-24-03.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-24-03.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>
      Usa el método <span class="r-word">Translate</span> del <span class="negrita">Transform</span>:
      <a href="UD3/images/ud3-2024-01-29-11-24-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-24-40.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <p>Con <span class="r-word">Translate</span> puedes indicar si usas el sistema local del objeto (por defecto) o el sistema del mundo (0, 0, 0):</p>
      <a href="UD3/images/ud3-2024-01-29-11-25-39.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-25-39.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
  </ul>
  
  <p>Además, la clase <span class="r-word">Vector3</span> incluye propiedades que devuelven vectores unidad alineados con los ejes:</p>
  <a href="UD3/images/ud3-2024-01-29-11-26-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-26-32.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>Puedes consultar todo lo disponible en la documentación:
    <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Vector3.html">https://docs.unity3d.com/ScriptReference/Vector3.html</a>
  </p>
  
  <p>Los objetos <span class="r-word">Vector3</span> también se pueden operar:</p>
  <a href="UD3/images/ud3-2024-01-29-11-27-08.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-27-08.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Rotar un GameObject</h3>
  <p class="sub-section">Alrededor de su propio eje</p>
  
  <p>Asigna un <span class="negrita">nuevo Vector3</span> a la propiedad <span class="negrita">rotation</span> del <span class="negrita">Transform</span> usando el método <span class="negrita">Euler</span> de <span class="negrita">Quaternion</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-29-15.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-29-15.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <p>La segunda opción es algo más verbosa pero útil si ya tienes un Vector3 o quieres manipular la rotación como vector antes de pasarlo a la función.</p>
  <br>
  
  <p>Usa la propiedad <span class="negrita">eulerAngles</span> (comportamiento similar al método anterior):</p>
  <a href="UD3/images/ud3-2024-01-29-11-30-49.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-30-49.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Usa el método <span class="negrita">Rotate</span> del <span class="negrita">Transform</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-30-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-30-56.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="negrita">Rotate</span> puedes elegir entre coordenadas locales del objeto (por defecto) o del mundo.</p>
  
  <p class="sub-section">Rotar alrededor de otro objeto</p>
  <p>Con <span class="r-word">RotateAround(origin, axis, speed)</span> puedes hacer que un GameObject rote alrededor de otro:</p>
  <a href="UD3/images/ud3-2024-01-29-11-32-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-32-50.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="r-word">LookAt(transformOtherGameObject)</span> puedes hacer que un GameObject siempre mire a otro GameObject:</p>
  <a href="UD3/images/ud3-2024-01-29-11-33-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-33-16.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Estas dos técnicas suelen usarse dentro del método <span class="negrita">Update</span> del script.</p>
  
  <h3>Escalar un GameObject</h3>
  <p>Para <span class="negrita">escalar</span> un GameObject, lo lógico es hacerlo respecto a su <span class="negrita">pivote</span>.</p>
  <p>Por ese motivo se usa la propiedad <span class="r-word">localScale</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-34-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-34-06.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Transform en la jerarquía</h3>
  <p>Cuando los GameObjects están agrupados, el componente Transform permite acceder a todos los Transforms y GameObjects del grupo.</p>
  <a href="UD3/images/ud3-2024-01-29-11-35-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-35-02.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-35-14.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-35-14.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>El orden de acceso a los hijos es el mismo que el orden en el que aparecen en la jerarquía.</p>
  <a href="UD3/images/ud3-2024-01-29-11-38-33.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-38-33.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>También puedes acceder al padre desde un GameObject hijo.</p>
  <a href="UD3/images/ud3-2024-01-29-11-39-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-39-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Movimiento con los métodos Update y FixedUpdate</h3>
  <p class="sub-section">Método Update</p>
  
  <p><span class="r-word">Update</span> se ejecuta una vez por frame.</p>
  
  <p>Si en <span class="negrita">Update</span> modificas el Transform (por ejemplo, sumando 0.01 a la X cada frame), el GameObject <span class="negrita">se mueve</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-40-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-40-35.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>El problema es que los FPS dependen del equipo y de la carga de la escena.</p>
  <a href="UD3/images/ud_3-2024-10-01-13-11-35.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-01-13-11-35.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-41-57.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-41-57.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>Para evitar que el movimiento dependa del frame rate, hay dos opciones:</p>
  <ul>
    <li>Multiplicar por <span class="r-word">Time.deltaTime</span>. Así el movimiento será consistente independientemente de los FPS (deltaTime es el tiempo entre el frame actual y el anterior).</li>
    <li>Usar <span class="r-word">FixedUpdate</span>, que por defecto se ejecuta a intervalos regulares (20 ms, 50 veces por segundo).</li>
  </ul>
  
  <p>Es común crear una propiedad <span class="negrita">speed</span> (float) para controlar la velocidad.</p>
  
  <p>Ejemplo: mover en X según <span class="negrita">speed</span> desde <span class="negrita">Update</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-44-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-44-47.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p class="sub-section">Método FixedUpdate</p>
  <p>Por defecto, <span class="negrita">FixedUpdate</span> se ejecuta cada 20 ms, pero puede cambiarse en <span class="negrita">Menú &rarr; Edit &rarr; Project Settings…</span> en la sección <span class="negrita">Time</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-45-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-45-47.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Ejemplo: mover en X según <span class="negrita">speed</span> desde <span class="r-word">FixedUpdate</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-46-19.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-46-19.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Ambos métodos pueden dar el mismo resultado si se multiplican por el mismo valor.</p>
  <a href="UD3/images/ud3-2024-01-29-11-47-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-47-06.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-47-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-47-21.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>La ventaja de <span class="negrita">FixedUpdate</span> es que su frecuencia se puede configurar desde los ajustes del proyecto.</p>
</section><!-- End section El componente Transform-->

<!--*********************************************************La clase Input***********************************************************-->
<section class="apartado">
  <a id="sLa_clase_Input"></a>
  <h2>La clase Input</h2>
  <p>Con la clase <span class="r-word">Input</span> puedes capturar <span class="negrita">eventos de entrada</span> del dispositivo del usuario (teclado, ratón, gamepad, etc.).</p>
  
  <p>La <span class="negrita">clase Input unifica</span> todos los dispositivos de entrada en un único punto de control.</p>
  
  <p>Unity proporciona una herramienta para configurar los dispositivos de entrada.</p>
  
  <p>En muchos juegos también se permite al usuario cambiar esta configuración para personalizar la experiencia.</p>
  
  <p>Desde <span class="negrita">Menú &rarr; Edit &rarr; Project Settings…</span> se abren los ajustes del proyecto; en <span class="negrita">Input Manager</span> puedes ver y configurar los dispositivos:</p>
  <a href="UD3/images/ud3-2024-01-29-19-19-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-19-19-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <section class="marco-t warn">
    <span class="icono warning"> </span> Ojo al atributo <span class="r-word">name</span>, que será con el que se referencie la tecla o la acción
    </section>
  <section class="marco-b">
      
  </section>
  
  <p>La clase <span class="r-word">MonoBehaviour</span> ofrece métodos que permiten ejecutar código ante eventos del ratón:</p>
  <ul>
    <li><span class="negrita">OnMouseDown</span></li>
    <li><span class="negrita">OnMouseDrag</span></li>
    <li><span class="negrita">OnMouseEnter</span></li>
    <li><span class="negrita">OnMouseExit</span></li>
    <li><span class="negrita">OnMouseOver</span></li>
    <li><span class="negrita">OnMouseUp</span></li>
    <li><span class="negrita">OnMouseUpAsButton</span></li>
  </ul>
  
  <p>La <span class="negrita">clase Input</span> dispone de métodos que devuelven <span class="negrita">booleanos</span> cuando el usuario interactúa con una <span class="negrita">tecla</span>, un <span class="negrita">botón de ratón</span> o un <span class="negrita">botón virtual</span> como <span class="cursiva">"Fire1"</span>.</p>
  
  <p>Estos métodos suelen usarse dentro de <span class="negrita">Update</span>, ya que se ejecuta con mucha frecuencia.</p>
  <a href="UD3/images/ud3-2024-01-29-19-21-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-19-21-12.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>Ejemplos:</p>
  <ul>
    <li>Input.GetKeyDown(KeyCode.E)</li>
    <li>Input.GetKey(KeyCode.V)</li>
    <li>Input.GetKeyUp(KeyCode.Space)</li>
    <li>Input.GetMouseButtonDown(0)</li>
    <li>Input.GetMouseButton(1)</li>
    <li>Input.GetMouseButtonUp(2)</li>
    <li>Input.GetMouseButtonUp("Fire1")</li>
    <li>Input.GetMouseButton("Jump")</li>
  </ul>
  
  <p>Consulta todos los métodos en la <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Input.html">documentación</a>.</p>
  
  <p>La <span class="negrita">clase Input</span> también tiene métodos para capturar valores de <span class="negrita">ejes de movimiento</span>.</p>
  
  <p>Estos devuelven un <span class="negrita">float</span>. En reposo, el eje vale 0; al pulsar, regresa un valor entre -1 y 1 (según aceleración o recorrido del joystick).</p>
  <p>Ejes disponibles:</p>
  <ul>
    <li><span class="negrita">Horizontal</span> y <span class="negrita">Vertical</span>: w, a, s, d, cursores, joystick, d-pad.
      <ul>
        <li>Input.GetAxis("Horizontal")</li>
        <li>Input.GetAxis("Vertical")</li>
      </ul>
    </li>
    <li><span class="negrita">Mouse X</span> y <span class="negrita">Mouse Y</span>: movimiento del ratón.
      <ul>
        <li>Input.GetAxis("Mouse X")</li>
        <li>Input.GetAxis("Mouse Y")</li>
      </ul>
    </li>
  </ul>
  
  <h3>Movimiento usando la clase Input</h3>
  <p>Gracias a <span class="negrita">Input</span>, <span class="negrita">puedes mover GameObjects</span> cuando el usuario interactúa con los <span class="negrita">dispositivos de entrada</span>.</p>
  
  <p>Con la cámara orientada como indica el gizmo, en el siguiente código:</p>
  <ul>
    <li>Flecha ↑ o W &rarr; <span class="negrita">mover</span> hacia delante (alejarse de la cámara).</li>
    <li>Flecha ↓ o S &rarr; <span class="negrita">mover</span> hacia atrás (acercarse a la cámara).</li>
    <li>Flecha ← o A &rarr; <span class="negrita">mover</span> a la izquierda.</li>
    <li>Flecha → o D &rarr; <span class="negrita">mover</span> a la derecha.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-12-50-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-50-54.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <section><pre><code class="language-csharp">public class CubeTransformScript : MonoBehaviour
{
    public float translationSpeed = 5;
    
    void Update()
    {
        Debug.Log("Input.GetAxis(\"Horizontal\"): " + Input.GetAxis("Horizontal"));
        transform.Translate(
            Input.GetAxis("Horizontal") * translationSpeed * Time.deltaTime,
            0,
            Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime * -1
        );
    }
}</code></pre>
  </section><br><br>
  <a href="UD3/images/ud3-2024-01-31-12-51-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-51-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Otra variante:</p>
  <ul>
    <li>Flecha ↑ o W &rarr; <span class="negrita">mover</span> hacia delante.</li>
    <li>Flecha ↓ o S &rarr; <span class="negrita">mover</span> hacia atrás.</li>
    <li>Flecha ← o A &rarr; <span class="negrita">rotar</span> a la izquierda.</li>
    <li>Flecha → o D &rarr; <span class="negrita">rotar</span> a la derecha.</li>
  </ul>
  <section><pre><code class="language-csharp">transform.Translate(Vector3.forward * Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime);
transform.Rotate(Vector3.up * Input.GetAxis("Horizontal") * rotationSpeed * Time.deltaTime);</code></pre>
  </section><br><br>
  <a href="UD3/images/ud3-2024-01-31-12-55-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-55-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con cualquiera de los dos códigos, si la cámara está colocada detrás del GameObject con la misma orientación en X y la haces hija del GameObject, la cámara lo seguirá al moverse.</p>
  <a href="UD3/images/ud3-2024-01-31-12-55-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-55-32.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <hr><br>
  <div class="tarea">
    <p>
      <span class="subrayado negrita">Actividad 6. Modificar GameObjects con Inputs</span> <br>
      Crea un proyecto 3D llamado <span class="subrayado">InputsTuNombre</span>. <br>
      Pon la vista de la cámara como si fuese un juego 2D (eje Z hacia atrás). <br>
      Añade un plano y dale tamaño 15x15x15 en (0, 0, 0). <br>
      Añade una <span class="negrita">Capsule</span> en (0, 1, 0). <br>
      Añade una <span class="negrita">Cube</span> en (3, 0.5, 0). <br>
      Añade una <span class="negrita">Sphere</span> en (6, 0.5, 0). <br>
      Crea un material naranja para la cápsula, azul para el cubo y verde para la esfera. <br>
      Duplica el cubo y repártelo por el plano (unas 20 copias). <br>
      Crea un script para la cápsula y programa:
      <ul>
        <li>Con los ejes Horizontal y Vertical, mover la cápsula por el plano.</li>
        <li>Con la tecla <span class="negrita">E</span>, escalar la esfera +0.5 en todos los ejes.</li>
        <li>Con la tecla <span class="negrita">Q</span>, escalar la esfera −0.5 en todos los ejes, sin bajar nunca de 0.5.</li>
      </ul>
      Crea un script para la cámara que haga que siempre mire a la cápsula.
    </p>
  </div>
</section><!-- End section La clase Input-->

<a id="#sInput_System_Package"></a> 
<!--*********************************************************Input System Package***********************************************************-->
<section class="apartado">
<a id="sInput_System_Package"></a>
<h2>Input System Package</h2>
<p>Es el nuevo sistema de Input de Unity, en las versiones nuevas viene activado por defecto, pero si no estuviera activado, hay que activarlo desde <span class="negrita">Project Settings → Player</span>.

En la sección <span class="negrita">Other Settings</span>  busca <span class="negrita">Active Input Handling</span> .

<br>Opciones que aparecen:
<ul>
  <li><span class="negrita">Input Manager (old)</span>  → sistema clásico (Input.GetKey, Input.GetAxis…).</li>
  <li><span class="negrita">Input System Package (new)</span> → el nuevo sistema basado en acciones.</li>
  <li><span class="negrita">Both</span> → compatibilidad con ambos (útil durante migración).</li>
</ul>

<br>
Selecciona <span class="negrita">Input System Package (new) o Both</span> si quieres probarlo sin perder el antiguo. Unity pedirá reiniciar el editor.</p>

<a href="UD3/images/UD3_2025-09-24-19-09-57.png"><figure><img src="UD3/images/UD3_2025-09-24-19-09-57.png" /><br><figcaption></figcaption></figure></a>
<br>

<p>Si no dispones de Input System, abre <span class="negrita">Window → Package Manager</span>. Busca <span class="r-word">Input System</span>  y pulsa <span class="negrita">Install</span> .
Tras la instalación, Unity añade soporte para: Ratón, teclado, mando, móvil/touch, VR, etc
</p>

<p>En el nuevo sistema <span class="negrita">Input System Package</span> , todas las entradas se guardan en un Asset.</p>
<p>En ese Asset se deben configurar todas las posibles <span class="negrita">Input Actions</span>  (acciones de entrada) que se quiera que tenga el videojuego.</p>
<p>Una Input Action es una acción que realiza el jugador con el controlador que esté utilizando, que puede ser el teclado, el ratón, un gamepad, pantalla táctil…</p>

<a href="UD3/images/UD3_2025-09-26-17-37-10.png"><figure><img src="UD3/images/UD3_2025-09-26-17-37-10.png" /><br><figcaption>InputAction</figcaption></figure></a>
<br>

<p>Las Input Actions se agrupan en Action Maps que serían los diferentes esquemas a usar dependiendo de la parte del juego en la que se esté.</p>

<p>Por ejemplo:
  <ul>
<li>Menú.</li>
<li>Jugador.</li>
<li>Conduciendo coche.</li>
<li>Nadar.</li>
<li>Mapa.</li>
<li>…</li>
  </ul>
</p>

<a href="UD3/images/UD3_2025-09-26-17-38-41.png"><figure><img src="UD3/images/UD3_2025-09-26-17-38-41.png" /><br><figcaption>Action Maps</figcaption></figure></a>
<br>

<p>Por defecto unity incluye la definición de las <span class="negrita">Input Actions</span> más típicas tanto para movimiento, acciones, 
  como para navegar por la UI.</p>

<p>Para acceder a las Input Actions para consultarlas/modificarlas hay dos opciones:
  <ul>
<li>Hacer <span class="negrita">doble clic en el asset</span>.</li>
<li><span class="negrita">Menú &rarr; Edit &rarr; Project Settings</span>… &rarrb;
			<span class="negrita">sección Input System Package</span>.</li>
  </ul>
</p>

<p>Como se puede observar, con las Input Actions creadas por defecto, 
  ya se tienen mapeadas las acciones más habituales tanto de movimiento como de navegación por la UI.</p>

<p>Si se necesitan más Maps y/o Actions simplemente se deben añadir en esta ventana.</p>

<p>Si por alguna razón el proyecto no dispone por defecto del Asset para Input System desde <span class="negrita">Menú &rarr; Edit &rarr; Project Settings</span>…,
  <span class="negrita">sección Input System Package</span> se puede volver a crear.</p>

<a href="UD3/images/UD3_2025-09-27-22-32-52.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-32-52.png" /><br><figcaption></figcaption></figure></a>
<br>

<p>Con esta configuración por defecto ya se puede acceder a los eventos de entrada de un teclado y de un gamepad directamente desde el código.</p>

<p>Hay tres maneras de mover al personaje mediante Input System:</p>
<ul>
  <li><span class="negrita">Detección directa</span> mediante la clase <span class="r-word">Keyboard</span> o <span class="r-word">Gamepad</span> .</li>
  <li><span class="negrita">Detección de Actions</span> mediante la clase <span class="r-word">InputAction</span> .</li>
  <li><span class="negrita">Detección de Actions y componente Player Input</span> mediante la clase <span class="r-word">PlayerInput</span> .</li>
</ul>

<h3>Detección directa</h3>

<p>La primera opción es la más sencilla pero menos flexible, ya que se está atado a un dispositivo concreto.</p>
<p>Es la técnica menos recomendable por no ser escalable y por la necesidad de tener que codificar cada acción a cada input (trigger is hardcoded) por lo que para cambiar la entrada se deberá cambiar el código.</p>
<a href="UD3/images/UD3_2025-09-27-22-36-04.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-36-04.png" /><br><figcaption></figcaption></figure></a>
<br>

<p>Ejemplo de detección directa:</p>
<a href="UD3/images/UD3_2025-09-27-22-35-48.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-35-48.png" /><br><figcaption>Detección directa</figcaption></figure></a>
<br>

<h3>Detección de Actions</h3>

<p>Esta es la técnica más recomendable para la mayoría de los proyectos y la que veremos aquí</p>
<a href="UD3/images/UD3_2025-09-27-22-40-10.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-40-10.png" /><br><figcaption></figcaption></figure></a>
<br>
<p>Mediante la detección de Actions se separa la lógica de los dispositivos físicos aumentando la escalabilidad y mejorando el mantenimiento.</p>

<p>Consiste en crear un objeto de la clase <span class="r-word">InputAction</span> para cada acción que se quiera detectar.</p>
<p>Estas acciones se configuran en el Asset de Input System y se pueden agrupar en Action Maps.</p>
<p>El código no está atado a ningún dispositivo concreto, ya que la configuración de las acciones se hace en el Asset.</p>
<p>Si se quiere cambiar la entrada que activa una acción, solo hay que cambiar la configuración en el Asset, sin tocar el código.</p>
<p class="sub-section">Ejemplo de detección de Actions:</p>
<p>A continuación, se estudiará cómo utilizar la detección de Actions para manejar al personaje mediante movimiento físico de manera básica.</p>
<p>Para el ejemplo se usará como base una escena que además de los elementos por defecto contiene:
  <ul>
<li>Canvas (desactivado con una imagen de pausa)</li>
<li>Plano con una imagen como material para poder apreciar el movimiento.</li>
<li>Cápsula a modo de jugador</li>
  </ul>
</p>
<p>La cápsula tiene:
  <ul>
    <li>Un Rigidbody para poder aplicar salto (con la rotación en X y en Z congelada para que no vuelque).</li>
    <li>Un cilindro como hijo para apreciar que rota al moverse la cámara.</li>
    <li>La cámara principal como hija para que la siga al moverse.</li>
  </ul>
</p>

<p>El primer paso será configurar dos acciones nuevas en el Input System Package, tanto en el Action Map <span class="negrita">Player</span>
   como en el Action Map <span class="negrita">UI</span>, las dos se llamarán <span class="cursiva">Pause</span>.</p>

<p>A las dos acciones nuevas se le añadirán dos <span class="negrita">Bindings</span> para poder usar tanto el teclado como el gamepad:
  <ul>
<li>Tecla Enter.</li>
<li>Botón Start.</li>
  </ul>
</p>

<p>Para realizar el Binding se puede pulsar en la casilla de <span class="negrita">Path</span> y una de las siguientes opciones:
  <ul>
<li>Buscar en la lista directamente</li>
<li>Pulsar en la casilla de <span class="negrita">Path</span>, luego en el botón <span class="negrita">Listen</span> y seleccionar la opción que reconozca Unity.</li>
  </ul>
</p>
<a href="UD3/images/UD3_2025-09-27-22-50-57.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-50-57.png" /><br><figcaption></figcaption></figure></a>
<br>
<a href="UD3/images/UD3_2025-09-27-22-51-13.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-51-13.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Es muy importante que cada Binding tenga marcada su opción correcta <span class="r-word">Keyboard&Mouse</span> o <span class="r-word">Gamepad</span>.</p>

<p>El siguiente paso es crear un script que se llamará <span class="d-word">Movement</span> que se añadirá a la Cápsula (jugador) con toda la lógica de movimiento.</p>

<p>Como se ha estudiado anteriormente todo movimiento físico se debe realizar en el método <span class="r-word">FixedUpdate</span>, así que el salto también se debe aplicar en ese método.</p>

<p>A diferencia del movimiento, el salto es algo puntual y se debe detectar nada más se realice la Action y no se puede dejar a la suerte de que se pulse justo en el momento en el que se ejecuta FixedUpdate.</p>

<p>Para solucionar esto en el método Update se detectará la <span class="negrita">Action jump</span> y se guardará en una propiedad que se evaluará en FixedUpdate para realizar el salto.</p>
<p>A continuación veremos un ejemplo del Script utilizado y explicaremos algunas partes de su código:</p>
<p>Incluimos la librería</p>
<section><pre><code class="language-csharp">using UnityEngine.InputSystem;</code></pre>
</section><br><br>
<p>Definimos una variable InputAction de tipo <span class="r-word">InputActionAsset</span> que posteriormente asignaremos en el inspector:</p>
<section><pre><code class="language-csharp">[SerializeField] private InputActionAsset InputActions;</code></pre>
</section><br><br>

<p>Declaramos tantas variables cono <span class="negrita">InputAction</span> vamos a utilizar</p>
<section><pre><code class="language-csharp">private InputAction moveAction;
    private InputAction lookAction;
    private InputAction jumpAction;
    private InputAction pauseActionPlayer;
    private InputAction pauseActionUI;</code></pre>
</section><br><br>

<p>En cada <span class="negrita">Update</span> nos quedamos con el valor del Action correspondiente con su método <span class="r-word">ReadValue</span></p>
<section><pre><code class="language-csharp">moveAmt = moveAction.ReadValue&lt;Vector2&gt;();
lookAmt = lookAction.ReadValue&lt;Vector2&gt;();</code></pre> </section><br><br>

<p>Activamos el Action Map que vamos a utilizar, un buen lugar es en el <span class="r-word">OnEnable</span></p>
<section><pre><code class="language-csharp">private void OnEnable()
{
    InputActions.FindActionMap("Player").Enable();
}</code></pre><section><br><br>

  <p>En cada <span class="negrita">Update</span> comprobamos si se ha dado a <span class="cursiva">Pause</span> y quien le ha dado. 
    Es decir, si estamos jugando sin <span class="cursiva">Pause</span>, el Action activo será el del <span class="negrita">player</span>
     y el de <span class="negrita">UI</span> estará deshabilitado y viceversa</p>

<section><pre><code class="language-csharp">private void DisplayPause()
{
    // Según se detecte la pausa en un Action Map u otro se activan/desactivan los diferentes elementos
    if (pauseActionPlayer.WasPressedThisFrame())
    {
        Time.timeScale = 0; // Para el tiempo y se detienen todos los elementos del juego
        PauseDisplayGO.SetActive(true);
        InputActions.FindActionMap("Player").Disable();
        InputActions.FindActionMap("UI").Enable();
    }
    else if (pauseActionUI.WasPressedThisFrame())
    {
        Time.timeScale = 1; // Vuelve a poner en marcha el tiempo
        PauseDisplayGO.SetActive(false);
        InputActions.FindActionMap("Player").Enable();
        InputActions.FindActionMap("UI").Disable();
    }
}</code></pre>
</section><br><br>

<p>El salto lo hacemos con un AddForce que veremos más adelante</p>
<section><pre><code class="language-csharp">private void Jump()
{
    myRigidbody.AddForce(Vector3.up * JumpForce, ForceMode.Impulse);
}</code></pre>
</section><br><br>

<p>Aquí tienes el código completo y comentado para su estudio:</p>
<section><pre><code class="language-csharp">using UnityEngine;
using UnityEngine.InputSystem;

public class Movement : MonoBehaviour
{
    // Propiedad para poder acceder a las Input Actions definidas
    [SerializeField] private InputActionAsset InputActions;
    // Propiedades para enlazar las Input Action
    private InputAction moveAction;
    private InputAction lookAction;
    private InputAction jumpAction;
    private InputAction pauseActionPlayer;
    private InputAction pauseActionUI;
    // Propiedades para almacenar la cantidad de movimiento detectada
    private Vector2 moveAmt;
    private Vector2 lookAmt;
    // Propiedad para acceder al Rigidbody propio
    private Rigidbody myRigidbody;
    // Propiedades para definir la velocidad de andar, de saltar y de rotar
    [SerializeField] private float WalkSpeed = 5;
    [SerializeField] private float JumpForce = 5;
    [SerializeField] private float RotateSpeed = 60;
    // Propiedad para poder acceder al Canvas con el menú de pausa
    [SerializeField] private GameObject PauseDisplayGO;
    // Propiedad para detectar en el método update que se desea saltar
    private bool wantJump = false;

    // Método que se ejecuta cuando el GameObject está activo
    private void OnEnable()
    {
        // Para poder usar un Action Map (esquema) primero se debe activar
        InputActions.FindActionMap("Player").Enable();
    }

    // Método que se ejecuta cuando el GameObject se desactiva
    private void OnDisable()
    {
        // Se desactiva el Action Map del jugador
        InputActions.FindActionMap("Player").Disable();
    }

    // Método que se ejecuta cuando el script se está cargando
    private void Awake()
    {
        // Se enlazan las Actions con las propiedades creadas para un acceso posterior más simple
        moveAction = InputActions.FindAction("Move");
        lookAction = InputActions.FindAction("Look");
        jumpAction = InputActions.FindAction("Jump");
        // Si en diferentes Action Map existe la misma Action se debe indicar a la hora de buscar la Action
        pauseActionPlayer = InputActions.FindAction("Player/Pause");
        pauseActionUI = InputActions.FindAction("UI/Pause");
        // Se almacena el Rigidbody propio en la propiedad
        myRigidbody = GetComponent&lt;Rigidbody&gt;();
    }

    // Update is called once per frame
    void Update()
    {
        // Se almacena la entrada recogida por la Action
        moveAmt = moveAction.ReadValue&lt;Vector2&gt;();
        lookAmt = lookAction.ReadValue&lt;Vector2&gt;();
        // Se detecta que se quiere saltar
        if (jumpAction.WasPressedThisFrame())
        {
            wantJump = true;
        }
        // Se llama al método DisplayPause para comprobar si se ha pulsado la Action pause
        DisplayPause();
    }

    // FixedUpdate is called every fixed framerate frame
    private void FixedUpdate()
    {
        // Si se quiere saltar se llama al método Jump y se resetea la propiedad wantJump
        if (wantJump)
        {
            Jump();
            wantJump = false;
        }
        // Se llama a los métodos que realizarán el movimiento y el giro
        Walking();
        Rotating();
    }

    private void Jump()
    {
        myRigidbody.AddForce(Vector3.up * JumpForce, ForceMode.Impulse);
    }

    private void Walking()
    {
        // Se calcula el Vector3 de movimiento según los datos recogidos en la entrada
        Vector3 moveDir = transform.forward * moveAmt.y   // W y S
                        + transform.right * moveAmt.x;    // A y D
        // Velocidad de movimiento actual
        Vector3 vel = myRigidbody.linearVelocity;
        // Velocidad de movimiento que se debe aplicar
        Vector3 targetVel = moveDir * WalkSpeed;
        // Se aplica la fuerza de movimiento (velocidad lineal) al Rigidbody
        myRigidbody.linearVelocity = new Vector3(targetVel.x, vel.y, targetVel.z);
    }

    private void Rotating()
    {
        // Rotación deseada en grados por segundo, se debe convertir a radianes
        float rotation = lookAmt.x * RotateSpeed * Mathf.Deg2Rad;
        // Velocidad de rotación actual
        Vector3 angVel = myRigidbody.angularVelocity;
        // Se aplica la fuerza de rotación (velocidad angular) al Rigidbody
        myRigidbody.angularVelocity = new Vector3(angVel.x, rotation, angVel.z);
    }

    private void DisplayPause()
    {
        // Según se detecte la pausa en un Action Map u otro se activan/desactivan los diferentes elementos
        if (pauseActionPlayer.WasPressedThisFrame())
        {
            Time.timeScale = 0; // Para el tiempo y se detienen todos los elementos del juego
            PauseDisplayGO.SetActive(true);
            InputActions.FindActionMap("Player").Disable();
            InputActions.FindActionMap("UI").Enable();
        }
        else if (pauseActionUI.WasPressedThisFrame())
        {
            Time.timeScale = 1; // Vuelve a poner en marcha el tiempo
            PauseDisplayGO.SetActive(false);
            InputActions.FindActionMap("Player").Enable();
            InputActions.FindActionMap("UI").Disable();
        }
    }
}
</code></pre>
</section><br><br>

<p>Una vez añadido el Script a la cápsula se deberán arrastrar tanto el Asset <span class="negrita">InputSystem_Actions</span> como el 
  GameObject Canvas a sus casillas correspondientes en el inspector.</p>
<a href="UD3/images/UD3_2025-09-27-23-11-41.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-23-11-41.png" /><br><figcaption></figcaption></figure></a>
<br>

<p>Esta es una primera aproximación al movimiento del personaje, pero válida para iniciarse.</p>

<p>Tiene determinadas limitaciones como el hecho de que, si se deja de mover el personaje en mitad de un salto, 
  no mantendrá la inercia en el salto.</p>

  <a href="UD3/images/EjemploInput.gif" target="_BLANK"><figure><img src="UD3/images/EjemploInput.gif" /><br><figcaption></figcaption></figure></a>
  <br>
  

<div class="tarea">
  <p>Actividad 7. Realiza el ejemplo de arriba</p>
</div>



<h3>Detección de Actions y componente Player Input</h3>
<p>Esta es la técnica extiende a la detección de Actions.</p>
<a href="UD3/images/UD3_2025-09-27-22-41-45.png" target="_BLANK"><figure><img src="UD3/images/UD3_2025-09-27-22-41-45.png" /><br><figcaption></figcaption></figure></a>
<br>

<p>Permite tener métodos C# propios y conectarlos a las Actions configuradas de manera que se llama automáticamente a esos métodos cuando el usuario realice una Action.</p>
<p>El componente Player input es idóneo para juegos multijugador en local permitiendo crear instancias nuevas de un jugador al detectar un dispositivo nuevo.</p>

<p>En el <a class="enlace" target="_blank" href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RpLvO3B7aH-ObfcOifMD20">Input System Tutorials</a> (oficial de Unity) se explica el uso básico de la detección de Actions y se introduce también el componente Player.</p>


</p>
</section><!-- End section Input System Package-->

<!--*********************************************************Movimiento cinemático y movimiento físico***********************************************************-->
<section class="apartado">
  <a id="sMovimiento_cinematico_y_movimiento_fisico"></a>
  <h2>Movimiento cinemático y movimiento físico</h2>
  <p>Tipos de movimiento en Unity:</p>
  <ul>
    <li><span class="negrita">Cinemático</span>:
      <ul>
        <li>Movimiento aplicado directamente al componente Transform del GameObject.</li>
        <li>Independiente de la física del juego (gravedad, aceleración, impulsos, inercia, fricción…).</li>
      </ul>
    </li>
    <li><span class="negrita">Físico</span>:
      <ul>
        <li>Movimientos que usan el motor de física.</li>
        <li>El GameObject debe tener el componente <span class="negrita">Rigidbody</span>.</li>
      </ul>
    </li>
  </ul>
  
  <p>Al añadir <span class="r-word">Rigidbody</span> a un GameObject, su configuración aparece en el Inspector.</p>

  <a href="UD3/images/UD3_2025-09-26-17-31-19.png"><figure><img src="UD3/images/UD3_2025-09-26-17-31-19.png" /><br><figcaption>Rigibody properties</figcaption></figure></a>
  <br>
  
  <p>Una vez añadido un Rigidbody a un GameObject, en el inspector se puede ver su configuración.</p>
  <p>Propiedades de <span class="negrita">Rigidbody</span>:
  <ul>
    <li><span class="negrita">Mass</span>: peso en kilogramos.</li>
    <li><span class="negrita">Linear Damping</span>: resistencia al movimiento lineal.</li>
    <li><span class="negrita">Angular Damping</span>: resistencia a la rotación.</li>
    <li><span class="negrita">Use Gravity</span>: si le afecta la gravedad.</li>
    <li><span class="negrita">Is Kinematic</span>: si está activado, el GameObject no se ve afectado por el motor físico 
      (solo se manipula con su Transform; útil para detección de colisiones).</li>
    <li><span class="negrita">Constraints</span>: permite bloquear coordenadas.</li>
  </ul>
 
  <p>Con movimientos cinemáticos (sin física), al mover un GameObject se <span class="negrita">teletransporta</span> a la nueva posición.</p>
  
  <p>Si un GameObject tiene <span class="negrita">Rigidbody</span>, no es recomendable modificar su posición vía Transform, porque podría aparecer parcialmente dentro de otro objeto y provocar colisiones no deseadas.</p>
  
  <p>Para mover un GameObject con Rigidbody, hay que <span class="negrita">aplicar fuerzas</span> que lo empujen en una dirección.</p>
  
  <p>Si <span class="negrita">no</span> hay interacción con Input, usa <span class="negrita">FixedUpdate</span>. Si <span class="negrita">sí</span> la hay, usa <span class="negrita">Update</span>.</p>
  
  <h3>Movimiento físico</h3>
  <p>Ejemplo de movimiento físico:</p>
  <section><pre><code class="language-csharp">using UnityEngine;
using UnityEngine.InputSystem;   // Necesario para el nuevo Input System

public class CubeScript : MonoBehaviour
{
    public float linealForce = 25f;
    public float angularForce = 10f;

    private Rigidbody rb;
    [SerializeField] private InputActionAsset InputActions;
    
    private InputAction moveAction;

    private void Awake()
    {
        moveAction = InputActions.FindAction("Move");
    }

    private void OnEnable()
    {
        InputActions.FindActionMap("Player").Enable();
    }

    private void OnDisable()
    {
        InputActions.FindActionMap("Player").Disable();
    }

    void Update()
    {
        
    }

    void Start()
    {
        rb = GetComponent&lt;Rigidbody&gt;();
    }

    private void FixedUpdate()
    {
        // Leemos los valores de entrada para la aceleración y el giro   
        float acceleration = moveAction.ReadValue&lt;Vector2&gt;().y;
        float spin = moveAction.ReadValue&lt;Vector2&gt;().x;     

        // Aplicamos las fuerzas de empuje y giro al Rigidbody
        rb.AddForce(transform.forward * acceleration * linealForce);
        rb.AddTorque(transform.up * spin * angularForce);
    }
}
</code></pre>
  </section><br><br>
  
  <p>Con el código anterior, hay que tener en cuenta los <span class="negrita">materiales físicos</span>: la fricción puede hacer que el comportamiento no sea el esperado.</p>
  
  <p>El suelo aporta fricción y, al empujar, el objeto puede inclinarse hacia delante.</p>
  
  <p>Además, por la fricción, al aplicar fuerzas el objeto tarda un poco en moverse y, al dejar de aplicarlas, se detiene gradualmente.</p>
  <a href="UD3/images/ud_3-2024-10-03-10-50-48.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-03-10-50-48.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para resolverlo puedes:</p>
  <ul>
    <li>Crear <span class="negrita">materiales físicos</span> para más realismo, configurándolos y asignándolos a superficies y personajes.</li>
    <li>Usar <span class="negrita">Constraints</span> en el Rigidbody para bloquear posición y/o rotación en cualquiera de los tres ejes.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-13-32-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-32-07.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para aplicar fuerzas necesitas una referencia a <span class="negrita">Rigidbody</span> en el código.</p>
  
  <p>Algunos métodos útiles:</p>
  <ul>
    <li><span class="negrita">AddForce</span>: aplica fuerzas de empuje en coordenadas de mundo.</li>
    <li><span class="negrita">AddTorque</span>: aplica fuerzas de rotación en coordenadas de mundo.</li>
    <li><span class="negrita">AddRelativeForce</span>: aplica empuje en coordenadas locales.</li>
    <li><span class="negrita">AddRelativeTorque</span>: aplica rotación en coordenadas locales.</li>
    <li><span class="negrita">AddForceAtPosition</span>: aplica fuerza en una posición concreta.</li>
    <li><span class="negrita">AddExplosionForce</span>: simula explosiones.</li>
  </ul>
  
  <p>Estas funciones tienen una sobrecarga que permite especificar el tipo de fuerza:</p>
  <ul>
    <li><span class="negrita">ForceMode.Force</span>: depende de la masa (F = m * a).</li>
    <li><span class="negrita">ForceMode.Acceleration</span>: aplica aceleración, ignorando la masa.</li>
    <li><span class="negrita">ForceMode.Impulse</span>: aplica fuerza instantánea en un frame (suele usarse en Update).</li>
    <li><span class="negrita">ForceMode.VelocityChange</span>: aplica directamente un cambio de velocidad.</li>
  </ul>
  
  <p>Usando solo movimientos físicos puedes mantener la inercia en cualquier eje.</p>
  <section><pre><code class="language-csharp">public class CubeScript : MonoBehaviour
{
    public float speed = 2;
    public float translationSpeed = 5;
    public float rotationSpeed = 180;
    public float jumpForce = 8f;
    private Rigidbody rb;
        
    void Start()
    {
        rb = GetComponent&lt;Rigidbody&gt;();        
    }

    void Update()
    {
        // Ojo, input manager antiguo Input.GetAxis("Vertical"), cambiar por moveAction.ReadValue&lt;Vector2&gt;().y      
        transform.Translate(Vector3.forward * Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime);

        transform.Translate(Vector3.up * Input.GetAxis("Horizontal") * rotationSpeed * Time.deltaTime);

        if(Input.GetButtonDown("Jump")){
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
    }
}</code></pre>
  </section><br><br>

<p>Existen muchos métodos y propiedades para aplicar fuerzas a un Rigidbody, su uso dependerá del tipo de Gameobject.
  (Se debe consultar la documentación para conocer todas las posibilidades ya que también hay métodos como MovePosition o MoveRotation que transporta el GameObject que pueden no ser recomendables).</p>


<p>Al personaje:
  <ul>
    <li>Se le cambiarán las propiedades <span class="negrita">linearVelocity</span> y <span class="negrita">angularVelocity</span> para el movimiento y el giro, entre otras.</li>
<li>Se le aplicará una fuerza vertical con <span class="negrita">AddForce</span> para el <span class="negrita">salto</span>.</li>
<li>Se le aplicará una fuerza con <span class="negrita">AddForce</span> o <span class="negrita">AddTorque</span> si es empujado por otro GameObject.</li>
  </ul>
</p>

<p>A un vehículo:
  <ul><li>Se le aplicará una fuerza con <span class="negrita">AddForce</span> y/o <span class="negrita">AddTorque</span> para el movimiento y el giro.</li>
  </ul>
</p>

<p>A un objeto:
  <ul><li>Se le aplicará una fuerza con <span class="negrita">AddForce</span> y/o <span class="negrita">AddTorque</span> por ejemplo si es empujado.</li>
  </ul>
</p>
<p>A un proyectil:
  <ul>Se le aplicará una fuerza con <span class="negrita">AddForce</span> y/o <span class="negrita">AddTorque</span>.</ul>
</p>


  <hr><br>
  <div class="tarea">
    <p>
      <span class="subrayado negrita">Actividad 8. Rigidbody y seguimiento de cámara</span> <br>
      Abre el proyecto <span class="subrayado">InputsTuNombre</span>. <br>
      Añade <span class="negrita">Rigidbody</span> a la cápsula. <br>
      Configura los <span class="negrita">Constraints</span> para que no se tumbe al colisionar. <br>
      Si programaste la cápsula sin rotación con A y D, cambia al modo que rota. <br>
      Añade <span class="negrita">Rigidbody</span> a la esfera. <br>
      Desactiva el script de la cámara. <br>
      Coloca la vista detrás de la cápsula como en la imagen (eje Z hacia atrás). <br>
      <a href="UD3/images/ud3-2024-02-01-10-37-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-10-37-56.png" /><br><figcaption></figcaption></figure></a>
      <br><br>
      Selecciona la cámara y usa <span class="negrita">Menú &rarr; GameObject &rarr; Align With View</span>. <br><br>
      Haz la cámara hija de la cápsula. <br><br>
      Ejecuta y mueve la cápsula: la cámara debería seguirla y la cápsula colisionar con otros GameObjects gracias al Rigidbody.
    </p>
  </div>
</section><!-- End section Movimiento cinemático y movimiento físico-->
  
  <!--*********************************************************Colisiones***********************************************************-->
<section class="apartado">
  <a id="sColisiones"></a>
 <h2>Colisiones</h2>
<p>Para detectar colisiones entre GameObjects, deben tener un componente <span class="r-word">Collider</span> 
  (normalmente presente en la mayoría de GameObjects).</p>

<p>Unity ofrece dos mecanismos para detectar colisiones entre GameObjects:
  <ul>
    <li>Mediante <span class="negrita">Collider</span>.</li>
    <li>Mediante <span class="negrita">Trigger</span> (Collider marcado como <span class="cursiva">Is Trigger</span>, usado habitualmente en GameObjects sin representación gráfica en pantalla).</li>
  </ul>
</p>

<p>Es habitual usar el nombre del GameObject o su <span class="negrita">Tag</span> para distinguir colisiones.</p>

<h3>Colisiones con Collider</h3>
<p>Las <span class="negrita">colisiones con Collider</span> se usan cuando un GameObject toca a otro.</p>

<p>Por ejemplo:
  <ul>
    <li>El jugador empuja otro GameObject.</li>
    <li>Un GameObject impacta contra otro, como un disparo.</li>
    <li>…</li>
  </ul>
</p>

<p>Los colliders pueden ser 3D o 2D, y la clase MonoBehaviour ofrece métodos que se disparan cuando se detecta la colisión entre colliders.</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter(Collision collision)</span>: se ejecuta en el frame en el que comienza la colisión.</li>
    <li><span class="negrita">void OnCollisionStay(Collision collision)</span>: se ejecuta mientras la colisión persiste.</li>
    <li><span class="negrita">void OnCollisionExit(Collision collision)</span>: se ejecuta en el frame en el que finaliza la colisión.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionStay2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionExit2D(Collision collision)</span></li>
  </ul>
</p>

<p>En los métodos se recibe un objeto <span class="negrita">Collision</span>, que permite acceder a todos los aspectos de la colisión y al otro GameObject.</p>

<p>Se pueden ejecutar acciones al colisionar con otros GameObjects.</p>
<a href="UD3/images/ud3-2024-01-31-13-40-49.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-40-49.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>A través del objeto de colisión se puede acceder a todos los elementos del GameObject implicado.</p>
<a href="UD3/images/ud3-2024-01-31-13-41-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-41-02.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<h3>Colisiones con Trigger</h3>
<p>Las <span class="negrita">colisiones con Trigger</span> se usan para determinar si un GameObject está dentro de una zona concreta.</p>
<p>Por ejemplo:
  <ul>
    <li>Un GameObject tiene un collider mayor que su tamaño para detectar si el jugador está a rango, de modo que al pulsar una tecla pueda recogerse (consumible) o activarse (interruptor).</li>
    <li>Un GameObject vacío con un collider que detecta si el jugador está dentro.</li>
    <li>…</li>
  </ul>
</p>

<p>Para actuar como Trigger, un GameObject debe tener marcada la opción <span class="negrita">Is Trigger</span> en el Inspector dentro del componente Collider.</p>

<p>A veces los GameObjects que actúan como Trigger solo tienen los componentes Transform y Collider, ya que no necesitan ser visibles.</p>

<p>Si un collider está marcado como <span class="cursiva">Is Trigger</span>, la clase MonoBehaviour ofrece los siguientes métodos:</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter(Collider other)</span>: se ejecuta en el frame en el que comienza la superposición.</li>
    <li><span class="negrita">void OnTriggerStay(Collider other)</span>: se ejecuta mientras la superposición persiste.</li>
    <li><span class="negrita">void OnTriggerExit(Collider other)</span>: se ejecuta en el frame en el que finaliza la superposición.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerStay2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerExit2D(Collider other)</span></li>
  </ul>
</p>

<p>En estos casos, el otro objeto se recibe como un <span class="negrita">Collider</span>, que es el collider del otro GameObject implicado.</p>
<p>Para el GameObject que se mueve:</p>
<a href="UD3/images/ud3-2024-01-31-13-44-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-44-02.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>Para el GameObject configurado como <span class="negrita">Is Trigger</span>:</p>
<a href="UD3/images/ud3-2024-01-31-13-44-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-44-10.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>En el siguiente ejemplo, un GameObject invisible con un Collider aplica una fuerza para hacer que otro GameObject flote dentro de él, 
  siempre que el otro GameObject tenga un componente Rigidbody:</p>
<a href="UD3/images/ud3-2024-01-31-13-45-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-45-12.png" /><br><figcaption></figcaption></figure></a>
<br><br>
</section><!-- End section Colisiones-->

  
  <!--*********************************************************Métodos interesantes***********************************************************-->
  <section class="apartado">
    <a id="sMetodos_Intersantes"></a>
    <h2>Métodos interesantes</h2>
    <h3>Método Destroy</h3>
    <p>El método <span class="r-word">Destroy</span> elimina el GameObject. Si no se especifica tiempo, se elimina inmediatamente. Si se indica un tiempo, se eliminará tras esos segundos.</p>
    <a href="UD3/images/ud3-2024-01-31-13-47-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-47-43.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Método Instantiate</h3>
    <p>El método <span class="r-word">Instantiate</span> permite crear GameObjects en tiempo de ejecución.</p>
    
    <p>Ejemplos de uso:
      <ul>
        <li>Cuando el jugador dispara, el proyectil debe crearse en ese punto y moverse en la dirección a la que apunta.</li>
        <li>En una zona de la escena aparece un enemigo por arriba, cae y desaparece al llegar abajo 
          (bucle con Instantiate, movimiento, detección por trigger al llegar abajo y Destroy).</li>
      </ul>
    </p>
    
    <p>Se crea un objeto cuando se pulsa el botón "<span class="cursiva">Fire1</span>" (botón izquierdo del ratón).</p>
    <a href="UD3/images/ud3-2024-01-31-13-49-03.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-03.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Cuando el jugador toca el GameObject, este se replica 10 veces.</p>
    <a href="UD3/images/ud3-2024-01-31-13-49-19.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-19.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Se crea un objeto a intervalos fijos de tiempo sin requerir acción.
    Se aplica una fuerza al GameObject creado en el momento de su creación, lanzándolo hacia delante.
    </p>
    <a href="UD3/images/ud3-2024-01-31-13-49-37.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-37.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-01-31-13-49-55.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-55.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Utilidades</h3>
    <p>Con los métodos <span class="r-word">Invoke</span> e <span class="r-word">InvokeRepeating</span> se puede indicar el tiempo de espera antes de llamar a otro método.</p>
    
    <a href="UD3/images/ud3-2024-01-31-13-50-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-50-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Las invocaciones activas pueden cancelarse con <span class="r-word">CancelInvoke</span>.</p>
    <p>Si no se pasa parámetro, se cancelan todas; si se pasa el nombre de un método, se cancela solo esa invocación.</p>
    
    <a href="UD3/images/ud3-2024-01-31-13-50-52.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-50-52.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Otra forma de realizar tareas similares a <span class="r-word">InvokeRepeating</span> es mediante <span class="negrita">Corrutinas</span>.</p>
    <a href="UD3/images/ud3-2024-01-31-13-51-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-51-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Las corrutinas pueden cancelarse con <span class="negrita">StopAllCoroutines</span> y <span class="negrita">StopCoroutine("NombreMetodo")</span>.</p>
    
    
    <br><br>
    <hr>
    <br>
    <div id="task1" class="tarea">
      <p><span class="subrayado negrita">Práctica 1 – Arkanoid</span></p>

      <p>La práctica constará en reproducir una pantalla (inventada, cada uno la suya) del famoso juego 
        <a class="enlace" target="_blank" href="https://es.wikipedia.org/wiki/Arkanoid">Arkanoid</a>. 
        Aunque podría hacerse con un motor 2D usaremos la plantilla 3D que hemos usado hasta ahora y solo jugaremos con dos ejes.
      </p>
      <p>El juego consiste en destruir una serie de bloques con una bola que se mueve rebotando en las paredes y en la barra que maneja el jugador. 
        Si la bola cae por debajo de la barra, el jugador pierde una vida. El juego termina cuando se destruyen todos los bloques (destruibles) 
        o se pierden todas las vidas.
      </p>
      <p>El juego debe incluir:
        <ul>
          <li>Una barra que se mueve horizontalmente con las teclas A y D o las flechas izquierda y derecha. Hasta el final de la pantalla</li>
          <li>Una bola que se mueve rebotando en las paredes, la barra y los bloques. Tendrás que calcular ángulos de rebote</li>
          <li>Una serie de bloques que dispondrás como tú quieras y aplicarás materiales distintos. <br>Tipos de bloques: <span class="negrita">Elige 2 de las 3 opcionales</span><ul>
            <li>Bloques normales que desaparecen al ser golpeados por la bola.</li>
            <li>Bloques resistentes que necesitan dos impactos para desaparecer. Cambian de color tras el primer impacto.</li>
            <li>Bloques indestructibles que no desaparecen al ser golpeados por la bola, ni disparados.</li>
            <li>Bloques que cuando lo destruyes cae un objeto (decide tú que es) en vertical hacía abajo y
              si lo tocas con la barra te incrementa en uno el número de vidas. (<span class="negrita">opcional</span>)</li>
              <li>Bloques que cuando los detruyes, aceleran la bola x1.5 durante 10 segundos.  (<span class="negrita">opcional</span>)</li>
              <li>Bloques que cuando lo destruyes cae un objeto (decide tú que es) en vertical hacía abajo y
              si lo tocas con la barra te permite disparar vertical y hacía arriba, cuando toque un bloque tendrá el mismo efecto que la bola, pero no rebotará, desaparecerá.
            Sólo podrá haber 3 "balas" en pantalla a la vez. Si te quitan la vida, pierdes la habilidad de disparar.  (<span class="negrita">opcional</span>)</li>

          </ul></li>
          <li>Un sistema de puntuación que sume puntos al destruir bloques. 10 puntos por bloque/toque, es decir si un bloque se destruye con 3 golpes valdrá 30 puntos.</li>
          <li>Un sistema de vidas que reste una vida al perder la bola. Tendrás 3 vidas.</li>
          <li>Al inicio y tras cada vida, la bola estará pegada a la barra, que si podrá desplazarse y al pulsar la tecla espacio es cuando saldrá despedia hacía arriba con una angulo aleatorio entre 10º y 170º.</li>
          <li>Cuando finalice por vidas o porque no quedan bloques detruibles, mostrará en el centro de la pantalla la puntuación, junto con tu nombre y apellidos. Estando aquí y al pulsar "intro" se resetea la partida</li>
        </ul>
      </p>

      <p>Para la entrega, crea un paquete con los elementos necesarios de la(s) escena(s) y graba un vídeo (máx. 5 minutos) mostrando la funcionalidad del juego y cómo has implementado las características más importantes.</p>
    </a>
  </div> <!--END OCULTO-->

  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>