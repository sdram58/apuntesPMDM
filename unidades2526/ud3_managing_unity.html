<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD3.- Managing Unity</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">    
      
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Manejo de Unity">1.- Manejo de Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Añadir GameObjects a la escena">2.- Añadir GameObjects a la escena</a>
      <a href="#sMateriales" title="3.- Materiales">3.- Materiales</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- Componentes de GameObject">4.- Componentes de GameObject</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- La clase GameObject">7.- La clase GameObject</a>
      <a href="#sEl_componente_Transform" title="8.- El componente Transform">8.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="9.- La clase Input">9.- La clase Input</a>
    </div>
    <div class="fila">
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="10.- Movimiento cinemático y físico">10.- Movimiento cinemático y físico</a>
      <a href="#sColisiones" title="11.- Colisiones">11.- Colisiones</a>
      <a href="#sMetodos_Intersantes" title="12.- Métodos interesantes">12.- Métodos interesantes</a>
    </div>
    <div class="fila">      
      <a href="#sComponenteCharacterController" title="13.- Componente CharacterController">13.- Componente CharacterController</a>
      <a href="#sCamaraprofesional" title="14.- Cámara profesional">14.- Cámara profesional</a>
      <a href="#sMovimientoProgramado" title="15.- Movimiento programado">15.- Movimiento programado</a>
    </div>
    
    <div class="fila">      
      <a href="#sRaycast" title="16.- Raycast">16.- Raycast</a>
      <a href="#sNPCs" title="17.- NPCs">17.- NPCs</a>
      <a href="#sCambiodeescenas" title="18.- Cambio de escenas">18.- Cambio de escenas</a>
    </div>
    <div class="fila">      
      <a href="#sPlayerPrefs" title="19.- PlayerPrefs">19.- PlayerPrefs</a>
      <a href="#sMenus" title="20.- Menús">20.- Menús</a>
      <a href="#sComunicacion" title="21.- Comunicación entre GameObjects">21.- Comunicación entre GameObjects</a>
    </div>
    
  </nav> <!-- BTM_MENU-->
  
  <h1>UD3.- Gestión de Unity</h1> 

  
  <div class="main-menu">  
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Manejo de Unity">1.- Manejo de Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Añadir GameObjects a la escena">2.- Añadir GameObjects a la escena</a>
      <a href="#sMateriales" title="3.- Materiales">3.- Materiales</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- Componentes de GameObject">4.- Componentes de GameObject</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- La clase GameObject">7.- La clase GameObject</a>
      <a href="#sEl_componente_Transform" title="8.- El componente Transform">8.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="9.- La clase Input">9.- La clase Input</a>
    </div>
    <div class="fila">
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="10.- Movimiento cinemático y físico">10.- Movimiento cinemático y físico</a>
      <a href="#sColisiones" title="11.- Colisiones">11.- Colisiones</a>
      <a href="#sMetodos_Intersantes" title="12.- Métodos interesantes">12.- Métodos interesantes</a>
    </div>
    <div class="fila">      
      <a href="#sComponenteCharacterController" title="13.- Componente CharacterController">13.- Componente CharacterController</a>
      <a href="#sCamaraprofesional" title="14.- Cámara profesional">14.- Cámara profesional</a>
      <a href="#sMovimientoProgramado" title="15.- Movimiento programado">15.- Movimiento programado</a>
    </div>
    
    <div class="fila">      
      <a href="#sRaycast" title="16.- Raycast">16.- Raycast</a>
      <a href="#sNPCs" title="17.- NPCs">17.- NPCs</a>
      <a href="#sCambiodeescenas" title="18.- Cambio de escenas">18.- Cambio de escenas</a>
    </div>
    <div class="fila">      
      <a href="#sPlayerPrefs" title="19.- PlayerPrefs">19.- PlayerPrefs</a>
      <a href="#sMenus" title="20.- Menús">20.- Menús</a>
      <a href="#sComunicacion" title="21.- Comunicación entre GameObjects">21.- Comunicación entre GameObjects</a>
    </div>

  </div>


  <section class="apartado">
    <a name="sManejo_de_Unity"></a>
    <h2>Manejo de Unity</h2>
    <p>Es muy importante aprender cómo funciona la ventana <span class="negrita">Scene View</span> para trabajar correctamente con los <span class="negrita">GameObjects</span>.</p>
    
    <p>La <span class="negrita">Scene View</span> es donde ves los objetos que forman parte de la escena.</p>
    
    <p>En esta ventana suelen aparecer <span class="negrita">gizmos</span>. Un gizmo es un gráfico que ayuda al desarrollador mostrando información de un GameObject dentro de la escena.</p>
    
    <p>Por ejemplo, si seleccionas la luz de la escena, verás un gizmo que indica la dirección de la luz.</p>
    <a href="UD3/images/ud3-2024-01-25-11-22-45.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-11-22-45.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>El sistema de coordenadas permite posicionar todos los GameObjects en la escena.</p>
    
    <p>Cada GameObject tendrá coordenadas que indican su posición.</p>
    
    <p>Unity utiliza un sistema <span class="negrita">Y-Up</span>:
      <ul>
        <li><span class="negrita">x</span>: eje horizontal</li>
        <li><span class="negrita">y</span>: eje vertical</li>
        <li><span class="negrita">z</span>: eje de profundidad</li>
      </ul>
    </p>
    <a href="UD3/images/ud3-2024-01-25-11-59-29.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-11-59-29.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Unreal y Blender usan Z-Up (el eje vertical es <span class="negrita">z</span> y el de profundidad es <span class="negrita">y</span>).</p>
    <p>En la <span class="negrita">esquina superior derecha</span> de Scene View aparece un <span class="negrita">Scene Gizmo</span> muy útil que indica la dirección desde la que se está viendo la escena.</p>
    <a href="UD3/images/ud3-2024-01-25-12-00-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-00-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Al hacer clic en los conos cambias la vista para alinearla con ese eje.</p>

    
    <p>Debajo del gizmo se muestra la vista actual, que puede indicar “Persp” u otra dirección como “Back”. Si haces clic en el cubo central o en el texto de la vista actual, cambias a vista isométrica.</p>
    
    <p>Si desarrollas en 3D, la vista cambiará constantemente; si desarrollas en 2D, la vista por defecto puede no ser la adecuada y conviene cambiarla.</p>
    
    <p>En la parte superior de la ventana están estas herramientas:</p>
    <a href="UD3/images/ud3-2024-01-25-12-01-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-01-47.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>A la izquierda:
      <ul>
        <li><span class="negrita">Center / Pivot</span>: determina si el <em>handle</em> de transformación se coloca en el centro de la selección (<em>Center</em>) o en el <em>pivot</em> propio de cada objeto (<em>Pivot</em>).</li>
        <li><span class="negrita">Global / Local</span>: controla si los ejes de transformación usan las coordenadas globales del mundo (<em>Global</em>) o los ejes locales del objeto (<em>Local</em>).</li>
        <li>Conmutador de cuadrícula (mostrar/ocultar).</li>
        <li>Ajuste a cuadrícula (<em>Snap</em>) al mover.</li>
        <li>Pasos del <em>snap</em> al mover un GameObject.</li>
      </ul>
    </p>
    
    <p>A la derecha:
      <ul>
        <li>Modo de visualización de los GameObjects (sólido, <em>wireframe</em>, etc.).</li>
        <li>Cambiar entre vista 3D u ortográfica 2D.</li>
        <li>Conmutar la iluminación de la escena.</li>
        <li>Conmutar el sonido.</li>
        <li>Conmutar efectos (cielo, niebla, etc.).</li>
        <li>Mostrar/ocultar recuento de GameObjects ocultos.</li>
        <li>Configuración de cámara de la vista.</li>
        <li>Visibilidad de <em>gizmos</em>.</li>
      </ul>
    </p>
    
    <p>En la esquina superior izquierda tienes las herramientas para navegar y manipular GameObjects:</p>
    <a href="UD3/images/ud3-2024-01-25-12-09-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-09-50.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Estas herramientas muestran un <span class="negrita">gizmo</span> sobre el GameObject seleccionado que facilita la manipulación.</p>
    <a href="UD3/images/ud3-2024-01-25-12-11-24.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-12-11-24.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <a href="UD3/images/movement_shample.gif" target="_BLANK"><figure><img src="UD3/images/movement_shample.gif" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Todos los GameObjects tienen un <span class="negrita">pivot</span>, desde el que se aplican los cambios.</p>
    
    <p>Por defecto, el <span class="negrita">pivot</span> está en el centro del GameObject, por eso el gizmo de las herramientas parte del centro del objeto seleccionado.</p>
    
      <a href="UD3/images/ud3-2024-01-25-13-50-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-50-41.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>El <span class="negrita">pivot</span> no puede moverse dentro de Unity (sí puedes ajustarlo en un DCC como Blender o usar un GameObject vacío como offset).</p>
    
      <h3>Mover la cámara de Scene View</h3>
    
      <p class="sub-section">Con teclado:</p>
      <p>
        <ul>
          <li><span class="negrita">W / A / S / D</span> + botón derecho mantenido: desplazamiento libre (<em>fly</em>).</li>
          <li><span class="negrita">Q / E</span>: bajar / subir.</li>
          <li><span class="negrita">F</span>: centrar la vista en el objeto seleccionado (<em>Frame Selected</em>).</li>
          <li><span class="negrita">Shift</span>: aumenta la velocidad de desplazamiento.</li>
        </ul>
      </p>
      
      
      <p class="sub-section">Con ratón:</p>
      <p>
        <ul>
          <li>Con la herramienta mano seleccionada <img style="vertical-align: baseline"  src="UD3/images/ud_3-2024-09-30-10-53-07.png" />, clic y arrastrar: desplazamiento horizontal/vertical (pan).</li>
          <li>Botón central (rueda): <em>pan</em>.</li>
          <li>Rueda: <em>zoom</em> (acercar/alejar).</li>
          <li>Botón derecho mantenido: rotar la cámara sobre su eje.</li>
          <li><span class="negrita">Alt</span> + botón izquierdo: orbitar alrededor del punto de mira.</li>
          <li><span class="negrita">Alt</span> + botón derecho: <em>dolly</em> (zoom continuo).</li>
        </ul>
      </p>
    
      <p>Cualquier GameObject puede alinearse con la vista.</p>
    
      <p>Esto es útil con cámaras porque permite alinear la <span class="negrita">Camera</span> a la vista para que, al ejecutar el juego, sea esa la vista mostrada.</p>
      
      <a href="UD3/images/ud3-2024-01-25-13-53-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-53-48.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      
      <p>Como se ha comentado, si desarrollas un juego 2D conviene cambiar la vista de escena para que coincida con la vista del juego, donde el eje <span class="negrita">z</span> es horizontal y el <span class="negrita">y</span> vertical.</p>
      <a href="UD3/images/ud3-2024-01-25-13-54-45.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-54-45.png" /><br><figcaption></figcaption></figure></a>
      <br>

      <section class="marco-t tip">
        <span class="icono info"></span>
        <strong>Consejos útiles (Unity 6.x):</strong>
        <ul>
          <li><em>Vertex Snap</em>: mantén <span class="negrita">V</span> para arrastrar el gizmo al vértice más cercano y alinear objetos con precisión.</li>
          <li><em>Grid &amp; Snap</em>: ajusta los pasos desde <span class="negrita">Edit &rarr; Grid and Snap Settings</span>; mantén <span class="negrita">Ctrl</span> mientras arrastras para forzar el <em>snap</em>.</li>
          <li><em>Align with View</em>: con una <span class="negrita">Camera</span> seleccionada, usa <span class="negrita">Ctrl + Shift + F</span> para igualarla a la vista actual.</li>
        </ul>
      </section>
      <section class="marco-b"></section>
      
  </section><!-- End section Manejo de Unity-->

  
  
  <section class="apartado">
    <a name="sAgregando_GameObjects_a_la_escena"></a>
    <h2>Añadir GameObjects a la escena</h2>
    
    <p>Para añadir GameObjects a la escena, puedes hacer clic derecho en la zona de elementos de la escena (jerarquía) o seleccionar la opción correspondiente en el menú <span class="negrita">GameObject</span>.</p>
    
    <p>Desde el menú también tienes acciones para aplicar sobre un GameObject si está seleccionado.</p>
    <a href="UD3/images/ud3-2024-01-25-13-56-44.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-56-44.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Según el tipo de proyecto, habrá distintos tipos de GameObjects disponibles para añadir a la escena (puedes ampliar el catálogo añadiendo paquetes desde el <span class="negrita">Package Manager</span>).</p>
    
    <p>Se pueden añadir GameObjects vacíos, que sirven para agrupar otros GameObjects y ayudan a mantener organizada la jerarquía.</p>
    
    <p>También hay objetos 3D, que serán los primeros que utilicemos en clase.</p>
    
    <a href="UD3/images/ud3-2024-01-25-13-58-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-58-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-01-25-13-59-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-13-59-21.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Al añadir un GameObject a la escena, puedes renombrarlo desde la jerarquía (más tarde también puedes renombrarlo con clic derecho sobre él en la jerarquía).</p>
    
    <p>Además, cuando se añade, el GameObject se posiciona en el centro de la escena, independientemente de sus coordenadas anteriores.</p>
    <a href="UD3/images/ud3-2024-01-25-14-00-24.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-00-24.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Al seleccionar el GameObject en el Inspector, puedes ver sus componentes, incluyendo <span class="r-word">Transform</span>, que indica los valores de <span class="negrita">posición, rotación y escala</span>.</p>
    
    <p>Los GameObjects se añaden a la jerarquía como hijos de la escena.</p>
    
    <p>En la jerarquía, puedes organizar GameObjects dentro de otros arrastrándolos sobre el que deba contenerlos o sacándolos del que los contiene.</p>
    
    <p>Si haces clic derecho sobre un objeto en la jerarquía y añades un GameObject, se añadirá directamente como hijo del seleccionado.</p> 
    <a href="UD3/images/ud3-2024-01-25-14-01-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-01-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <section class="marco-t warn">
      <span class="icono warning"> </span>Todas las modificaciones realizadas a un GameObject afectan a todos los GameObjects que contiene en la jerarquía.
    </section>
    <section class="marco-b">
        
    </section>
    
    <h3>Punto de pivot de un GameObject</h3>
    <p><span class="negrita">Todos los GameObjects tienen un punto de pivot situado en su centro.</span></p>
    
    <p>Las coordenadas de este pivot en la escena son las que usa Unity para efectuar todos los cálculos necesarios.</p>
    
    <p>El pivot <span class="negrita">no puede moverse</span> dentro de Unity. (Salvo ajustándolo en programas de diseño como Blender.)</p>
    
    <p>El pivot también es la referencia cuando un GameObject sigue a otro; por ejemplo, una cámara que sigue a un personaje. En ese caso, la cámara seguirá el pivot del GameObject.</p>
    
    <p>Si quieres un centro de seguimiento diferente, puedes crear un GameObject vacío, añadirlo al GameObject principal en las coordenadas deseadas y hacer que la cámara siga al GameObject vacío.</p>
    
    <h3>Modificar GameObjects</h3>
    <p>Para modificar un GameObject debes seleccionarlo, ya sea desde la jerarquía o haciendo clic sobre él en la vista de la escena.</p>
    
    <p>Si haces doble clic en un GameObject de la jerarquía, además de seleccionarlo, la vista se centrará en él.</p>
    
    <p>Si haces clic en un GameObject en la vista de la escena, lo seleccionas y centras la vista donde has pulsado.</p>
    
    <p><span class="negrita">Todas las modificaciones de un GameObject usan el pivot como referencia.</span></p>
    
    <p>Hay varias formas de modificar un GameObject en la escena:</p>
    
    <p class="sub-section">Cambiar manualmente sus valores en el Inspector</p>
    
    <a href="UD3/images/ud3-2024-01-25-14-06-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-06-47.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Puedes colocar el GameObject en el origen de coordenadas (0,0,0).</p>
    
    <a href="UD3/images/ud3-2024-01-25-14-07-26.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-07-26.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Esta acción puede ser problemática porque el pivot está centrado por defecto. Al mover a (0,0,0), el GameObject puede quedar como en la imagen, con la mitad por debajo del punto (0,0,0).</p>
    <a href="UD3/images/ud3-2024-01-25-14-07-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-07-47.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p class="sub-section">Usar el Inspector pasando el cursor por una coordenada</p>
    <p>El cursor cambiará y podrás hacer clic y arrastrar para variar el valor.</p>
    <a href="UD3/images/ud3-2024-01-25-14-08-44.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-08-44.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p class="sub-section">Con las herramientas mencionadas antes</p>
    <p>Puedes modificar un GameObject usando el ratón.</p>
    
    <p>Al seleccionarlo aparece un gizmo y, al interactuar con él con el ratón, podrás realizar las acciones necesarias.</p>
    
    <p>Cada gizmo funciona de forma distinta.</p>
    <a href="UD3/images/ud3-2024-01-25-14-09-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-09-56.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Movimiento solo en el eje X</p>
    <a href="UD3/images/ud3-2024-01-25-14-10-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-10-56.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Movimiento en los ejes no Y (plano X, Z):</p>
    <a href="UD3/images/ud3-2024-01-25-14-10-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-25-14-10-43.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Al usar herramientas con gizmos puedes utilizar <span class="negrita">snaps</span>.</p>
    
    <p>Los pasos por defecto del <em>snap</em> pueden cambiarse:</p>
    <a href="UD3/images/ud3-2024-01-26-09-28-26.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-28-26.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Para aplicar el <em>snap</em> mientras usas los gizmos, mantén pulsada la tecla <span class="negrita">Ctrl</span>.</p>
    
    <p>Todas las modificaciones usan el pivot como referencia.</p>
    
    <p>Puedes ajustar el punto de referencia a un vértice de la malla del GameObject. Para ello, pulsa la tecla <span class="negrita">V</span> tras seleccionar la herramienta.</p>
    
    <p>Al pulsar <span class="negrita">V</span>, verás que el gizmo se mueve al vértice más cercano al pasar el ratón sobre el GameObject.</p>
    
    <p>Esta acción se conoce como <em>vertex snap</em> y permite alinear GameObjects haciendo coincidir un vértice con el vértice de otro GameObject.</p>
    
    <a href="UD3/images/ud3-2024-01-26-09-29-17.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-29-17.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Unidades de medida</h3>
    <p>Por defecto, las unidades de medida en Unity son:
      <ul>
        <li><span class="negrita">Distancias</span>: metros.</li>
        <li><span class="negrita">Tamaños</span>: metros.</li>
        <li><span class="negrita">Peso (masa)</span>: kilogramos.</li>
        <li><span class="negrita">Tiempo</span>: segundos.</li>
      </ul>
    </p>
    
    <p>Es importante tenerlo en cuenta, ya que el comportamiento de los GameObjects con física depende de su tamaño y su masa.</p>
    
  </section><!-- End section Agregando GameObjects -->
  
  <section class="apartado">
    <a name="sMateriales"></a>
    <h2>Materiales</h2>
    <p>Los <span class="negrita">Materiales</span> permiten dar apariencia a los GameObjects.</p>
    
    <p>Para crear un material, haz clic derecho en el gestor de archivos y selecciona <span class="negrita">Create &rarr; Material</span>. Al crearlo podrás asignarle un nombre.</p>
    <a href="UD3/images/ud3-2024-01-26-09-32-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-32-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Es importante recordar que, para mantener la organización, los materiales deberían colocarse en una carpeta llamada <span class="inline-folder">Materials</span> dentro de <span class="inline-folder">Assets</span>.</p>
    
    <p>Un material en el gestor de archivos se representa con una esfera y, según la configuración aplicada en el Inspector, tendrá una apariencia diferente.</p>
       
    <a href="UD3/images/ud3-2024-01-26-09-33-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-33-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Con una buena configuración puedes conseguir materiales realistas.</p>
    
    <p>También puedes obtener materiales desde la <span class="negrita">Unity Asset Store</span> y desde repositorios en Internet.</p>
    <a href="UD3/images/ud3-2024-01-26-09-53-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-53-50.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Puedes aplicar un material a un GameObject de varias maneras:
      <ul>
        <li>Arrastrando el material sobre el GameObject en la jerarquía.</li>
        <li>Arrastrándolo sobre el GameObject en la vista de la escena.</li>  
        <li>Arrastrándolo al GameObject en el Inspector, en la zona de “Add Component”.</li>
      </ul>
    </p>
    
    <a href="UD3/images/ud3-2024-01-26-09-54-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-09-54-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <div class="tarea">
      <span class="negrita subrayado">Actividad 1</span>: Crea 3 materiales y aplícalos a los cubos como en la imagen anterior.</div>
    <br>
    <h3>Materiales físicos</h3>
    <p>Los materiales físicos (<span class="negrita">Physic Material</span>) permiten controlar cómo interactúan físicamente los GameObjects cuando colisionan entre sí.</p>
    
    <p>Se usan habitualmente para que los GameObjects reboten o para generar fricción entre ellos.</p>
    
    <p>Para crear un material físico, haz clic derecho en el gestor de archivos y elige <span class="negrita">Create &rarr; Physic Material</span>.</p>
    
    <p>Al crearlo deberás darle un nombre.</p>
    <a href="UD3/images/ud3-2024-01-26-10-05-23.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-05-23.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Los parámetros que pueden configurarse en un material físico son:</p>
    <a href="UD3/images/ud3-2024-01-26-10-05-53.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-05-53.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Puedes aplicar un material físico a un GameObject de varias formas:
      <ul>
        <li>Arrastrando el material sobre el GameObject en la jerarquía.</li>
        <li>Arrastrándolo sobre el GameObject en la vista de la escena.</li>
        <li>Arrastrándolo al GameObject en el Inspector, en la zona “Add Component”.</li>
      </ul>
    </p>
    
    <a href="UD3/images/ud3-2024-01-26-10-06-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-06-48.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 2: Construcción de la escena</span> <br>
        Crea un proyecto 3D en Unity llamado <span class="subrayado">SceneTuNombre</span>. <br>
        Configura la vista de cámara como si desarrollaras un juego 2D (eje Z hacia el fondo).<br>
        Añade un plano a la escena y modifica su tamaño para que sea poco profundo pero muy ancho (como una plataforma horizontal de izquierda a derecha). <br>
        Añade un cubo, una esfera, una cápsula y un cilindro a la escena. Ordénalos como quieras, pero todos deben compartir la misma coordenada Z que el plano. <br>
        Solo un objeto debe tocar la superficie del plano. <br>
        De los GameObjects que no tocan el plano, coloca uno alineado en Z con el que sí toca, desplázalo ligeramente en X (por encima del otro) y pon su Y más alta, en la parte superior de la escena. <br>
        Crea 5 materiales con colores y apariencias distintas y asigna cada uno a un GameObject. <br>
    
        Coloca la vista en un ángulo distinto al de la cámara: puedes rotarla y moverla, pero deben aparecer el plano y todos los objetos.
        <span class="oculto">Haz una captura de la vista de escena y nómbrala TuNombreUnity1.png</span>
        <span class="oculto">Haz una captura de la vista de juego durante la ejecución; nómbrala TuNombreUnity2.png. Comprime ambas capturas en un .rar o .zip llamado TuNombre y adjúntalo a la tarea.</span>
      </p>
    </div>
    
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 3: Eventos de MonoBehaviour</span> <br>
        Abre el proyecto SceneTuNombre. <br>
        Crea un script llamado <span class="negrita">EventsScript</span> y asígnalo al GameObject que está tocando la superficie. <br>
        En el script, añade instrucciones para mostrar mensajes en la consola con <span class="negrita">Debug.Log</span> para los eventos: <span class="negrita">Start</span>, <span class="negrita">Update</span>, <span class="negrita">OnMouseEnter</span> (cuando el ratón está sobre el GameObject) y <span class="negrita">OnMouseDrag</span> (cuando se hace clic y se arrastra el GameObject). <br>
        Los mensajes deben seguir el formato: "TuNombre (NombreEvento): TuMensaje".<br>
        <span class="oculto">
        Haz clic en el script en el gestor de archivos para que el código aparezca en el Inspector; ejecuta el juego y toma una captura donde se vea la consola y el Inspector (recuerda activar la opción <span class="negrita">Collapse</span> en la consola).
        Nombra la captura TuNombreUnity3.png. <br>
        Comprime la captura en un .rar o .zip llamado TuNombre y adjúntalo a la tarea.</span>
      </p>
    </div>
    
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Actividad 4: Gravedad</span> <br>
        Abre el proyecto SceneTuNombre. <br>
        Uno de los GameObjects está alineado verticalmente con el que tocaba la superficie. Añade un componente <span class="negrita">Rigidbody</span> al objeto situado en la parte superior de la escena. <br>
        Ejecuta el juego y observa qué ocurre. <br>
        Cambia la <span class="negrita">masa</span> de ese GameObject y vuelve a ejecutar para observar los cambios.<br>
        Ajusta otros parámetros del <span class="negrita">Rigidbody</span> y ejecuta para ver qué pasa. <br>
        <div class="oculto">Haz una captura de la ventana de juego antes de que caiga el cubo y nómbrala TuNombreUnity4.png. <br>
          Haz una captura cuando el cubo golpee al objeto inferior y nómbrala TuNombreUnity5.png. <br>
          Haz una captura cuando el cubo se detenga y nómbrala TuNombreUnity6.png. <br>
          Comprime las capturas en un .rar o .zip llamado TuNombre y adjúntalas a la tarea.</div>
      </p>
    </div>

    <br><br>
    <a href="UD3/images/demo_act_2_4.gif" target="_BLANK"><figure><img src="UD3/images/demo_act_2_4.gif" /><br><figcaption></figcaption></figure></a>
    
  </section><!-- End section Materials -->

  
  <!--*********************************************************Componentes de GameObject***********************************************************-->
<section class="apartado">
  <a name="sComponentes_de_GameObject"></a>
  <h2>Componentes de GameObject</h2>
  <p>Los GameObjects pueden contener distintos componentes.</p>
  
  <p>Como mínimo, todos los GameObjects tienen el componente <span class="negrita">Transform</span>, que indica la posición, rotación y escala del GameObject.</p>
  
  <p>Los GameObjects geométricos suelen tener una <span class="negrita">malla (Mesh)</span> y un <span class="negrita">Mesh Renderer</span> para poder dibujarse.</p>
  
  <p>Para detectar colisiones, los GameObjects utilizan un <span class="negrita">Collider</span>.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-00-53.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-00-53.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Puedes añadir otros componentes desde el <span class="negrita">Menú &rarr; GameObject</span> o desde el Inspector con el botón <span class="negrita">“Add Component”</span> al final.</p>
  
  <p>Al pulsar <span class="negrita">“Add Component”</span> se abre un buscador para escribir el nombre del componente que necesitas.</p>
  <a href="UD3/images/ud3-2024-01-26-10-02-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-02-02.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Cuando un GameObject debe verse afectado por la <span class="negrita">física</span> (gravedad, fuerzas, etc.), necesita un componente <span class="r-word">Rigidbody</span>.</p>
  
  <p>En el <span class="negrita">Rigidbody</span> se configura la <span class="negrita">masa</span> del GameObject (entre otros parámetros).</p>
  <a href="UD3/images/ud3-2024-01-26-10-03-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-03-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
</section><!-- End section Componentes de GameObject-->

<!--*********************************************************UI (Interfaz de usuario)***********************************************************-->
<section class="apartado">
  <a name="sUI"></a>
  <h2>UI (Interfaz de usuario)</h2>
  <p>La interfaz de usuario (UI) está formada por elementos añadidos a la escena para mostrar información o interactuar con el jugador.</p>
  
  <p>Con la UI puedes crear menús y el <span class="negrita">HUD</span> (Head-Up Display).</p>
  
  <p>Puede construirse con GameObjects 2D o 3D, aunque lo habitual es usar GameObjects 2D.</p>
  
  <p>Entre los GameObjects de UI están: texto, imágenes, deslizadores, barras de desplazamiento, botones o campos de texto.</p>
  
  <p>Los GameObjects de UI deben ser hijos de un <span class="negrita">Canvas</span>.</p>
  
  <p>Si añades un GameObject de UI y no existe <span class="negrita">Canvas</span> en la escena, Unity creará uno automáticamente.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-09-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-09-35.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <h3>UI — Texto</h3>
  <p>Hay dos GameObjects principales para añadir texto:</p>
  <ul>
    <li><span class="negrita">Text</span>: texto básico con opciones limitadas.</li>
    <li><span class="negrita">TextMeshPro</span>: texto avanzado con muchas opciones.</li>
  </ul>
  
  <p>Existen otros GameObjects de MeshPro que mejoran los tipos primitivos.</p>
  
  <p>Se recomienda usar <span class="negrita">TextMeshPro</span> siempre que sea posible.</p>
  <a href="UD3/images/ud3-2024-01-26-10-11-13.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-11-13.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>La primera vez que añadas un <span class="negrita">TextMeshPro</span> al proyecto, aparecerá una ventana para importar los paquetes necesarios. Pulsa <span class="cursiva">“Import TMP Essentials”</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-12-31.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-12-31.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para que los elementos del Canvas se muestren correctamente en pantalla, ajusta en el Inspector:</p>
  <ul>
    <li><span class="negrita">Render Mode</span>: <span class="negrita">Screen Space - Camera</span>.</li>
    <li>Arrastra la cámara de la jerarquía al campo <span class="negrita">Render Camera</span>.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-26-10-14-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-14-41.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-15-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-15-02.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/demo_canvas_text.gif" target="_BLANK"><figure><img src="UD3/images/demo_canvas_text.gif" /><br><figcaption></figcaption></figure></a>
  <br>

  <h3>UI — Imágenes (Sprites)</h3>
  <p>Para añadir imágenes a la UI, dichas imágenes deben ser <span class="d-word">sprites</span>.</p>
  
  <p>Un sprite es una imagen de mapa de bits que representa una unidad mínima (por ejemplo, el gráfico de un botón o de un personaje).</p>
  
  <p>Una imagen puede contener uno o varios sprites.</p>
  
  <p>Cada sprite puede añadirse a la escena como GameObject independiente.</p>
  
  <p>Si una imagen agrupa varios sprites, <span class="negrita">optimiza</span> la carga de recursos.</p>
  
  <p>Los sprites se usan para componer personajes completos y animar partes por separado, o para animaciones por <span class="cursiva">frames</span> cambiando el sprite de un GameObject.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-28-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-28-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Primer paso: añade el paquete <span class="negrita">2D Sprite</span> desde <span class="negrita">Menú &rarr; Window &rarr; Package Manager</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-30-33.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-30-33.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Esto instala la herramienta <span class="negrita">Sprite Editor</span>.</p>
  
  <p>Después, arrastra las imágenes al gestor de archivos dentro de una carpeta <span class="inline-folder">Sprites</span>.</p>
  
  <p>Selecciona la imagen y en el Inspector cambia <span class="negrita">Texture Type</span> a <span class="negrita">Sprite (2D and UI)</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-31-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-31-40.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Así aparecerá el botón <span class="negrita">Sprite Editor</span>. Al abrirlo, podrás crear el sprite desde la imagen.</p>
  
  <p>Si la imagen solo contiene un sprite y dejas el modo <span class="cursiva">Single</span>, al abrir el editor se convertirá automáticamente.</p>
  
  <p>Cuando una imagen se convierte en sprite, aparece una flecha en su previsualización dentro del gestor de archivos.</p>
  <a href="UD3/images/ud3-2024-01-26-10-32-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-32-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>El editor permite modificar el sprite.</p>
  <a href="UD3/images/ud3-2024-01-26-10-33-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-33-21.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si la imagen contiene varios sprites, establece <span class="negrita">Sprite Mode</span> en <span class="negrita">Multiple</span>. Es importante que el fondo de la imagen sea transparente.</p>
  <a href="UD3/images/ud3-2024-01-26-10-34-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-34-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>En el editor podrás seleccionar y nombrar manualmente cada sprite.</p>
  <a href="UD3/images/ud3-2024-01-26-10-35-15.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-35-15.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>La opción <span class="negrita">Trim</span> ajusta el contorno al contenido (mejor con fondo transparente).</p>
  <a href="UD3/images/ud3-2024-01-26-10-35-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-35-48.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="negrita">Outline Tolerance</span> y <span class="negrita">Generate</span> puedes generar el contorno; pulsa <span class="negrita">Apply</span> para guardar.</p>
  <a href="UD3/images/ud3-2024-01-26-10-37-14.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-37-14.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si los sprites están en una rejilla, usa el menú <span class="negrita">Slice</span>:</p>
  <ul>
    <li><span class="negrita">Automatic</span>: detecta sprites por contenido.</li>
    <li><span class="negrita">Grid By Cell Size</span>: especifica el tamaño de celda.</li>
    <li><span class="negrita">Grid By Cell Count</span>: especifica filas y columnas.</li>
  </ul>
  <p>Después pulsa <span class="negrita">Slice</span> para generarlos.</p>
  
  <a href="UD3/images/ud3-2024-01-26-10-39-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-39-10.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-39-17.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-39-17.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-40-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-40-12.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para hojas de animación, revisa el <span class="negrita">pivot</span> que usa cada sprite para que la animación funcione correctamente (a menudo está en el centro, pero puede variar).</p>
  
  <p>Al desplegar la flecha de la imagen en el gestor de archivos verás la lista de sprites y sus nombres.</p>
  <a href="UD3/images/ud3-2024-01-26-10-41-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-41-11.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para usar un sprite, arrástralo a la jerarquía o a la vista de la escena para crear un GameObject que lo muestre.</p>
  <a href="UD3/images/ud3-2024-01-26-10-52-04.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-52-04.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>También puedes crear un GameObject <span class="negrita">UI &rarr; Image</span> y asignar el sprite arrastrándolo a <span class="negrita">Source Image</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-52-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-52-56.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-26-10-53-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-53-10.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
</section><!-- End section UI (Interfaz de usuario) -->

<!--*********************************************************Prefabs***********************************************************-->
<section class="apartado">
  <a name="sPrefabs"></a>
  <h2>Prefabs</h2>
  <p>Un <span class="r-word">Prefab</span> es un GameObject con todas sus características (tamaño, rotación, escala, materiales, texturas, física, etc.) guardadas como un <span class="negrita">asset</span>.</p>
  
  <p>Una vez guardado como prefab, <span class="negrita">puede instanciarse desde un script</span>.</p>
  
  <p>Ejemplo típico: objetos que sueltan los enemigos al desaparecer.</p>
  
  <p>Los prefabs son fáciles de exportar para reutilizarlos en otros proyectos.</p>
  
  <p>Para crear un prefab, arrastra el objeto desde la jerarquía al gestor de archivos.</p>
  
  <p>Por organización, coloca los prefabs en la carpeta <span class="inline-folder">Prefabs</span>.</p>
  <a href="UD3/images/ud3-2024-01-26-10-55-31.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-55-31.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>En la jerarquía, un GameObject que proviene de un prefab aparece con el nombre en <span class="negrita">azul</span>.</p>
  
  <p>En el gestor de archivos verás la previsualización del prefab.</p>
  <a href="UD3/images/ud3-2024-01-26-10-56-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-56-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Seleccionando el prefab, el Inspector muestra sus características y componentes.</p>
  <a href="UD3/images/ud3-2024-01-26-10-56-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-56-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Un GameObject de la escena que proviene de un prefab puede modificarse sin afectar al prefab original.</p>
  <a href="UD3/images/ud3-2024-01-26-10-57-23.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-57-23.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para editar el prefab en sí, haz doble clic en el asset del prefab.</p>
  
  <p>Los cambios en el prefab se replicarán en todos los GameObjects instanciados a partir de él.</p>
  <a href="UD3/images/ud3-2024-01-26-10-57-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-57-56.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Puedes añadir tantas copias de un prefab a la escena como necesites.</p>
  
  <p>Desde un script, también puedes instanciar prefabs en tiempo de ejecución.</p>
  <a href="UD3/images/ud3-2024-01-26-10-58-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-26-10-58-35.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <hr><br>
  <div class="tarea">
    <p><span class="subrayado negrita">Actividad 5. Imágenes y Prefabs</span> <br>
      Abre el proyecto <span class="subrayado">SceneTuNombre</span>. <br>
      Añade un GameObject Cubo, crea un material nuevo y asígnalo. <br>
      Crea 5 copias de ese cubo y ordénalas formando una figura (puedes rotar y escalar). <br>
      Crea un GameObject vacío y agrupa en él los 6 cubos (cuida las coordenadas). <br>
      Crea un Prefab a partir de ese GameObject vacío. <br>
      Añade un texto a la escena con tu nombre. <br>
      Añade una foto tipo carné tuya (actual). <br><br>
      <div class="oculto">Haz una captura de toda la ventana de Unity durante la ejecución, donde se vea el prefab en el gestor de archivos y los GameObjects en la vista de escena. Nómbrala <span class="negrita">TuNombreUnity7.png</span>.<br>
      Comprime la captura en un .rar o .zip llamado <span class="negrita">TuNombre</span> y adjúntalo a la tarea.</div>
    </p>
  </div>
</section><!-- End section Prefabs-->

<!--*********************************************************La clase GameObject***********************************************************-->
<section class="apartado">
  <a name="sLa_Clase_GameObject"></a>
  <h2>La clase GameObject</h2>

  <h3>Acceder a las propiedades de un GameObject</h3>
  <p>Desde un script añadido a un GameObject puedes acceder a las propiedades del propio GameObject y a todos los componentes que tenga.</p>
  
  <p>Para ello se usa la variable <span class="r-word">gameObject</span> (en minúscula), que <span class="negrita">se inyecta automáticamente</span> al heredar de <span class="r-word">MonoBehaviour</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-10-56-27.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-56-27.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <a href="UD3/images/ud3-2024-01-29-10-56-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-56-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <a href="UD3/images/ud3-2024-01-29-10-57-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-57-11.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <a href="UD3/images/ud3-2024-01-29-10-57-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-10-57-50.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Todos los GameObjects tienen al menos un componente <span class="negrita">Transform</span> (posición, rotación y escala).</p>
  
  <p>Como está presente en <span class="subrayado">todos</span> los GameObjects, Unity inyecta directamente la propiedad <span class="negrita">transform</span>, que puedes usar tal cual o acceder a través de <span class="negrita">gameObject.transform</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-00-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-00-07.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para acceder a un <span class="negrita">componente distinto de Transform</span>, declara una propiedad y asígnale el componente con <span class="negrita">GetComponent</span>.</p>
  
  <p>Por ejemplo, para acceder al componente <span class="negrita">Collider</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-01-57.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-01-57.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <h3>Acceder a otros GameObjects</h3>
  <p>Para acceder a otros GameObjects desde un script, <span class="negrita">declara una propiedad de tipo GameObject</span> y <span class="negrita">asigna el GameObject deseado</span> (ej.: <span class="negrita">SphereGO</span> &rarr; <span class="negrita">G</span>ame<span class="negrita">O</span>bject).</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-03-58.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-03-58.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Formas de asignar el GameObject a la propiedad:</p>
  <ul>
    <li>Si la propiedad es <span class="negrita">public</span>, puedes <span class="negrita">arrastrar y soltar</span> el GameObject desde la jerarquía al campo del Inspector.
      <a href="UD3/images/ud3-2024-01-29-11-06-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-06-10.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>Desde el propio script, usando <span class="negrita">GameObject.Find</span> para buscar por <span class="negrita">nombre</span> (habitualmente con propiedad privada).
      <a href="UD3/images/ud3-2024-01-29-11-07-41.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-07-41.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>Asignando <span class="negrita">tags</span> a GameObjects y usando <span class="r-word">GameObject.FindGameObjectsWithTag</span> para buscar por <span class="negrita">tag</span>.
      <a href="UD3/images/ud3-2024-01-29-11-09-22.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-09-22.png" /><br><figcaption></figcaption></figure></a>
      <br><br>
      <p>En este caso, la variable <span class="negrita">debe ser un array</span>, ya que puede haber más de un GameObject con esa etiqueta.</p>
      <a href="UD3/images/ud3-2024-01-29-11-11-20.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-11-20.png" /><br><figcaption></figcaption></figure></a>
      <br>
<section><pre><code class="language-csharp">public class Test : MonoBehaviour
{
    public GameObject[] blueCubesGO;

    // Start is called before the first frame update
    void Start()
    {
        blueCubesGO = GameObject.FindGameObjectsWithTag("blueCubes");
        foreach (GameObject cubeGO in blueCubesGO)
        {
            Debug.Log("Cubo: " + cubeGO.name );
        }
    }

    // Update is called once per frame
    void Update(){
    }
}</code></pre>
</section><br><br>
      <a href="UD3/images/ud3-2024-01-29-11-12-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-12-54.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
  </ul>
  
  <p>Al acceder a otros GameObjects, también puedes usar sus componentes. Por ejemplo, este script (añadido a la <span class="negrita">Main Camera</span>) accede a un <span class="negrita">TextMeshProUGUI</span> y actualiza su texto.</p>
  
  <p>Para ello, arrastra el GameObject con el TextMeshProUGUI al campo correspondiente del Inspector (tras seleccionar la cámara).</p>
<section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class Test : MonoBehaviour
{
    public int points = 0;

    public TextMeshProUGUI pointsTMP;
    // Start is called before the first frame update
    void Start()
    {
        pointsTMP.text ="Points: " + points;
    }

    // Update is called once per frame
    void Update()
    {
        if(Input.GetKeyDown(KeyCode.Space)){
            pointsTMP.text ="Points: " + ++points;
        }
    }
}</code></pre>
</section><br><br>

  <h3>Acceder a componentes de otros GameObjects</h3>
  <p>Una vez tienes la referencia a otro GameObject con cualquiera de las técnicas anteriores, puedes acceder a sus componentes mediante <span class="negrita">GetComponent</span>, igual que haces con el GameObject actual.</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-15-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-15-43.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Si la propiedad que expone el componente es pública, <span class="negrita">al arrastrar el GameObject</span> al campo del Inspector, <span class="negrita">Unity asignará automáticamente el tipo de componente</span> correcto.</p>
  <a href="UD3/images/ud3-2024-01-29-11-16-38.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-16-38.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>También puedes acceder a scripts en otros GameObjects obteniendo la referencia al objeto destino y pidiendo el componente con el <span class="negrita">nombre del script</span>.</p>
  
  <p>Usa cualquiera de las técnicas previas para obtener esa referencia.</p>
  <a href="UD3/images/ud3-2024-01-29-11-18-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-18-28.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
</section><!-- End section La clase GameObject-->


  
  <!--*********************************************************El componente Transform***********************************************************-->
<section class="apartado">
  <a name="sEl_componente_Transform"></a>
  <h2>El componente Transform</h2>
  <p>El componente <span class="r-word">Transform</span> se compone de tres elementos:
    <ul>
      <li><span class="negrita">Position</span></li>
      <li><span class="negrita">Rotation</span></li>
      <li><span class="negrita">Scale</span></li>
    </ul>
  </p>
  <a href="UD3/images/ud3-2024-01-29-11-20-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-20-46.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Cada elemento especifica un valor para cada coordenada, a las que se puede acceder como se mostró antes.</p>
  
  <a href="UD3/images/ud3-2024-01-29-11-20-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-20-54.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <p>Para modificar <span class="negrita">posición</span>, <span class="negrita">rotación</span> y <span class="negrita">escala</span> se usan objetos de la clase <span class="r-word">Vector3</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-22-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-22-06.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>El código de la imagen representa las coordenadas: x=3, y=8, z=1.</p>
  
  <p>Los parámetros aceptados son números decimales (<span class="cursiva">float</span>), aunque también se pueden usar enteros.</p>
  
  <p>Si indicas un número decimal, debes añadir la letra <span class="negrita">f</span> al final:</p>
  <a href="UD3/images/ud3-2024-01-29-11-22-20.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-22-20.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Cambiar la posición de un GameObject</h3>
  <p>Para <span class="negrita">cambiar la posición</span> de un GameObject:</p>
  <ul>
    <li>
      Asigna <span class="negrita">un nuevo Vector3</span> a la propiedad <span class="negrita">position</span> de su <span class="negrita">Transform</span>:
      <a href="UD3/images/ud3-2024-01-29-11-23-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-23-18.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>
      Realiza operaciones sobre la propiedad <span class="negrita">position</span> del <span class="negrita">Transform</span> usando un <span class="negrita">Vector3</span>:
      <a href="UD3/images/ud3-2024-01-29-11-24-03.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-24-03.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
    <li>
      Usa el método <span class="r-word">Translate</span> del <span class="negrita">Transform</span>:
      <a href="UD3/images/ud3-2024-01-29-11-24-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-24-40.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <p>Con <span class="r-word">Translate</span> puedes indicar si usas el sistema local del objeto (por defecto) o el sistema del mundo (0, 0, 0):</p>
      <a href="UD3/images/ud3-2024-01-29-11-25-39.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-25-39.png" /><br><figcaption></figcaption></figure></a>
      <br>
    </li>
  </ul>
  
  <p>Además, la clase <span class="r-word">Vector3</span> incluye propiedades que devuelven vectores unidad alineados con los ejes:</p>
  <a href="UD3/images/ud3-2024-01-29-11-26-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-26-32.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>Puedes consultar todo lo disponible en la documentación:
    <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Vector3.html">https://docs.unity3d.com/ScriptReference/Vector3.html</a>
  </p>
  
  <p>Los objetos <span class="r-word">Vector3</span> también se pueden operar:</p>
  <a href="UD3/images/ud3-2024-01-29-11-27-08.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-27-08.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Rotar un GameObject</h3>
  <p class="sub-section">Alrededor de su propio eje</p>
  
  <p>Asigna un <span class="negrita">nuevo Vector3</span> a la propiedad <span class="negrita">rotation</span> del <span class="negrita">Transform</span> usando el método <span class="negrita">Euler</span> de <span class="negrita">Quaternion</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-29-15.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-29-15.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <p>La segunda opción es algo más verbosa pero útil si ya tienes un Vector3 o quieres manipular la rotación como vector antes de pasarlo a la función.</p>
  <br>
  
  <p>Usa la propiedad <span class="negrita">eulerAngles</span> (comportamiento similar al método anterior):</p>
  <a href="UD3/images/ud3-2024-01-29-11-30-49.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-30-49.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Usa el método <span class="negrita">Rotate</span> del <span class="negrita">Transform</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-30-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-30-56.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="negrita">Rotate</span> puedes elegir entre coordenadas locales del objeto (por defecto) o del mundo.</p>
  
  <p class="sub-section">Rotar alrededor de otro objeto</p>
  <p>Con <span class="r-word">RotateAround(origin, axis, speed)</span> puedes hacer que un GameObject rote alrededor de otro:</p>
  <a href="UD3/images/ud3-2024-01-29-11-32-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-32-50.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con <span class="r-word">LookAt(transformOtherGameObject)</span> puedes hacer que un GameObject siempre mire a otro GameObject:</p>
  <a href="UD3/images/ud3-2024-01-29-11-33-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-33-16.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Estas dos técnicas suelen usarse dentro del método <span class="negrita">Update</span> del script.</p>
  
  <h3>Escalar un GameObject</h3>
  <p>Para <span class="negrita">escalar</span> un GameObject, lo lógico es hacerlo respecto a su <span class="negrita">pivote</span>.</p>
  <p>Por ese motivo se usa la propiedad <span class="r-word">localScale</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-34-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-34-06.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Transform en la jerarquía</h3>
  <p>Cuando los GameObjects están agrupados, el componente Transform permite acceder a todos los Transforms y GameObjects del grupo.</p>
  <a href="UD3/images/ud3-2024-01-29-11-35-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-35-02.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-35-14.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-35-14.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>El orden de acceso a los hijos es el mismo que el orden en el que aparecen en la jerarquía.</p>
  <a href="UD3/images/ud3-2024-01-29-11-38-33.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-38-33.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>También puedes acceder al padre desde un GameObject hijo.</p>
  <a href="UD3/images/ud3-2024-01-29-11-39-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-39-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <h3>Movimiento con los métodos Update y FixedUpdate</h3>
  <p class="sub-section">Método Update</p>
  
  <p><span class="r-word">Update</span> se ejecuta una vez por frame.</p>
  
  <p>Si en <span class="negrita">Update</span> modificas el Transform (por ejemplo, sumando 0.01 a la X cada frame), el GameObject <span class="negrita">se mueve</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-40-35.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-40-35.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>El problema es que los FPS dependen del equipo y de la carga de la escena.</p>
  <a href="UD3/images/ud_3-2024-10-01-13-11-35.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-01-13-11-35.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-41-57.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-41-57.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>Para evitar que el movimiento dependa del frame rate, hay dos opciones:</p>
  <ul>
    <li>Multiplicar por <span class="r-word">Time.deltaTime</span>. Así el movimiento será consistente independientemente de los FPS (deltaTime es el tiempo entre el frame actual y el anterior).</li>
    <li>Usar <span class="r-word">FixedUpdate</span>, que por defecto se ejecuta a intervalos regulares (20 ms, 50 veces por segundo).</li>
  </ul>
  
  <p>Es común crear una propiedad <span class="negrita">speed</span> (float) para controlar la velocidad.</p>
  
  <p>Ejemplo: mover en X según <span class="negrita">speed</span> desde <span class="negrita">Update</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-44-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-44-47.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p class="sub-section">Método FixedUpdate</p>
  <p>Por defecto, <span class="negrita">FixedUpdate</span> se ejecuta cada 20 ms, pero puede cambiarse en <span class="negrita">Menú &rarr; Edit &rarr; Project Settings…</span> en la sección <span class="negrita">Time</span>.</p>
  <a href="UD3/images/ud3-2024-01-29-11-45-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-45-47.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Ejemplo: mover en X según <span class="negrita">speed</span> desde <span class="r-word">FixedUpdate</span>:</p>
  <a href="UD3/images/ud3-2024-01-29-11-46-19.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-46-19.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Ambos métodos pueden dar el mismo resultado si se multiplican por el mismo valor.</p>
  <a href="UD3/images/ud3-2024-01-29-11-47-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-47-06.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <a href="UD3/images/ud3-2024-01-29-11-47-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-11-47-21.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>La ventaja de <span class="negrita">FixedUpdate</span> es que su frecuencia se puede configurar desde los ajustes del proyecto.</p>
</section><!-- End section El componente Transform-->

<!--*********************************************************La clase Input***********************************************************-->
<section class="apartado">
  <a name="sLa_clase_Input"></a>
  <h2>La clase Input</h2>
  <p>Con la clase <span class="r-word">Input</span> puedes capturar <span class="negrita">eventos de entrada</span> del dispositivo del usuario (teclado, ratón, gamepad, etc.).</p>
  
  <p>La <span class="negrita">clase Input unifica</span> todos los dispositivos de entrada en un único punto de control.</p>
  
  <p>Unity proporciona una herramienta para configurar los dispositivos de entrada.</p>
  
  <p>En muchos juegos también se permite al usuario cambiar esta configuración para personalizar la experiencia.</p>
  
  <p>Desde <span class="negrita">Menú &rarr; Edit &rarr; Project Settings…</span> se abren los ajustes del proyecto; en <span class="negrita">Input Manager</span> puedes ver y configurar los dispositivos:</p>
  <a href="UD3/images/ud3-2024-01-29-19-19-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-19-19-18.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>La clase <span class="r-word">MonoBehaviour</span> ofrece métodos que permiten ejecutar código ante eventos del ratón:</p>
  <ul>
    <li><span class="negrita">OnMouseDown</span></li>
    <li><span class="negrita">OnMouseDrag</span></li>
    <li><span class="negrita">OnMouseEnter</span></li>
    <li><span class="negrita">OnMouseExit</span></li>
    <li><span class="negrita">OnMouseOver</span></li>
    <li><span class="negrita">OnMouseUp</span></li>
    <li><span class="negrita">OnMouseUpAsButton</span></li>
  </ul>
  
  <p>La <span class="negrita">clase Input</span> dispone de métodos que devuelven <span class="negrita">booleanos</span> cuando el usuario interactúa con una <span class="negrita">tecla</span>, un <span class="negrita">botón de ratón</span> o un <span class="negrita">botón virtual</span> como <span class="cursiva">"Fire1"</span>.</p>
  
  <p>Estos métodos suelen usarse dentro de <span class="negrita">Update</span>, ya que se ejecuta con mucha frecuencia.</p>
  <a href="UD3/images/ud3-2024-01-29-19-21-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-29-19-21-12.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  <p>Ejemplos:</p>
  <ul>
    <li>Input.GetKeyDown(KeyCode.E)</li>
    <li>Input.GetKey(KeyCode.V)</li>
    <li>Input.GetKeyUp(KeyCode.Space)</li>
    <li>Input.GetMouseButtonDown(0)</li>
    <li>Input.GetMouseButton(1)</li>
    <li>Input.GetMouseButtonUp(2)</li>
    <li>Input.GetMouseButtonUp("Fire1")</li>
    <li>Input.GetMouseButton("Jump")</li>
  </ul>
  
  <p>Consulta todos los métodos en la <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Input.html">documentación</a>.</p>
  
  <p>La <span class="negrita">clase Input</span> también tiene métodos para capturar valores de <span class="negrita">ejes de movimiento</span>.</p>
  
  <p>Estos devuelven un <span class="negrita">float</span>. En reposo, el eje vale 0; al pulsar, regresa un valor entre -1 y 1 (según aceleración o recorrido del joystick).</p>
  <p>Ejes disponibles:</p>
  <ul>
    <li><span class="negrita">Horizontal</span> y <span class="negrita">Vertical</span>: w, a, s, d, cursores, joystick, d-pad.
      <ul>
        <li>Input.GetAxis("Horizontal")</li>
        <li>Input.GetAxis("Vertical")</li>
      </ul>
    </li>
    <li><span class="negrita">Mouse X</span> y <span class="negrita">Mouse Y</span>: movimiento del ratón.
      <ul>
        <li>Input.GetAxis("Mouse X")</li>
        <li>Input.GetAxis("Mouse Y")</li>
      </ul>
    </li>
  </ul>
  
  <h3>Movimiento usando la clase Input</h3>
  <p>Gracias a <span class="negrita">Input</span>, <span class="negrita">puedes mover GameObjects</span> cuando el usuario interactúa con los <span class="negrita">dispositivos de entrada</span>.</p>
  
  <p>Con la cámara orientada como indica el gizmo, en el siguiente código:</p>
  <ul>
    <li>Flecha ↑ o W &rarr; <span class="negrita">mover</span> hacia delante (alejarse de la cámara).</li>
    <li>Flecha ↓ o S &rarr; <span class="negrita">mover</span> hacia atrás (acercarse a la cámara).</li>
    <li>Flecha ← o A &rarr; <span class="negrita">mover</span> a la izquierda.</li>
    <li>Flecha → o D &rarr; <span class="negrita">mover</span> a la derecha.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-12-50-54.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-50-54.png" /><br><figcaption></figcaption></figure></a>
  <br>
  <section><pre><code class="language-csharp">public class CubeTransformScript : MonoBehaviour
{
    public float translationSpeed = 5;
    
    void Update()
    {
        Debug.Log("Input.GetAxis(\"Horizontal\"): " + Input.GetAxis("Horizontal"));
        transform.Translate(
            Input.GetAxis("Horizontal") * translationSpeed * Time.deltaTime,
            0,
            Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime * -1
        );
    }
}</code></pre>
  </section><br><br>
  <a href="UD3/images/ud3-2024-01-31-12-51-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-51-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Otra variante:</p>
  <ul>
    <li>Flecha ↑ o W &rarr; <span class="negrita">mover</span> hacia delante.</li>
    <li>Flecha ↓ o S &rarr; <span class="negrita">mover</span> hacia atrás.</li>
    <li>Flecha ← o A &rarr; <span class="negrita">rotar</span> a la izquierda.</li>
    <li>Flecha → o D &rarr; <span class="negrita">rotar</span> a la derecha.</li>
  </ul>
  <section><pre><code class="language-csharp">transform.Translate(Vector3.forward * Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime);
transform.Rotate(Vector3.up * Input.GetAxis("Horizontal") * rotationSpeed * Time.deltaTime);</code></pre>
  </section><br><br>
  <a href="UD3/images/ud3-2024-01-31-12-55-05.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-55-05.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con cualquiera de los dos códigos, si la cámara está colocada detrás del GameObject con la misma orientación en X y la haces hija del GameObject, la cámara lo seguirá al moverse.</p>
  <a href="UD3/images/ud3-2024-01-31-12-55-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-12-55-32.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <hr><br>
  <div class="tarea">
    <p>
      <span class="subrayado negrita">Actividad 6. Modificar GameObjects con Inputs</span> <br>
      Crea un proyecto 3D llamado <span class="subrayado">InputsTuNombre</span>. <br>
      Pon la vista de la cámara como si fuese un juego 2D (eje Z hacia atrás). <br>
      Añade un plano y dale tamaño 15x15x15 en (0, 0, 0). <br>
      Añade una <span class="negrita">Capsule</span> en (0, 1, 0). <br>
      Añade un <span class="negrita">Cube</span> en (3, 0.5, 0). <br>
      Añade una <span class="negrita">Sphere</span> en (6, 0.5, 0). <br>
      Crea un material naranja para la cápsula, azul para el cubo y verde para la esfera. <br>
      Duplica el cubo y repártelo por el plano (unas 20 copias). <br>
      Crea un script para la cápsula y programa:
      <ul>
        <li>Con los ejes Horizontal y Vertical, mover la cápsula por el plano.</li>
        <li>Con la tecla <span class="negrita">E</span>, escalar la esfera +0.5 en todos los ejes.</li>
        <li>Con la tecla <span class="negrita">Q</span>, escalar la esfera −0.5 en todos los ejes, sin bajar nunca de 0.5.</li>
      </ul>
      Crea un script para la cámara que haga que siempre mire a la cápsula.
    </p>
  </div>
</section><!-- End section La clase Input-->

<!--*********************************************************Movimiento cinemático y movimiento físico***********************************************************-->
<section class="apartado">
  <a name="sMovimiento_cinematico_y_movimiento_fisico"></a>
  <h2>Movimiento cinemático y movimiento físico</h2>
  <p>Tipos de movimiento en Unity:</p>
  <ul>
    <li><span class="negrita">Cinemático</span>:
      <ul>
        <li>Movimiento aplicado directamente al componente Transform del GameObject.</li>
        <li>Independiente de la física del juego (gravedad, aceleración, impulsos, inercia, fricción…).</li>
      </ul>
    </li>
    <li><span class="negrita">Físico</span>:
      <ul>
        <li>Movimientos que usan el motor de física.</li>
        <li>El GameObject debe tener el componente <span class="negrita">Rigidbody</span>.</li>
      </ul>
    </li>
  </ul>
  
  <p>Al añadir <span class="r-word">Rigidbody</span> a un GameObject, su configuración aparece en el Inspector.</p>
  <a href="UD3/images/ud3-2024-01-31-13-00-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-00-16.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Propiedades de <span class="negrita">Rigidbody</span>:</p>
  <ul>
    <li><span class="negrita">Mass</span>: peso en kilogramos.</li>
    <li><span class="negrita">Drag</span>: resistencia al movimiento lineal.</li>
    <li><span class="negrita">Angular Drag</span>: resistencia a la rotación.</li>
    <li><span class="negrita">Use Gravity</span>: si le afecta la gravedad.</li>
    <li><span class="negrita">Is Kinematic</span>: si está activado, el GameObject no se ve afectado por la física (solo se manipula con su Transform; útil para detección de colisiones).</li>
    <li><span class="negrita">Constraints</span>: permite bloquear coordenadas.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-13-02-08.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-02-08.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Con movimientos cinemáticos (sin física), al mover un GameObject se <span class="negrita">teletransporta</span> a la nueva posición.</p>
  
  <p>Si un GameObject tiene <span class="negrita">Rigidbody</span>, no es recomendable modificar su posición vía Transform, porque podría aparecer parcialmente dentro de otro objeto y provocar colisiones no deseadas.</p>
  
  <p>Para mover un GameObject con Rigidbody, hay que <span class="negrita">aplicar fuerzas</span> que lo empujen en una dirección.</p>
  
  <p>Si <span class="negrita">no</span> hay interacción con Input, usa <span class="negrita">FixedUpdate</span>. Si <span class="negrita">sí</span> la hay, usa <span class="negrita">Update</span>.</p>
  
  <h3>Movimiento físico</h3>
  <p>Ejemplo de movimiento físico:</p>
  <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using System.Net.Security;
using UnityEngine;

public class CubeScript : MonoBehaviour
{
    public float linealForce;
    public float angularForce;

    private Rigidbody rb;
    
    // Start is called before the first frame update
    void Start()
    {
        //Get a reference to the Rigibody component
        rb = GetComponent&lt;Rigidbody&gt;        
    }

    private void FixedUpdate()
    {
        float acceleration = Input.GetAxis("Vertical");
        float spin = Input.GetAxis("Horizontal");

        //Thrust and turning forces are applied
        rb.AddForce(transform.forward * acceleration * linealForce);
        rb.AddTorque(transform.up * spin * angularForce);
    }
}</code></pre>
  </section><br><br>
  
  <p>Con el código anterior, hay que tener en cuenta los <span class="negrita">materiales físicos</span>: la fricción puede hacer que el comportamiento no sea el esperado.</p>
  
  <p>El suelo aporta fricción y, al empujar, el objeto puede inclinarse hacia delante.</p>
  
  <p>Además, por la fricción, al aplicar fuerzas el objeto tarda un poco en moverse y, al dejar de aplicarlas, se detiene gradualmente.</p>
  <a href="UD3/images/ud_3-2024-10-03-10-50-48.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-03-10-50-48.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para resolverlo puedes:</p>
  <ul>
    <li>Crear <span class="negrita">materiales físicos</span> para más realismo, configurándolos y asignándolos a superficies y personajes.</li>
    <li>Usar <span class="negrita">Constraints</span> en el Rigidbody para bloquear posición y/o rotación en cualquiera de los tres ejes.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-13-32-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-32-07.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>Para aplicar fuerzas necesitas una referencia a <span class="negrita">Rigidbody</span> en el código.</p>
  
  <p>Algunos métodos útiles:</p>
  <ul>
    <li><span class="negrita">AddForce</span>: aplica fuerzas de empuje en coordenadas de mundo.</li>
    <li><span class="negrita">AddTorque</span>: aplica fuerzas de rotación en coordenadas de mundo.</li>
    <li><span class="negrita">AddRelativeForce</span>: aplica empuje en coordenadas locales.</li>
    <li><span class="negrita">AddRelativeTorque</span>: aplica rotación en coordenadas locales.</li>
    <li><span class="negrita">AddForceAtPosition</span>: aplica fuerza en una posición concreta.</li>
    <li><span class="negrita">AddExplosionForce</span>: simula explosiones.</li>
  </ul>
  
  <p>Estas funciones tienen una sobrecarga que permite especificar el tipo de fuerza:</p>
  <ul>
    <li><span class="negrita">ForceMode.Force</span>: depende de la masa (F = m * a).</li>
    <li><span class="negrita">ForceMode.Acceleration</span>: aplica aceleración, ignorando la masa.</li>
    <li><span class="negrita">ForceMode.Impulse</span>: aplica fuerza instantánea en un frame (suele usarse en Update).</li>
    <li><span class="negrita">ForceMode.VelocityChange</span>: aplica directamente un cambio de velocidad.</li>
  </ul>
  
  <p>Usando solo movimientos físicos puedes mantener la inercia en cualquier eje.</p>
  <section><pre><code class="language-csharp">public class CubeScript : MonoBehaviour
{
    public float speed = 2;
    public float translationSpeed = 5;
    public float rotationSpeed = 180;
    public float jumpForce = 8f;
    private Rigidbody rb;
        
    void Start()
    {
        rb = GetComponent<Rigidbody>();        
    }

    void Update()
    {
        transform.Translate(Vector3.forward * Input.GetAxis("Vertical") * translationSpeed * Time.deltaTime);

        transform.Translate(Vector3.up * Input.GetAxis("Horizontal") * rotationSpeed * Time.deltaTime);

        if(Input.GetButtonDown("Jump")){
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
    }
}</code></pre>
  </section><br><br>
  
  <h3>Combinar movimiento cinemático y físico</h3>
  <p>Aunque no es lo ideal, se pueden combinar ambos tipos:</p>
  <ul>
    <li><span class="negrita">Cinemático</span>: para mover personaje/enemigos sobre superficies.</li>
    <li><span class="negrita">Físico</span>: para aplicar fuerza de salto.</li>
  </ul>
  <a href="UD3/images/ud3-2024-01-31-13-36-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-36-07.png" /><br><figcaption></figcaption></figure></a>
  <br><br>
  
  <p>El problema de este enfoque es que, si el personaje deja de moverse en mitad del salto, puede no conservar la inercia del salto.</p>
  
  <hr><br>
  <div class="tarea">
    <p>
      <span class="subrayado negrita">Actividad 7. Rigidbody y seguimiento de cámara</span> <br>
      Abre el proyecto <span class="subrayado">InputsTuNombre</span>. <br>
      Añade <span class="negrita">Rigidbody</span> a la cápsula. <br>
      Configura los <span class="negrita">Constraints</span> para que no se tumbe al colisionar. <br>
      Si programaste la cápsula sin rotación con A y D, cambia al modo que rota. <br>
      Añade <span class="negrita">Rigidbody</span> a la esfera. <br>
      Desactiva el script de la cámara. <br>
      Coloca la vista detrás de la cápsula como en la imagen (eje Z hacia atrás). <br>
      <a href="UD3/images/ud3-2024-02-01-10-37-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-10-37-56.png" /><br><figcaption></figcaption></figure></a>
      <br><br>
      Selecciona la cámara y usa <span class="negrita">Menú &rarr; GameObject &rarr; Align With View</span>. <br><br>
      Haz la cámara hija de la cápsula. <br><br>
      Ejecuta y mueve la cápsula: la cámara debería seguirla y la cápsula colisionar con otros GameObjects gracias al Rigidbody.
    </p>
  </div>
</section><!-- End section Movimiento cinemático y movimiento físico-->


<!--*********************************************************Colisiones***********************************************************-->
<section class="apartado">
<a name="sColisiones"></a>
<h2>Colisiones</h2>
<p>Para detectar colisiones entre GameObjects, deben tener un componente <span class="r-word">Collider</span> 
  (normalmente presente en la mayoría de GameObjects).</p>

<p>Unity ofrece dos mecanismos para detectar colisiones entre GameObjects:
  <ul>
    <li>Mediante <span class="negrita">Collider</span>.</li>
    <li>Mediante <span class="negrita">Trigger</span> (Collider marcado como <span class="cursiva">Is Trigger</span>, usado habitualmente en GameObjects sin representación gráfica en pantalla).</li>
  </ul>
</p>

<p>Es habitual usar el nombre del GameObject o su <span class="negrita">Tag</span> para distinguir colisiones.</p>

<h3>Colisiones con Collider</h3>
<p>Las <span class="negrita">colisiones con Collider</span> se usan cuando un GameObject toca a otro.</p>

<p>Por ejemplo:
  <ul>
    <li>El jugador empuja otro GameObject.</li>
    <li>Un GameObject impacta contra otro, como un disparo.</li>
    <li>…</li>
  </ul>
</p>

<p>Los colliders pueden ser 3D o 2D, y la clase MonoBehaviour ofrece métodos que se disparan cuando se detecta la colisión entre colliders.</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter(Collision collision)</span>: se ejecuta en el frame en el que comienza la colisión.</li>
    <li><span class="negrita">void OnCollisionStay(Collision collision)</span>: se ejecuta mientras la colisión persiste.</li>
    <li><span class="negrita">void OnCollisionExit(Collision collision)</span>: se ejecuta en el frame en el que finaliza la colisión.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionStay2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionExit2D(Collision collision)</span></li>
  </ul>
</p>

<p>En los métodos se recibe un objeto <span class="negrita">Collision</span>, que permite acceder a todos los aspectos de la colisión y al otro GameObject.</p>

<p>Se pueden ejecutar acciones al colisionar con otros GameObjects.</p>
<a href="UD3/images/ud3-2024-01-31-13-40-49.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-40-49.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>A través del objeto de colisión se puede acceder a todos los elementos del GameObject implicado.</p>
<a href="UD3/images/ud3-2024-01-31-13-41-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-41-02.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<h3>Colisiones con Trigger</h3>
<p>Las <span class="negrita">colisiones con Trigger</span> se usan para determinar si un GameObject está dentro de una zona concreta.</p>
<p>Por ejemplo:
  <ul>
    <li>Un GameObject tiene un collider mayor que su tamaño para detectar si el jugador está a rango, de modo que al pulsar una tecla pueda recogerse (consumible) o activarse (interruptor).</li>
    <li>Un GameObject vacío con un collider que detecta si el jugador está dentro.</li>
    <li>…</li>
  </ul>
</p>

<p>Para actuar como Trigger, un GameObject debe tener marcada la opción <span class="negrita">Is Trigger</span> en el Inspector dentro del componente Collider.</p>

<p>A veces los GameObjects que actúan como Trigger solo tienen los componentes Transform y Collider, ya que no necesitan ser visibles.</p>

<p>Si un collider está marcado como <span class="cursiva">Is Trigger</span>, la clase MonoBehaviour ofrece los siguientes métodos:</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter(Collider other)</span>: se ejecuta en el frame en el que comienza la superposición.</li>
    <li><span class="negrita">void OnTriggerStay(Collider other)</span>: se ejecuta mientras la superposición persiste.</li>
    <li><span class="negrita">void OnTriggerExit(Collider other)</span>: se ejecuta en el frame en el que finaliza la superposición.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerStay2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerExit2D(Collider other)</span></li>
  </ul>
</p>

<p>En estos casos, el otro objeto se recibe como un <span class="negrita">Collider</span>, que es el collider del otro GameObject implicado.</p>
<p>Para el GameObject que se mueve:</p>
<a href="UD3/images/ud3-2024-01-31-13-44-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-44-02.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>Para el GameObject configurado como <span class="negrita">Is Trigger</span>:</p>
<a href="UD3/images/ud3-2024-01-31-13-44-10.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-44-10.png" /><br><figcaption></figcaption></figure></a>
<br><br>

<p>En el siguiente ejemplo, un GameObject invisible con un Collider aplica una fuerza para hacer que otro GameObject flote dentro de él, 
  siempre que el otro GameObject tenga un componente Rigidbody:</p>
<a href="UD3/images/ud3-2024-01-31-13-45-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-45-12.png" /><br><figcaption></figcaption></figure></a>
<br><br>
</section><!-- End section Colisiones-->

  
  <!--*********************************************************Métodos interesantes***********************************************************-->
  <section class="apartado">
    <a name="sMetodos_Intersantes"></a>
    <h2>Métodos interesantes</h2>
    <h3>Método Destroy</h3>
    <p>El método <span class="r-word">Destroy</span> elimina el GameObject. Si no se especifica tiempo, se elimina inmediatamente. Si se indica un tiempo, se eliminará tras esos segundos.</p>
    <a href="UD3/images/ud3-2024-01-31-13-47-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-47-43.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Método Instantiate</h3>
    <p>El método <span class="r-word">Instantiate</span> permite crear GameObjects en tiempo de ejecución.</p>
    
    <p>Ejemplos de uso:
      <ul>
        <li>Cuando el jugador dispara, el proyectil debe crearse en ese punto y moverse en la dirección a la que apunta.</li>
        <li>En una zona de la escena aparece un enemigo por arriba, cae y desaparece al llegar abajo 
          (bucle con Instantiate, movimiento, detección por trigger al llegar abajo y Destroy).</li>
      </ul>
    </p>
    
    <p>Se crea un objeto cuando se pulsa el botón "<span class="cursiva">Fire1</span>" (botón izquierdo del ratón).</p>
    <a href="UD3/images/ud3-2024-01-31-13-49-03.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-03.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Cuando el jugador toca el GameObject, este se replica 10 veces.</p>
    <a href="UD3/images/ud3-2024-01-31-13-49-19.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-19.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Se crea un objeto a intervalos fijos de tiempo sin requerir acción.
    Se aplica una fuerza al GameObject creado en el momento de su creación, lanzándolo hacia delante.
    </p>
    <a href="UD3/images/ud3-2024-01-31-13-49-37.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-37.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-01-31-13-49-55.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-49-55.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <h3>Utilidades</h3>
    <p>Con los métodos <span class="r-word">Invoke</span> e <span class="r-word">InvokeRepeating</span> se puede indicar el tiempo de espera antes de llamar a otro método.</p>
    
    <a href="UD3/images/ud3-2024-01-31-13-50-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-50-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Las invocaciones activas pueden cancelarse con <span class="r-word">CancelInvoke</span>.</p>
    <p>Si no se pasa parámetro, se cancelan todas; si se pasa el nombre de un método, se cancela solo esa invocación.</p>
    
    <a href="UD3/images/ud3-2024-01-31-13-50-52.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-50-52.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Otra forma de realizar tareas similares a <span class="r-word">InvokeRepeating</span> es mediante <span class="negrita">Coroutines</span>.</p>
    <a href="UD3/images/ud3-2024-01-31-13-51-28.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-01-31-13-51-28.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Las coroutines pueden cancelarse con <span class="negrita">StopAllCoroutines</span> y <span class="negrita">StopCoroutine("NombreMetodo")</span>.</p>
    
    
    <br><br>
    <hr>
    <br>
    <div id="task1" class="tarea">
      <p><span class="subrayado negrita">Práctica 1 – Pachinko</span></p>
      
    <p>Un Pachinko es una máquina recreativa japonesa en la que el jugador dispone de una gran cantidad de bolas de acero que se introducen en la máquina. <br>
    La máquina cuenta con un sistema que lanza las bolas desde abajo por un lateral para llegar a la parte superior, desde donde empiezan a caer. <br>
    En el tablero hay una serie de clavos/pines donde las bolas rebotan tomando caminos aleatorios. <br>
    Además, en el tablero puede haber compuertas por las que las bolas pueden caer para conseguir puntos y, a veces, compuertas que devuelven la bola al jugador para reutilizarla. <br>
    Por último, las bolas que llegan al fondo no otorgan premio. <br></p>
    
    
    <p>Abajo puedes ver algunos ejemplos reales y versiones de videojuegos.</p>
    <a href="UD3/images/ud3-2024-02-01-11-00-27.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-11-00-27.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-02-01-11-00-52.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-11-00-52.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    
            
    <p>Crea un proyecto 3D en Unity llamado <span class="subrayado">PachinkoTuNombre</span>. <br>
    Instala el paquete de Unity que está <a class="enlace" target="_blank" href="./UD3/resources/pr-pachinko.unitypackage">adjunto</a> 
    de una de estas formas: 
    <ul>
      <li>Haciendo doble clic en el archivo del paquete se abrirá el diálogo para importar todos los elementos.</li>
      <li>Arrastrando el archivo del paquete a Unity se abrirá el mismo diálogo de importación.</li>
    </ul> <br>
    </p>
    <p>El paquete incluye, además del tablero, una imagen con sprites y 
      una serie de materiales que puedes aplicar al tablero y a las bolas metálicas. <br> 
    Todos los elementos del tablero incluyen un Collider para impedir que las bolas los atraviesen. Además, hay un Collider 
    delante para evitar que las bolas se disparen hacia el frente (dejando hueco para las bolas metálicas).</p>
    <a href="UD3/images/ud3-2024-02-01-11-04-26.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-11-04-26.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
     <p>En el siguiente enlace tienes el mismo paquete de materiales metálicos incluido en la tarea. 
    Puedes usar cualquiera de estos materiales para las bolas. 
    <a class="enlace" target="_blank" href="https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949">https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949</a></p>
    
    
    <p>Primero debes crear los siguientes prefabs (presta atención a la escala para evitar problemas de colisión):
    <ul>
      <li>Una bola metálica con física y colisiones.</li>
      <li>Un pin estático (puede ser un cilindro) con material metálico y material físico para que las bolas reboten.</li>
      <li>Un pin giratorio (puede ser un cilindro con un cubo alargado o dos cubos alargados en cruz, o lo que se te ocurra) 
        que no tendrá material de rebote. Cuando la bola golpee este pin, debe girar sobre su centro.</li>
       <a href="UD3/images/ud3-2024-02-01-11-09-34.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-11-09-34.png" /><br><figcaption></figcaption></figure></a>
       <br><br>
      <li>Una compuerta que otorgue 5 puntos si cae una bola.</li>
      <li>Una compuerta que otorgue 10 puntos. Esta compuerta debe ser más pequeña que la anterior.</li>
      <li>Una compuerta que otorgue una bola extra si cae una bola.</li>
    </ul></p>
    
    
    <p>Los prefabs de compuertas deben incluir sprites que indiquen al jugador qué ocurre al caer en ellas.
    En la escena, debes añadir:
    <li>En la parte superior centrada, una foto tipo pasaporte actual, tu nombre, los puntos actuales y el número de bolas restantes.</li>
     <a href="UD3/images/ud3-2024-02-01-11-12-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-01-11-12-11.png" /><br><figcaption></figcaption></figure></a>
     <br><br>
    <li>Tantos pines estáticos y giratorios como quieras para que el juego sea dinámico.</li>
    <li>Dos compuertas de 5 puntos.</li>
    <li>Una compuerta de 10 puntos.</li>
    <li>Dos compuertas de bola extra.</li></p>
    
    
    <p><span class="subrayado">Mecánicas del juego:</span> 
    <ul>
      <li>El juego empieza con 100 bolas y 0 puntos.</li>
      <li>Pulsando la flecha izquierda se soltará una bola por la ranura superior izquierda y se restará una bola del contador.</li>
      <li>Pulsando la flecha derecha se soltará una bola por la ranura superior derecha y se restará una bola.</li>
      <li>Cuando una bola caiga en cualquier compuerta, se sumarán los puntos o la bola extra correspondiente.</li>
      <li>Cuando una bola caiga en cualquier compuerta o llegue al fondo, debe destruirse.</li>
      <li>El HUD debe actualizarse siempre con los puntos y las bolas restantes.</li>
    </ul></p>
    
    <p>Todos los GameObjects de la escena deben tener nombres adecuados. <br>
    Crea y asigna todas las tags necesarias. <br>
    Crea los scripts necesarios y añádelos a los GameObjects o Prefabs para que el juego funcione correctamente.</p>
    
    <p>
    <span class="subrayado">Extras:</span>
    <ul>
      <li>Cada vez que se cree una bola, tendrá un material aleatorio de entre todos los materiales metálicos del paquete.</li>
      <li>Crea un prefab de compuerta que otorgue 50 bolas extra. Debe ser una compuerta difícil de acertar. 
        Una vez creado, añádelo al tablero.</li>
      <li>Modifica el tablero para asemejarse a las máquinas pachinko originales, donde la bola se lanza desde abajo por el lateral hacia la parte superior. 
        En este caso, las flechas se reemplazan por la barra espaciadora y, al pulsarla, se lanza una bola. 
        Debes crear un mecanismo para ajustar la fuerza, como una rueda que gire con las flechas para indicar la potencia.</li>
    </ul></p>
    </div>
  </section><!-- End section Métodos interesantes-->
  
  <div class="oculto2">
  <!--*********************************************************Componente CharacterController***********************************************************-->
  <section class="apartado">
    <a name="sComponenteCharacterController"></a>
    <h2>Componente CharacterController</h2>
    <p>En muchos juegos en primera o tercera persona, se necesitan colisiones para controlar cosas como que el personaje no atraviese suelo o paredes.</p>
    
    <p>Además, en estos juegos el movimiento es intencionadamente poco realista, permitiendo empezar o cambiar de dirección instantáneamente, sin inercia.</p>
    
    <p>Para estos casos, Unity ofrece la clase <span class="r-word">CharacterController</span>, que tiene sus propias funciones, se ve afectada por colisiones y no requiere <span class="r-word">Rigidbody</span>, facilitando su uso.</p>
    
    <p>Al añadir el componente <span class="negrita">CharacterController</span> a un GameObject, se añade automáticamente un <span class="subrayado">collider con forma de cápsula</span> asociado al CharacterController.</p>
    
    <a href="UD3/images/ud3-2024-02-20-18-19-30.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-19-30.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <a href="UD3/images/ud3-2024-02-20-18-19-46.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-19-46.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Todos los GameObjects representados gráficamente en la escena tienen un <span class="negrita">Collider</span>. Puede ser útil quitarlo o desactivarlo si el collider cápsula del CharacterController es suficiente.</p>
    <a href="UD3/images/ud3-2024-02-20-18-21-17.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-21-17.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p><span class="negrita">Propiedades de CharacterController</span>:
      <ul>
        <li><span class="negrita">Slope Limit</span>: pendiente máxima que puede subir.</li>
        <li><span class="negrita">Step Offset</span>: altura máxima de escalón que puede subir (0.3 m).</li>
        <li><span class="negrita">Skin Width</span>: grosor de la “piel” del collider (margen sin colisión).</li>
        <li><span class="negrita">Min Move Distance</span>: distancia mínima para moverse.</li>
        <li><span class="negrita">Center</span>: posición del collider respecto al GameObject.</li>
        <li><span class="negrita">Radius</span>: radio de la cápsula.</li>
        <li><span class="negrita">Height</span>: altura de la cápsula.</li>
      </ul>
    </p>
    <a href="UD3/images/ud3-2024-03-05-09-59-36.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-05-09-59-36.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Como <span class="negrita">CharacterController no está afectado por la física</span>, 
      el componente proporciona propiedades y métodos para obtener información del GameObject, como <span class="r-word">isGrounded</span>, que indica si tocó el suelo durante su último movimiento.</p>
    
    <p>El “suelo” será cualquier otro GameObject con collider sobre el que el CharacterController pueda apoyarse.</p>
    
    <p>Para mover el personaje hay dos métodos:</p>
      <ul>
        <li><span class="negrita">Move</span>: control total del movimiento (gravedad, salto, movimiento horizontal, etc.).</li>
        <li><span class="negrita">SimpleMove</span>: mueve aplicando automáticamente gravedad.</li>
      </ul>
    
    <p>La técnica con <span class="r-word">Move</span> consiste en recoger datos de <span class="negrita">Input</span> y de otros GameObjects que afecten al movimiento y calcular el vector de movimiento a aplicar.</p>
    
    <p>Datos a tener en cuenta:
      <ul>
        <li>¿Está el personaje tocando el suelo?</li>
        <li>¿Hay alguna tecla o botón pulsado?</li>
        <li>¿Debe aplicarse fuerza hacia arriba por salto?</li>
        <li>…</li>
      </ul>
    </p>
    
    <p>Un enfoque inicial para moverse por una superficie con CharacterController podría ser:</p>
    
    <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    public float horizontalMove;
    public float verticalMove;
    public Vector3 playerInput;

    public CharacterController player;

    public float playerSpeed;
    // Start is called before the first frame update
    void Start()
    {  
        player = GetComponent&lt;CharacterController>();
    }

    // Update is called once per frame
    void Update()
    {
        // Obtener valores de entrada del jugador
        horizontalMove = Input.GetAxis("Horizontal");
        verticalMove = Input.GetAxis("Vertical");

        playerInput = new Vector3(horizontalMove,0, verticalMove);

        // ClampMagnitude limita la magnitud del vector al máximo indicado (1),
        // así la diagonal no es más rápida que en un solo eje.
        playerInput = Vector3.ClampMagnitude(playerInput, 1);

        // Aplicar movimiento
        player.Move(playerInput * playerSpeed * Time.deltaTime);
    }
}</code></pre>
    </section><br><br>
    
    <p>Las propiedades son públicas para poder ver sus valores en el <span class="cursiva">Inspector</span> durante la ejecución.</p>
    
    <p>Es un enfoque básico: no tiene en cuenta la cámara, la gravedad u otros factores. Además, sin normalizar, al moverse en diagonal la velocidad sería mayor.</p>
    
    <h3>Control de personaje con CharacterController</h3>
    
    <p>A continuación, una serie de scripts para:
      <ul>
        <li>Movimiento completo del jugador (incluye salto y deslizamiento en pendientes).</li>
        <li>Cámara que sigue al jugador.</li>
        <li>Poder empujar GameObjects con Rigidbody.</li>
      </ul>
    </p>
    <p>Estos scripts están basados en tutoriales de Unity y pueden mejorarse.</p>
    <p class="sub-section">PlayerController.cs</p>
    
    <a href="UD3/images/ud3-2024-02-20-18-37-45.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-37-45.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    // Entradas del jugador
    private float horizontalMove;
    private float verticalMove;
    
    // Dirección de movimiento según la entrada
    private Vector3 playerInput;
    
    // Acceso al CharacterController
    private CharacterController player;
    
    // Velocidad de movimiento
    public float playerSpeed;
    
    // Vector de movimiento final
    private Vector3 movePlayer;
    
    // Gravedad
    public float gravity = 9.807f;
    
    // Velocidad de caída
    public float fallVelocity;
    
    // Fuerza de salto
    public float jumpForce;
    
    // Referencia a la cámara y su dirección
    public Camera mainCamera;
    private Vector3 camForward;
    private Vector3 camRight;
    
    // ¿Está en pendiente?
    public bool isOnSlope = false;
    private Vector3 hitNormal;
    
    // Deslizamiento en pendientes no escalables
    public float slideVelocity;
    public float slopeForceDown;

    void Start()
    {
        player = GetComponent&lt;CharacterController>();
    }

    void Update()
    {
        // Entradas
        horizontalMove = Input.GetAxis("Horizontal");
        verticalMove = Input.GetAxis("Vertical");

        playerInput = new Vector3(horizontalMove, 0, verticalMove);

        // Limitar magnitud para normalizar la diagonal
        playerInput = Vector3.ClampMagnitude(playerInput, 1);

        // Direcciones según cámara
        camDirection();
        movePlayer = playerInput.x * camRight + playerInput.z * camForward;

        // Aplicar velocidad
        movePlayer *= playerSpeed;

        // Rotar hacia el movimiento
        player.transform.LookAt(player.transform.position + movePlayer);

        // Gravedad y pendiente
        SetGravity();
        SlideOnSlope();

        // Habilidades (salto)
        PlayerSkills();

        // Mover
        player.Move(movePlayer * Time.deltaTime);
    }

    // Dirección de cámara para mover relativo a ella
    void camDirection()
    {
        camForward = mainCamera.transform.forward;
        camRight = mainCamera.transform.right;

        camForward.y = 0;
        camRight.y = 0;

        camForward = camForward.normalized;
        camRight = camRight.normalized;
    }

    // Cálculo de fuerza de caída
    void SetGravity()
    {
        if (player.isGrounded)
        {
            // Al tocar suelo, reiniciar caída
            fallVelocity = -gravity * Time.deltaTime;
        }
        else
        {
            // En el aire, acumular aceleración
            fallVelocity -= gravity * Time.deltaTime;
        }

        movePlayer.y = fallVelocity;
    }

    // Salto
    void PlayerSkills()
    {
        if (player.isGrounded && Input.GetButtonDown("Jump"))
        {
            fallVelocity = jumpForce;
            movePlayer.y = fallVelocity;
        }
    }

    // Deslizamiento en pendientes no escalables
    void SlideOnSlope()
    {
        isOnSlope = Vector3.Angle(Vector3.up, hitNormal) >= player.slopeLimit;
        if (isOnSlope)
        {
            movePlayer.x += (1 - hitNormal.y) * hitNormal.x * slideVelocity;
            movePlayer.z += (1 - hitNormal.y) * hitNormal.z * slideVelocity;
            movePlayer.y += slopeForceDown;
        }
    }

    // Detectar colisiones del CharacterController
    void OnControllerColliderHit(ControllerColliderHit hit)
    {
        hitNormal = hit.normal;
    }
}</code></pre>
    </section><br>
    <br>
    <p class="sub-section">PushRigidBody.cs</p>
    <a href="UD3/images/ud3-2024-02-20-18-40-38.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-40-38.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PushRigidBody : MonoBehaviour
{
    // Fuerza de empuje del personaje
    public float pushPower = 2;
    // Masa del objeto empujado
    private float targetMass;

    // Al colisionar, aplicar empuje
    void OnControllerColliderHit(ControllerColliderHit hit)
    {
        // Aquí podrías filtrar por tag. En este código se empuja cualquier Rigidbody.

        Rigidbody body = hit.collider.attachedRigidbody;

        if (body != null && !body.isKinematic && hit.moveDirection.y > -0.3)
        {
            targetMass = body.mass;
            Vector3 pushDir = new Vector3(hit.moveDirection.x, 0, hit.moveDirection.z);
            body.velocity = pushDir * pushPower / targetMass;
        }
    }
}</code></pre>
    </section><br><br>
    
    <p class="sub-section">ThirdPersonCamera.cs</p>
    <a href="UD3/images/ud3-2024-02-20-18-41-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-02-20-18-41-06.png" /><br><figcaption></figcaption></figure></a>
    <br>
 <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ThirdPersonCamera : MonoBehaviour
{
    // Distancia (offset) cámara-personaje
    public Vector3 offset;
    // Transform del personaje a seguir
    private Transform target;
    // Suavizado (0 a 1)
    [Range(0, 1)] public float lerpValue;
    // Sensibilidad del ratón
    public float sensitivity;

    void Start()
    {
        target = GameObject.Find("Player").transform;
    }

    // Se ejecuta tras todos los Update para seguir al personaje
    void LateUpdate()
    {
        // Interpolación suave hacia la posición objetivo
        transform.position = Vector3.Lerp(transform.position, target.position + offset, lerpValue);

        // Órbita alrededor con movimiento del ratón
        offset = Quaternion.AngleAxis(Input.GetAxis("Mouse X") * sensitivity, Vector3.up) * offset;
        transform.LookAt(target);
    }
}</code></pre>
 </section><br><br>   
    <p><a class="enlace" target="_blank" href="https://youtu.be/a9DEOeJxw9Y?si=OM8Kp5rI4AqE9KNV">Aquí</a> tienes una playlist de YouTube con la explicación completa.</p>
    <h3>CharacterController vs Movimiento físico</h3>
    <p>Al implementar el movimiento del personaje, se puede elegir entre:</p>
      <ul>
        <li>Implementar con física usando Rigidbody. <br>
          La física aporta realismo (útil en simuladores). <br>
          El control del jugador será más exigente.</li>
        <li>Implementar cinemático con CharacterController. <br>
          Más fácil para desarrolladores, colisiones precisas y eficiente al estar optimizado para personajes. <br>
          El jugador tendrá control más preciso, ideal para acciones complejas. <br>
          En la mayoría de casos, CharacterController es suficiente.</li>
      </ul>
  </section><!-- End section Componente CharacterController-->
  
  <!--*********************************************************Cámara profesional***********************************************************-->
  <section class="apartado">
    <a name="sCamaraprofesional"></a>
    <h2>Cámara profesional</h2>
    <p>Unity ofrece un paquete llamado <span class="r-word">Cinemachine</span>, con herramientas y 
      cámaras virtuales que simulan un estudio de cine para controlar totalmente la cámara.</p>
    <a href="UD3/images/ud3-2024-03-11-10-24-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-24-06.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-03-11-10-24-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-24-16.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Una vez instalado, encontrarás la configuración de cámaras virtuales en <span class="negrita">Menú &rArr; Component &rArr; Cinemachine</span>, 
       que puedes añadir a la cámara de la escena.</p>
    
    <a href="UD3/images/ud3-2024-03-11-10-25-13.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-25-13.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-03-11-10-25-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-25-32.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </section><!-- End section Cámara profesional-->
    
  <!--*********************************************************Movimiento programado***********************************************************-->
  <section class="apartado">
    <a name="sMovimientoProgramado"></a>
    <h2>Movimiento programado</h2>
    
    <p>En un videojuego puede haber elementos con movimiento preprogramado, 
      por ejemplo un enemigo que va de un lado a otro por el mismo camino o una plataforma que se mueve entre puntos.</p>
    
    <p>La mecánica suele ser:
      <ul>
        <li>Crear un GameObject vacío.</li>
        <li>Añadir como hijo el GameObject que se moverá (enemigo, plataforma…).</li>
        <li>Añadir tantos GameObjects vacíos como puntos tenga que alcanzar el objeto en movimiento.</li>
        <li>En un script del objeto que se moverá, indicar el movimiento punto a punto.</li>
      </ul>
    </p>
    <p>Si la plataforma solo se mueve entre dos puntos, el montaje sería:</p>
    <a href="UD3/images/ud3-2024-03-05-10-03-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-05-10-03-16.png" /><br><figcaption></figcaption></figure></a>
    <br><br>
    <p>Añade este script al GameObject que deba moverse:</p>
    <section><pre><code class="language-csharp">public class Platform : MonoBehaviour
{
    // Punto inicial
    public GameObject startGO;
    // Punto final
    public GameObject endGO;
    // Velocidad
    public float platformSpeed = 4;
    // Destino actual
    private Vector3 platformDestiny;

    void Start()
    {
        // Empieza hacia el final
        platformDestiny = endGO.transform.position;
    }

    void Update()
    {
        // Cambiar destino al llegar a un extremo
        if (transform.position == endGO.transform.position)
        {
            platformDestiny = startGO.transform.position;
        }
        else if (transform.position == startGO.transform.position)
        {
            platformDestiny = endGO.transform.position;
        }

        // Avanzar suavemente hacia el destino
        Vector3 newPosition = Vector3.MoveTowards(transform.position, platformDestiny, platformSpeed * Time.deltaTime);
        transform.position = newPosition;
    }
}
</code></pre>
    </section><br><br>
    
    <p>Este código usa movimiento cinemático.</p>
    
    <p>Se puede mejorar con un array de posiciones para recorrerlas en bucle y con pausas al llegar a cada destino.</p>
    
    <p>Si añades <span class="negrita">Rigidbody a la plataforma</span> (sin gravedad y como kinematic), 
      el jugador u otros objetos podrán subirse y desplazarse con ella.</p>
    
    <p>Con Rigidbody, el movimiento debe ser físico.</p>
    
    <p>En ese caso, coloca el script en el GameObject padre de la plataforma.</p>
    
    <p>Este código se añade al padre de la plataforma en movimiento.</p>
    <a href="UD3/images/ud3-2024-03-05-10-55-07.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-05-10-55-07.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <p>Además, arrastra la plataforma y los puntos al inspector.</p>
    
    <a href="UD3/images/ud3-2024-03-11-10-28-20.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-28-20.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Como la plataforma tiene Rigidbody, el movimiento debe ser físico.</p>
    
    <section><pre><code class="language-csharp">public class PlatformEnhanced : MonoBehaviour
{
    // Rigidbody del objeto que se moverá
    public Rigidbody platformRB;
    // Puntos de destino
    public Transform[] platformPositions;
    // Velocidad
    public float platformSpeed;
    // ¿Puede moverse?
    public bool moveToTheNext = true;
    // Tiempo de espera al llegar a un destino
    public float waitTime;

    // Índices de posición
    private int actualPosition = 0;
    private int nextPosition = 1;

    void Start()
    {
        // Posición inicial
        platformRB.position = platformPositions[0].position;
    }

    void Update()
    {
        if (moveToTheNext)
        {
            StopCoroutine(WaitForNext(0)); // Detener la espera si puede moverse
            // Avanzar hacia el siguiente punto
            platformRB.MovePosition(Vector3.MoveTowards(platformRB.position, platformPositions[nextPosition].position, platformSpeed * Time.deltaTime));
        }

        // ¿Ha llegado al destino?
        if (Vector3.Distance(platformRB.position, platformPositions[nextPosition].position) == 0)
        {
            // Esperar
            StartCoroutine(WaitForNext(waitTime));
            actualPosition = nextPosition;

            // Siguiente índice en bucle
            if (nextPosition + 1 == platformPositions.Length)
            {
                nextPosition = 0;
            }
            else
            {
                nextPosition++;
            }
        }
    }

    // Corrutina de espera
    IEnumerator WaitForNext(float time)
    {
        moveToTheNext = false;
        yield return new WaitForSeconds(time);
        moveToTheNext = true;
    }
}
</code></pre>
    </section><br><br>
    
    <p>Si el movimiento del personaje se implementó con <span class="negrita">CharacterController</span> y usas la plataforma anterior con Rigidbody, el personaje no se quedará encima.</p>
    
    <p>Ocurre porque la plataforma se mueve con física y el personaje no tiene Rigidbody.</p>
    
    <p>Para solucionarlo, hay que detectar la superficie bajo el personaje y, si está sobre la plataforma, mover al personaje junto con ella.</p>
    
    <p>Puedes usar <span class="negrita">Raycasts</span> para ello.</p>
  </section><!-- End section Movimiento programado-->
  
  <!--*********************************************************Raycast***********************************************************-->
  <section class="apartado">
    <a name="s"></a>
    <h2>Raycast</h2>
    
    <p>Un <span class="negrita">Raycast</span> consiste en emitir un rayo.</p>
    
    <p>Un <span class="negrita">rayo</span> es una línea <span class="negrita">imaginaria</span> que parte de un punto y viaja en una dirección.</p>
    
    <p>Emitiendo rayos con Raycast se pueden detectar GameObjects y triggers en la trayectoria del rayo.</p>
    
    <p>Para emitir un rayo necesitas:
      <ul>
        <li>Un objeto de la clase <span class="negrita">Ray</span>.</li>
        <li>Un objeto <span class="negrita">RaycastHit</span> que indicará qué GameObject impacta el rayo.</li>
        <li>Emitir el rayo con el método <span class="negrita">Raycast</span> de la clase <span class="negrita">Physics</span>.</li>
      </ul>
    </p>
    
    <p>Usos comunes:
      <ul>
        <li>Detectar colisiones.</li>
        <li>Detectar si un GameObject está en el camino de otro.</li>
        <li>Seleccionar elementos con el ratón.</li>
        <li>Mecánicas de disparo.</li>
        <li>…</li>
      </ul>
    </p>
    
    <p>Ejemplo: se emite un rayo y, al impactar, se muestra un mensaje:</p>
    <section><pre><code class="language-csharp">public class Sphere : MonoBehaviour
{
    private float rotationSpeed = 30f;

    void Update()
    {
        // Rotación para emitir rayos en 360º
        transform.Rotate(new Vector3(0, rotationSpeed * Time.deltaTime, 0));
        
        // Declarar el rayo (origen y dirección)
        Ray ray = new Ray(transform.position, transform.forward);
        
        // Visualizar el rayo en modo debug
        Debug.DrawRay(ray.origin, ray.direction * 5f);
        
        // Si el rayo impacta en algo, mostrar mensaje
        if (Physics.Raycast(ray))
        {
            Debug.Log("Impacto detectado");
        }
    }
}
</code></pre>
    </section><br><br>
    <a href="UD3/images/ud3-2024-03-11-10-29-32.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-29-32.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Si los rayos no se ven al ejecutar, actívalos en Gizmos en la vista Scene o Game:</p>
    <a href="UD3/images/ud3-2024-03-11-10-29-55.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-29-55.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>El método <span class="negrita">Raycast</span> tiene varias versiones.</p>
    
    <a href="UD3/images/ud3-2024-03-11-10-30-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-30-21.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Una versión acepta un segundo parámetro <span class="negrita">RaycastHit</span>, 
      donde se almacena toda la información del impacto, incluido el GameObject golpeado.</p>
    
    <p>El objeto <span class="negrita">RaycastHit</span> debe declararse antes de llamar a <span class="negrita">Raycast</span>.</p>
    
      <section><pre><code class="language-csharp">public class Sphere : MonoBehaviour
{
    private float rotationSpeed = 30f;

    void Update()
    {
        transform.Rotate(new Vector3(0, rotationSpeed * Time.deltaTime, 0));

        // Variable para almacenar el objeto impactado
        RaycastHit hit;
        Ray ray = new Ray(transform.position, transform.forward);
        Debug.DrawRay(ray.origin, ray.direction * 5f);

        if (Physics.Raycast(ray, out hit))
        {
            Debug.Log("Distancia: " + hit.distance);
            Debug.Log("Punto de impacto: " + hit.point);

            // Cambiar color del objeto impactado
            hit.transform.gameObject.GetComponent&lt;MeshRenderer>().material.color = Color.blue;
        }
    }
}
</code></pre>
      </section><br><br>
      
      <a href="UD3/images/ud3-2024-03-11-10-31-08.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-31-08.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>Puedes aplicar <span class="negrita">filtros</span> para que el rayo solo impacte en GameObjects que cumplan condiciones:
        <ul>
          <li><span class="negrita">Por distancia</span>: menor o igual que 7.
            <a href="UD3/images/ud3-2024-03-11-10-33-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-33-47.png" /><br><figcaption></figcaption></figure></a>
            <br>
          </li>
          <li><span class="negrita">Por capas (layers)</span>: igual que con las tags, puedes crear capas y asignarlas a GameObjects. 
            Se indica con una variable <span class="negrita">LayerMask</span>. En el inspector puedes seleccionar varias.
          <a href="UD3/images/ud3-2024-03-11-10-34-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-34-16.png" /><br><figcaption></figcaption></figure></a>
          <br><br>
          </li>
        </ul>
      </p>
      
      <p>Puedes indicar que el rayo no impacte en Colliders de tipo Trigger.</p>
      <a href="UD3/images/ud3-2024-03-11-10-34-47.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-34-47.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>Por defecto, un rayo solo impacta en el primer GameObject. 
        Puedes cambiar este comportamiento usando <span class="negrita">RaycastAll</span> de <span class="negrita">Physics</span>, que devuelve un array con todos los impactos.</p>
       <a href="UD3/images/ud3-2024-03-11-10-35-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-35-12.png" /><br><figcaption></figcaption></figure></a>
       <br><br>
       
      <p>Se pueden emitir rayos desde la cámara para seleccionar objetos con el ratón.</p>
      
    <p>El siguiente script debe añadirse a la cámara. 
      No puede llamarse <span class="negrita">Camera</span> para no sobrescribir la clase de Unity.</p>
    <section><pre><code class="language-csharp">// El script no puede llamarse Camera porque sobrescribiría la clase de Unity
public class CameraRay : MonoBehaviour
{
    private Camera mainCamera;

    void Start()
    {
        mainCamera = GetComponent&lt;Camera>();
    }

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            RaycastHit hit;
            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);

            if (Physics.Raycast(ray, out hit))
            {
                hit.transform.gameObject.GetComponent&lt;MeshRenderer>().material.color = Color.green;
                Debug.DrawRay(ray.origin, ray.direction * 10, Color.blue);
            }
        }
    }
}
</code></pre>
    </section><br><br>
    <a href="UD3/images/ud3-2024-03-11-10-36-19.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-36-19.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>En muchos videojuegos, los Raycast se usan para detectar colisiones, por ejemplo para saber si un personaje toca el suelo.</p>
      
    <p>Para ello, emite un rayo con una distancia acorde al tamaño del GameObject.</p>
      <section><pre><code class="language-csharp">private bool GroundCheck()
{
    float rayLength = 0.6f;
    Ray ray = new Ray(transform.position, Vector3.down);
    Debug.DrawRay(ray.origin, ray.direction * rayLength, Color.red);

    return Physics.Raycast(ray.origin, ray.direction, rayLength);
}
</code></pre>
      </section><br><br>
      
      <a href="UD3/images/ud3-2024-03-11-10-36-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-36-48.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>En algunos juegos se emiten rayos desde diferentes puntos del personaje para controlar el movimiento.</p>
    <section><pre><code class="language-csharp">private bool GroundCheck()
{
    float rayLength = 0.8f;

    Vector3 rightRayPosition = transform.position + new Vector3(transform.localScale.x / 2 - 0.05f, 0, 0);
    Ray rayRight = new Ray(rightRayPosition, Vector3.down);
    Debug.DrawRay(rayRight.origin, rayRight.direction * rayLength, Color.green);

    Vector3 leftRayPosition = transform.position - new Vector3(transform.localScale.x / 2 - 0.05f, 0, 0);
    Ray rayLeft = new Ray(leftRayPosition, Vector3.down);
    Debug.DrawRay(rayLeft.origin, rayLeft.direction * rayLength, Color.green);

    return Physics.Raycast(rayRight.origin, rayRight.direction, rayLength) ||
           Physics.Raycast(rayLeft.origin, rayLeft.direction, rayLength);
}
</code></pre>
    </section><br><br>
    <a href="UD3/images/ud3-2024-03-11-10-37-15.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-37-15.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Raycast emite una línea; la clase Physics ofrece otros “casts” con diferentes formas:</p>
      <ul>
        <li><span class="negrita">BoxCast</span>: rayo con forma de cubo.</li>
        <li><span class="negrita">CapsuleCast</span>: rayo con forma de cápsula.</li>
        <li><span class="negrita">SphereCast</span>: rayo con forma de esfera.</li>
        <li><span class="negrita">LineCast</span>: devuelve true si hay algún objeto impactado entre dos puntos.</li>
      </ul>
    
    <p>El siguiente script amplía el controlador de personaje con <span class="negrita">CharacterController</span>, 
       comprobando si el GameObject toca el suelo con <span class="negrita">SphereCast</span>.</p>
    
       <h3>Control del personaje – En plataformas móviles</h3>    
       <p>Para que un CharacterController se mueva con una plataforma con Rigidbody sobre la que está, 
        añade este script al personaje:</p>
    
        <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MoveWithFloor : MonoBehaviour
{
    // Acceso al CharacterController
    private CharacterController player;
    // Posiciones del último suelo tocado
    private Vector3 actualGroundPosition;
    private Vector3 lastGroundPosition;
    // Nombre del último objeto de suelo
    private string groundName;
    private string lastGroundName;
    // Últimas rotaciones de la plataforma
    private Quaternion actualRotation;
    private Quaternion lastRotation;

    void Start()
    {
        player = GetComponent&lt;CharacterController>();
    }

    void Update()
    {
        // Si toca suelo, comprobamos la superficie
        if (player.isGrounded)
        {
            RaycastHit hit;

            // SphereCast para detectar superficie inferior
            if (Physics.SphereCast(transform.position, player.height / 4.2f, -transform.up, out hit))
            {
                // Si es una plataforma (tag "Platforms"), aplicar su movimiento al jugador
                if (hit.collider.CompareTag("Platforms"))
                {
                    GameObject groundedIn = hit.collider.gameObject;
                    groundName = groundedIn.name;
                    actualGroundPosition = groundedIn.transform.position;
                    actualRotation = groundedIn.transform.rotation;

                    // Si la plataforma cambió de posición y el jugador sigue encima, desplazarlo
                    if (actualGroundPosition != lastGroundPosition && groundName == lastGroundName)
                    {
                        transform.position += actualGroundPosition - lastGroundPosition;
                        player.enabled = false;
                        player.transform.position = transform.position;
                        player.enabled = true;
                    }

                    // Si cambió la rotación y el jugador sigue encima, rotarlo alrededor
                    if (actualRotation != lastRotation && groundName == lastGroundName)
                    {
                        var newRotation = transform.rotation * (actualRotation.eulerAngles - lastRotation.eulerAngles);
                        transform.RotateAround(groundedIn.transform.position, Vector3.up, newRotation.y);
                    }

                    // Actualizar referencias
                    lastGroundName = groundName;
                    lastGroundPosition = actualGroundPosition;
                    lastRotation = actualRotation;
                }
            }
        }
        // Si no hay colisión, resetear variables
        else
        {
            lastGroundName = null;
            lastGroundPosition = Vector3.zero;
            lastRotation = Quaternion.Euler(Vector3.zero);
        }            
    }
}</code></pre>
        </section><br><br>
        
        <br>
        
  </section><!-- End section Raycast-->
  
  <!--*********************************************************NPCs***********************************************************-->
  <section class="apartado">
    <a name="sNPCs"></a>
    <h2>NPCs</h2>
    <p><span class="negrita">NPCs</span> (<span class="negrita">N</span>on-<span class="negrita">P</span>layable 
    <span class="negrita">C</span>haracters) son personajes controlados por el juego que el jugador no dirige.</p>
    
    <p>Tipos de NPC:
      <ul>
        <li><span class="negrita">Enemigos</span>: suponen un reto a superar.</li>
        <li><span class="negrita">Aliados</span>: acompañan al jugador, ayudando en puzles o combate.</li>
        <li><span class="negrita">Influenciables</span>: según las acciones del jugador, pueden ser aliados o enemigos.</li>
        <li><span class="negrita">Comerciantes</span>: permiten comerciar para mejorar/progresar.</li>
        <li><span class="negrita">Informativos</span>: aportan información relevante o trivial para la misión.</li>
        <li><span class="negrita">Decorativos</span>: dan realismo a la escena.</li>
      </ul>
    </p>
    
    <p>Un NPC puede ser:</p>
      <ul>
        <li><span class="negrita">Activo</span>: ofrece misiones, información o ítems que cambian con el progreso.</li>
        <li><span class="negrita">Pasivo</span>: repite la misma información o conducta al interactuar.</li>
      </ul>
    
    <p>Se espera un mínimo de <span class="negrita">IA</span> (Inteligencia Artificial): comportamiento programado, desde simple a complejo.</p>
    
    <p>En el siguiente ejemplo veremos cómo 
      <span class="negrita">hacer que un NPC se mueva de un punto a otro por el camino más óptimo</span>.</p>
    
    <p>Esta técnica también sirve para mover al jugador con clic de ratón o para que un enemigo patrulle y persiga al jugador al verlo.</p>
    
    <p>Instala el paquete <span class="r-word">AI Navigation</span>.</p>
    <a href="UD3/images/ud3-2024-03-11-10-38-48.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-38-48.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Al instalarlo, aparece la opción: <span class="negrita">Menú</span> &rarr; <span class="negrita">Window</span> &rarr;
    <span class="negrita">AI</span> &rarr; <span class="negrita">Navigation</span>.</p>
    <a href="UD3/images/ud3-2024-03-11-10-38-59.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-38-59.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>En <span class="negrita">Menú</span> &rarr; <span class="negrita">Window</span> &rarr; <span class="negrita">AI</span> 
       &rarr; <span class="negrita">Navigation</span> se abre la ventana de navegación.</p>
    
    <p>En la pestaña <span class="negrita">Agents</span> defines las características del GameObject 
      que se moverá por el camino óptimo.</p>
    
      <a href="UD3/images/ud3-2024-03-11-10-39-33.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-39-33.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
    <p>Puedes crear tantos agentes como necesites (unos podrán saltar muros, otros no).</p>
    
    <p>En la pestaña <span class="negrita">Areas</span> defines áreas y su prioridad (Cost): cuanto menor, más preferente.</p>
    
      <a href="UD3/images/ud3-2024-03-11-10-39-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-39-43.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>Los GameObjects que deban moverse deben tener el componente <span class="negrita">NavMeshAgent</span>.</p>
      
      <p>En el ejemplo, la cápsula se moverá hacia la posición de la esfera por el camino óptimo.</p>
      
      <p><span class="negrita">Se añadió NavMeshAgent a la cápsula</span>. En el inspector verás sus opciones.</p>
      
      <a href="UD3/images/ud3-2024-03-11-10-40-08.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-40-08.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <a href="UD3/images/ud3-2024-03-11-10-40-16.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-40-16.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
    <p>Después, añade <span class="negrita">NavMeshSurface</span> a los GameObjects de la escena y asígnales el área deseada.</p>
    
    <p>Este componente define <span class="negrita">dónde puede moverse el agente</span>.</p>
    
    <p>En el ejemplo, el suelo y bloques están dentro de un GameObject al que se añade NavMeshSurface.</p>
    <a href="UD3/images/ud3-2024-03-11-10-40-43.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-40-43.png" /><br><figcaption></figcaption></figure></a>
    <br>
    <a href="UD3/images/ud3-2024-03-11-10-40-50.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-40-50.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Configurado el NavMeshSurface, pulsa <span class="negrita">Bake</span>.</p>
    
    <p>Esto genera la superficie navegable. Se deja margen alrededor de obstáculos para evitar comportamientos extraños. 
      Puedes modificar la superficie ajustando el <span class="negrita">Agent</span> y pulsando <span class="negrita">Clear</span> y <span class="negrita">Bake</span> de nuevo.</p>
    
       <a href="UD3/images/ud3-2024-03-11-10-41-12.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-41-12.png" /><br><figcaption></figcaption></figure></a>
       <br><br>
    
      <p>Como la esfera no forma parte del escenario, debes añadirle <span class="negrita">NavMeshObstacle</span>.</p>
         
      <p><span class="negrita">NavMeshObstacle</span> se usa para GameObjects que pueden moverse por la escena.</p>
      <a href="UD3/images/ud3-2024-03-11-10-41-42.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-41-42.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <a href="UD3/images/ud3-2024-03-11-10-41-55.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-41-55.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>Se usa para personajes y para GameObjects que, al moverse, afectan a la superficie de navegación.</p>
      
      <p>Los enemigos tendrán el componente <span class="cursiva">NavMeshObstacle</span> y normalmente no afectarán a la superficie.</p>
      
      <p>GameObjects como rocas que caen o puertas que se cierran sí deberían afectar la superficie.</p>
      
      <p>Para que un <span class="negrita">NavMeshObstacle</span> afecte a la superficie, marca <span class="negrita">Carve</span>. 
        Si solo quieres que afecte cuando esté parado (por ejemplo, una roca grande que cae), desmarca <span class="negrita">Carve Only Stationary</span>.</p>
    
        <a href="UD3/images/ud3-2024-03-11-10-42-37.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-42-37.png" /><br><figcaption></figcaption></figure></a>
        <br><br>
        
      <p>En el ejemplo, hay un cubo con NavMeshObstacle y la opción Carve activada.</p>
      <a href="UD3/images/ud3-2024-03-11-10-42-56.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-42-56.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <a href="UD3/images/ud3-2024-03-11-10-43-06.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-43-06.png" /><br><figcaption></figcaption></figure></a>
      <br>
      <a href="UD3/images/ud3-2024-03-11-10-43-22.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-43-22.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <p>En navegación puedes crear <span class="negrita">links</span> (enlaces).</p>
      <p>Tipos:</p>
        <ul>
          <li><span class="negrita">NavMeshLink</span>: conecta zonas en la misma superficie (por ejemplo, permitir bajar un borde alto).</li>
          <li><span class="negrita">OffMeshLink</span>: conecta dos zonas de navegación separadas físicamente.</li>
        </ul>
      <p>Los enlaces pueden ser unidireccionales o bidireccionales.</p>
      
      <h3>NavMeshLink</h3>
      <p>Tiene dos puntos y una superficie visible entre ellos.</p>
      <p>Si quieres permitir bajar pero no subir, desmarca <span class="negrita">Bidirectional</span>.</p>
    <a href="UD3/images/ud3-2024-03-11-10-43-51.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-43-51.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
      <h3>OffMeshLink</h3>
      <p>Requiere dos GameObjects como puntos de referencia.</p>
      
      <p>Solo falta asignar este script al GameObject que debe moverse (la cápsula).</p>
      <p>Añade la librería al inicio del script.</p>
      <a href="UD3/images/ud3-2024-03-11-10-44-24.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-44-24.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
      <section><pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class NavMeshController : MonoBehaviour
{
    // Objetivo a seguir
    public Transform aim;
    // Agente de navegación
    private NavMeshAgent agent;

    void Start()
    {
        agent = GetComponent&lt;NavMeshAgent>();
    }

    void Update()
    {
        // Actualiza destino cada frame; si el objetivo se mueve, recalcula ruta
        agent.destination = aim.position;
    }
}</code></pre>
      </section><br><br>
      
      <p>A partir de este script, puedes crear una ruta para un GameObject:</p>
        <ul>
          <li>Crea GameObjects vacíos con collider trigger y colócalos donde quieras.</li>
          <li>Declara un array de objetivos en el script.</li>
          <li>En Start, pon el primer objetivo como la posición 0 del array.</li>
          <li>En Update, comprueba si se ha alcanzado el objetivo.</li>
          <li>Si se alcanzó, pasa al siguiente en el array.</li>
          <li>Si el índice llega a la longitud del array, vuelve a 0.</li>
          <li>En el inspector, arrastra los GameObjects vacíos en el orden deseado.</li>
        </ul>
      
      <p>Si quieres que el enemigo que patrulla persiga al jugador, añade:</p>
        <ul>
          <li>Un <span class="negrita">Transform</span> del jugador en el script.</li>
          <li>Un Raycast desde el enemigo en su dirección de marcha, con una longitud (puedes simular visión humana girando unos grados a cada lado).</li>
          <li>Si el Raycast golpea al jugador, guarda el objetivo actual y cambia el objetivo al Transform del jugador.</li>
          <li>Si deja de ver al jugador, restaura el objetivo anterior (o mejor, el punto de la ruta más cercano).</li>
        </ul>
      
    <p>Si quieres mover al personaje a donde se hace clic en pantalla, usa este script:</p>
    <section><pre><code class="language-csharp">public class NavMeshMouse : MonoBehaviour
{
    // Agente de navegación
    private NavMeshAgent agent;

    void Start()
    {
        agent = GetComponent&lt;NavMeshAgent>();
    }

    void Update()
    {
        // Al hacer clic, lanzar un rayo para saber dónde se hizo clic
        if (Input.GetMouseButtonDown(0))
        {
            RaycastHit hit;
            if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit))
            {
                // Establecer destino del agente en el punto de impacto
                agent.destination = hit.point;
            }
        }
    }
}
</code></pre>
    </section><br><br>
    
  </section><!-- End section NPCs-->
  
  <!--*********************************************************Cambio de escenas***********************************************************-->
  <section class="apartado">
      <a name="sCambiodeescenas"></a>
      <h2>Cambio de escenas</h2>
    <p>En un videojuego es habitual tener varias escenas, ya que cada nivel suele ser una escena distinta.</p>
    
    <p>Además, suele haber un menú inicial y un menú de opciones, también como escenas.</p>
    
    <p>Para poder cambiar a una escena debe estar añadida a la configuración de compilación (Build).</p>
    
    <p>Los cambios de escena pueden ocurrir en distintos momentos:
    <ul>
      <li>Al pulsar “Play” en el menú principal.</li>
      <li>Al completar un nivel.</li>
      <li>Dentro de un nivel al entrar en una nueva zona.</li>
      <li>...</li>
    </ul>
    </p>
    
    <p>Primero añade todas las escenas a <span class="negrita">File</span> &rarr; <span class="negrita">Build Settings…</span>.</p>
    <a href="UD3/images/ud3-2024-03-11-10-45-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-45-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Pulsando <span class="negrita">Add Open Scenes</span> se añade la escena abierta.</p>
    
    <p>Para añadir otras escenas, arrástralas desde el gestor de archivos.</p>
    
    <p>La escena en la posición cero (0) será la que se cargue al ejecutar el juego (tras compilar y generar el ejecutable).</p>
    <a href="UD3/images/ud3-2024-03-11-10-46-03.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-46-03.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <p>Para cambiar de escena desde un script, añade esta librería:</p>
    <section><pre><code class="language-csharp">using UnityEngine.SceneManagement;</code></pre>
    </section><br><br>
    
    <p>La instrucción para cambiar de escena es:</p>
    <section><pre><code class="language-csharp">SceneManager.LoadScene("SceneName");</code></pre>
    </section><br><br>
    
    <p>También puedes usar el identificador (Build settings):</p>
    <section><pre><code class="language-csharp">SceneManager.LoadScene(2);</code></pre>
    </section><br><br>
    
    <p>Al cambiar de escena puedes indicar que ciertos GameObjects no se destruyan y persistan.</p>
    
    <p>Esto permite transferir datos entre escenas y ahorrar tiempo de carga.</p>
    <section><pre><code class="language-csharp">public class DontDestroy : MonoBehaviour
{
    // Variable estática para guardar la instancia de este script
    public static DontDestroy instance;

    // Cuando se carga el script
    void Awake()
    {
        // Si ya existe una instancia, destruir este GameObject para evitar duplicados
        if (DontDestroy.instance != null)
        {
            Destroy(gameObject);
            return; // Detener la ejecución de Awake
        }

        // Si no existe, guardar esta como instancia (solo la primera vez)
        instance = this;

        // Indicar que este GameObject persista entre escenas
        DontDestroyOnLoad(gameObject);
    }
}
</code></pre>
    </section><br><br>
    
  </section><!-- End section Cambio de escenas-->

   <!--*********************************************************PlayerPrefs***********************************************************-->
<section class="apartado">
  <a name="sPlayerPrefs"></a>
  <h2>PlayerPrefs</h2>
  <p><span class="negrita">PlayerPrefs</span> permiten almacenar información en el ordenador donde se ejecuta el juego.</p>

  <p>Normalmente se usan para guardar:
    <ul>
      <li>El nombre del jugador.</li>
      <li>Puntuaciones.</li>
      <li>Vidas.</li>
      <li>Opciones del juego como la resolución o teclas definidas por el usuario.</li>
      <li>Último nivel (escena) jugado.</li>
      <li>...</li>
    </ul>
  </p>

  <p><span class="negrita">PlayerPrefs</span> ofrece varios métodos para almacenar/recuperar información según el tipo de dato:
    <ul>
      <li>SetFloat</li>
      <li>SetInt</li>
      <li>SetString</li>
    </ul>
    <a href="UD3/images/ud3-2024-03-11-10-47-30.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-47-30.png" /><br><figcaption></figcaption></figure></a>
    <br>

    <ul>
      <li>GetFloat</li>
      <li>GetInt</li>
      <li>GetString</li>
    </ul>
    <a href="UD3/images/ud3-2024-03-11-10-47-40.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-47-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
  </p>

  <p>Los métodos <span class="negrita">Get</span> pueden tener uno o dos parámetros; el segundo es el valor por defecto en caso de que la preferencia no exista.</p>

  <p>Para comprobar si existe una preferencia, usa <span class="negrita">HasKey</span>:</p>
  <a href="UD3/images/ud3-2024-03-11-10-48-02.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-48-02.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p>Para eliminar una preferencia, usa <span class="negrita">DeleteKey</span>:</p>
  <a href="UD3/images/ud3-2024-03-11-10-48-11.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-48-11.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p>Para borrar todas las preferencias, usa <span class="negrita">DeleteAll</span>:</p>
  <a href="UD3/images/ud3-2024-03-11-10-48-18.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-48-18.png" /><br><figcaption></figcaption></figure></a>
  <br>
</section><!-- End section PlayerPrefs-->

<!--*********************************************************Menus***********************************************************-->
<section class="apartado">
  <a name="sMenus"></a>
  <h2>Menus</h2>

  <p>Hay dos opciones para crear menús:
    <ul>
      <li>
        <span class="negrita">Menú principal</span> (cuando no hay nivel cargado): <br>
        Suele crearse en su propia escena utilizando elementos de UI.
      </li>
      <li><span class="negrita">Menú dentro del juego</span>:<br>
        Se crea de forma similar al menú principal, pero al cambiar entre el nivel y la escena del menú debe guardarse el estado actual.
      </li>
    </ul>
  </p>

  <p>También puede crearse dentro de la escena del nivel añadiendo una cámara secundaria con los elementos de UI,
    colocada lejos de los objetos del juego. Al abrir el menú, se pausa la escena y se cambia la cámara activa
    por la asociada al menú.</p>

  <p>Aunque podría hacerse con GameObjects normales, lo más habitual es usar GameObjects de interfaz (UI).</p>
  <a href="UD3/images/ud3-2024-03-11-10-48-49.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-48-49.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <p>Los GameObjects de UI gestionan eventos de forma diferente al resto. Así se interactúa con ellos.</p>

  <p>Cada tipo de UI tiene eventos específicos visibles en el Inspector.</p>
  <a href="UD3/images/ud3-2024-03-11-10-49-25.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-49-25.png" /><br><figcaption></figcaption></figure></a>
  <br><br>

  <p>Estos eventos deben vincularse a un método de un script de Unity.</p>
  <a href="UD3/images/ud3-2024-03-11-10-49-52.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-49-52.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p>Tras crear el script y añadir los métodos necesarios (con el nombre que prefieras),
    añádelo al GameObject <span class="negrita">Canvas</span> para poder seleccionarlos desde los elementos de UI en el Inspector.</p>

  <p>Una vez el script está en el <span class="negrita">Canvas</span>, para enlazar un evento de UI:
    <ul>
      <li>Haz clic en <span class="negrita">+</span> en el evento deseado.</li>
      <li>Arrastra el GameObject Canvas desde la jerarquía al nuevo hueco.</li>
      <li>Selecciona el método que se ejecutará cuando se dispare el evento.</li>
    </ul>
  </p>
  <a href="UD3/images/ud3-2024-03-11-10-50-22.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-50-22.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p>Con esto, el método queda vinculado al evento del GameObject de UI.</p>

  <a href="UD3/images/ud3-2024-03-11-10-51-21.png" target="_BLANK"><figure><img src="UD3/images/ud3-2024-03-11-10-51-21.png" /><br><figcaption></figcaption></figure></a>
  <br>
</section><!-- End section Menus-->

<!--*********************************************************sComunicacion***********************************************************-->
<section class="apartado">
  <a name="sComunicacion"></a>
  <h2>Comunicación entre GameObjects</h2>
  <p>Anteriormente vimos cómo un GameObject podía acceder al script de otro.</p>

  <p>Para ello se guarda una referencia al otro objeto para acceder a su componente Script y, por tanto, a sus propiedades y métodos.</p>

  <p>Este enfoque es intrusivo y va contra los principios de la POO.</p>

  <p>Una alternativa usa <span class="d-word">delegados</span> y <span class="d-word">eventos</span>.</p>

  <p>Los delegados actúan como referencias a métodos.</p>

  <p>Los eventos amplían los delegados para que una clase pueda notificar a otras cuando ocurre una acción.</p>

  <p>Define un delegado y un evento asociado dentro de un GameObject.</p>

  <p>Otros GameObjects pueden suscribirse con su propio método para que, al lanzarse el evento, se llame a dicho método.</p>

  <p>La mejor forma de entenderlo es con un ejemplo.</p>

  <p><span class="subrayado">Escena de ejemplo</span>:</p>
  <p>
    <ul>
      <li><span class="negrita">Cápsula</span>: personaje (tag Player) con Rigidbody que puede moverse por el plano.</li>
      <li><span class="negrita">Paredes con puertas</span>: los GameObjects marrones son puertas que suben.</li>
      <li><span class="negrita">Baldosa azul</span>: interruptor que abre las puertas al pisarlo.</li>
    </ul>
  </p>

  <a href="UD3/images/ud_3-2024-10-24-19-09-18.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-24-19-09-18.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <a href="UD3/images/ud_3-2024-10-24-19-09-39.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-24-19-09-39.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p><span class="negrita">Script en la baldosa</span></p>
  <section><pre><code class="language-csharp">public class DoorSwitch : MonoBehaviour
{
    // Declarar el delegado
    public delegate void Activate();
    // Declarar un evento del mismo tipo que el delegado
    // Se declara estático para permitir la suscripción con el nombre de la clase
    public static event Activate OnActivate;

    // Otros GameObjects pueden suscribirse a estos eventos
    // Pueden lanzarse desde cualquier función
    // Al lanzarse, los GameObjects suscritos ejecutarán su propia función
    private void OnTriggerEnter(Collider other)
    {
        // Solo lanzar el evento si hay algún suscriptor
        if (OnActivate != null)
        {
            OnActivate(true);
        }
    }
}
</code></pre>
  </section><br><br>

  <p><span class="negrita">Script en la puerta</span>:</p>
  <section><pre><code class="language-csharp">public class Door : MonoBehaviour
{
    void Start()
    {
        // La puerta se suscribe al evento OnActivate del interruptor
        // Cuando ocurra el evento, se ejecutará el método Open de esta clase
        DoorSwitch.OnActivate += Open;
    }

    private void Open()
    {
        transform.Translate(Vector3.up * 3f);
    }

    void OnDisable()
    {
        // La puerta se desuscribe del evento OnActivate
        DoorSwitch.OnActivate -= Open;
    }
}
</code></pre>
  </section><br><br>

  <p>También puedes hacer que la puerta baje al salir de la baldosa y añadir un cubo con <span class="r-word">Rigidbody</span> para dejarlo sobre la baldosa.</p>

  <p>En este caso la baldosa tendrá dos eventos: activar y desactivar.</p>

  <p>Las puertas deberán suscribirse a ambos, cada uno con su propio método.</p>
  <a href="UD3/images/ud_3-2024-10-24-19-11-31.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-24-19-11-31.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p><span class="negrita">Script en la baldosa</span></p>
  <section><pre><code class="language-csharp">public class DoorSwitch : MonoBehaviour
{
    public delegate void Activate();
    public static event Activate OnActivate;

    public delegate void Disable();
    public static event Disable OnDisable;

    private void OnTriggerEnter(Collider other)
    {
        if (OnActivate != null)
        {
            OnActivate();
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (OnDisable != null)
        {
            OnDisable();
        }
    }
}
</code></pre>
  </section><br><br>

  <p><span class="negrita">Script en la puerta</span>:</p>
  <section><pre><code class="language-csharp">public class Door : MonoBehaviour
{
    void Start()
    {
        DoorSwitch.OnActivate += Open;
        DoorSwitch.OnDisable  += Close;
    }

    private void Open()
    {
        transform.Translate(Vector3.up * 3f);
    }

    private void Close()
    {
        transform.Translate(Vector3.down * 3f);
    }

    void OnDisable()
    {
        DoorSwitch.OnActivate -= Open;
        DoorSwitch.OnDisable  -= Close;
    }
}
</code></pre>
  </section><br><br>

  <a href="UD3/images/ud_3-2024-10-24-19-12-47.png" target="_BLANK"><figure><img src="UD3/images/ud_3-2024-10-24-19-12-47.png" /><br><figcaption></figcaption></figure></a>
  <br>

  <p>También puedes reutilizar el mismo evento para acciones distintas definiendo el delegado con un parámetro.</p>

  <p>Así, al lanzar el evento, puedes pasar un valor que los suscriptores utilizarán.</p>

  <p><span class="negrita">Script en la baldosa</span></p>
  <section><pre><code class="language-csharp">public class DoorSwitch : MonoBehaviour
{
    public delegate void Activate(bool open);
    public static event Activate OnActivate;

    private void OnTriggerEnter(Collider other)
    {
        if (OnActivate != null)
        {
            OnActivate(true);
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (OnActivate != null)
        {
            OnActivate(false);
        }
    }
}
</code></pre>
  </section><br><br>

  <p><span class="negrita">Script en la puerta</span>:</p>
  <section><pre><code class="language-csharp">public class Door : MonoBehaviour
{
    void Start()
    {
        DoorSwitch.OnActivate += Open;
    }

    private void Open(bool open)
    {
        if (open)
        {
            transform.Translate(Vector3.up * 3f);
        }
        else
        {
            transform.Translate(Vector3.down * 3f);
        }
    }

    void OnDisable()
    {
        DoorSwitch.OnActivate -= Open;
    }
}
</code></pre>
  </section><br><br>

  <p>Como se ve en los ejemplos, usar delegados y eventos es una técnica mucho menos intrusiva.</p>
  <p>Además, permite que varios GameObjects se suscriban fácilmente al mismo evento y reaccionen cuando se dispare.</p>
  <p>Desde el script que define el evento, puedes lanzarlo cuando corresponda simplemente invocándolo:</p>

  <section><pre><code class="language-csharp">void Start() {
    OnActivate(true);
}
</code></pre>
  </section><br><br>
</section><!-- End section sComunicacion-->

<!--*********************************************************FinalPractice***********************************************************-->
<section class="apartado">
  <a name="sFinalPractice"></a>
  <h2>FinalPractice</h2>

  <div class="tarea">
    <a class="tarea" target="_blank" href="https://aules.edu.gva.es/semipresencial/mod/assign/view.php?id=2332098">
      <p>Este proyecto consiste en un videojuego de creación libre con los siguientes requisitos:
        <ol>
          <li>El juego debe tener un menú inicial donde el jugador pueda introducir su nombre antes de empezar. <span class="negrita">1pt</span></li>
          <li>Incluye un sistema de puntuación (p. ej., por tiempo de finalización, recogida de monedas/objetos, derrotar enemigos). Guarda esta puntuación en <span class="cursiva">PlayerPrefs</span> junto con el nombre del jugador. <span class="negrita">1.5pts</span></li>
          <li>El menú inicial debe mostrar el nombre del jugador junto a su puntuación. <span class="negrita">0.5pts</span></li>
          <li>Además del menú, el juego debe tener al menos dos pantallas a las que se pueda llegar tras completar la primera. No hace falta que sean muy extensas. <span class="negrita">0.75pts</span></li>
          <li>La cámara debe seguir al personaje del jugador. <span class="negrita">0.75pts</span></li>
          <li>Incluye al menos dos tipos de enemigos:
            <ul>
              <li>Uno que persiga al jugador. <span class="negrita">1.5pts</span></li>
              <li>Otro que siga una ruta fija. <span class="negrita">1pt</span></li>
            </ul>
          </li>
          <li>Usa prefabs cuando sea apropiado.</li>
          <li>Incluye mecánicas jugables como movimiento del jugador, saltos, vidas, ataques, etc. <span class="negrita">1.5pts</span></li>
          <li>Diseño del juego y personajes (se aceptan assets de tienda), fondo, sprites, animaciones, audio, etc. <span class="negrita">1.5pts</span></li>
        </ol>
      </p>

      <p>Para la entrega, crea un paquete con los elementos necesarios de la(s) escena(s) y graba un vídeo (máx. 5 minutos) mostrando la funcionalidad del juego y cómo has implementado las características más importantes.</p>
    </a>
  </div>
</section><!-- End section FinalPractice-->
    
  </div> <!--END OCULTO-->

  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>