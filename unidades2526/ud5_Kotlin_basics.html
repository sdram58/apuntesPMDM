<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UD5.-Introduction to Kotlin</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/prism.css">
    <link rel="stylesheet" href="../styles/styles.css">
    <script src="../script/script.js"></script>
  </head>

  
<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">
    <div class="fila">
      <a href="#sFundamentos" title="1.- Fundamentos de Kotlin">1.- Fundamentos de Kotlin</a><a 
       href="#sNullSafety" title="2.- Seguridad de nulos (Null Safety)">2.- Seguridad de nulos (Null Safety)</a><a 
       href="#sExpresionesRegulares" title="3.- Expresiones regulares">3.- Expresiones regulares</a>
    </div>
    <div class="fila">
      <a 
       href="#sControldeFlujo" title="4.- Control de flujo">4.- Control de flujo</a>
       <a href="#sColecciones" title="5.- Colecciones">5.- Colecciones</a>
       <a href="#sFunciones" title="6.- Funciones">6.- Funciones</a>
    </div>
    <div class="fila">
      <a 
       href="#sPOO" title="7.- Programación orientada a objetos">7.- Programación orientada a objetos</a><a 
       href="#sFuncionesExtension" title="8.- Funciones de extensión">8.- Funciones de extensión</a><a 
       href="#sSingleton" title="9.- Singleton">9.- Singleton</a>
    </div>
    <div class="fila">
      <a 
       href="#sHerencia" title="10.- Herencia">10.- Herencia</a><a
       href="#sFuncionesdealcance" title="11.- Funciones de alcance">11.- Funciones de alcance</a><a 
       href="#sFuncionesLambda" class="" title="12.- Funciones lambda">12.- Funciones lambda</a>
    </div>

    <div class="fila">
      <a href="#sEjerciciosInteractivos" title="13.- Ejercicios interactivos de Kotlin">13.- Ejercicios interactivos de Kotlin</a>
    </div>
  </nav>

  <h1>UD5.- Introducción a Kotlin</h1>
  
  <div class="main-menu">
    <div class="fila">
      <a href="#sFundamentos">1.- Fundamentos de Kotlin</a><a 
       href="#sNullSafety">2.- Seguridad de nulos (Null Safety)</a><a 
       href="#sExpresionesRegulares">3.- Expresiones regulares</a>
    </div>
    <div class="fila">
      <a href="#sControldeFlujo">4.- Control de flujo</a><a 
      href="#sColecciones">5.- Colecciones</a><a 
      href="#sFunciones">6.- Funciones</a>
    </div>
    <div class="fila">
      <a 
       href="#sPOO">7.- Programación orientada a objetos</a><a 
       href="#sFuncionesExtension">8.- Funciones de extensión</a><a 
       href="#sSingleton">9.- Singleton</a>
    </div>
    <div class="fila">
      <a 
       href="#sHerencia">10.- Herencia</a><a
       href="#sFuncionesdealcance">11.- Funciones de alcance</a><a 
       href="#sFuncionesLambda" class="">12.- Funciones lambda</a>
    </div>

    <div class="fila">
      <a href="#sEjerciciosInteractivos">13.- Ejercicios interactivos de Kotlin</a>
      <a href="" class="relleno"></a><a href="" class="relleno"></a>
    </div>
  </div>



<!--*********************************************************1.- Fundamentos de Kotlin***********************************************************-->
<section class="apartado">
  <a id="sFundamentos"></a>
  <h2>Fundamentos de Kotlin</h2>
  
  <h3>Introducción</h3>
  
  <p>
    Inicialmente, <span class="negrita">Java</span> fue el <span class="negrita">lenguaje de programación para Android</span>, 
    pero en <span class="negrita">2017 Google</span> designó <span class="negrita">Kotlin</span> como 
    <span class="negrita">lenguaje oficial para Android</span>, equiparándolo con Java.
  </p>
  
  <p>
    Tiene soporte oficial de Google y está integrado en Android Studio.
  </p>
  
  <a href="UD5/images/UD5_2025-10-31-15-30-57.png"><figure><img src="UD5/images/UD5_2025-10-31-15-30-57.png" /><br><figcaption>Características de Kotlin</figcaption></figure></a>
  <br>
  <a href="UD5/images/UD5_2025-10-31-15-33-32.png"><figure><img src="UD5/images/UD5_2025-10-31-15-33-32.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  
  <br>
  
  <p>Algunas características de Kotlin son:</p>
  
  <ul>
    <li>
      <span class="negrita">Lenguaje multiplataforma y multipropósito</span> compilado sobre la JVM, por lo que es totalmente compatible 
      con Java y sus librerías (llamadas de Java a Kotlin y viceversa).
    </li>
    <li>
      Lenguaje orientado a objetos (<span class="negrita">POO</span>)
    </li>
    <li>
      Es un <span class="negrita">lenguaje conciso</span> que evita código innecesario (hasta un 40% menos).
    </li>
    <li>
      Tiene <span class="d-word">seguridad de nulos (Null Safety)</span>, gestionando los nulos de forma segura y evitando 
      errores <span class="r-word">NullPointerException</span>.
    </li>
    <li>
      De forma no oficial, se puede decir que es como Java pero con el estilo (y ventajas) de Python.
    </li>
  </ul>
  

  <p>
    La documentación oficial contiene todo lo necesario sobre el lenguaje: 
    <a class="enlace" target="_blank" href="https://kotlinlang.org/docs/basic-syntax.html">https://kotlinlang.org/docs/basic-syntax.html</a>
    <br>
    También hay una plataforma para aprender Kotlin mediante ejemplos: 
    <a class="enlace" target="_blank" href="https://play.kotlinlang.org/byExample/overview">https://play.kotlinlang.org/byExample/overview</a>
  </p>
  
  <p>
    En este curso, <span class="negrita">Kotlin</span> se utilizará como lenguaje de programación para Android. 
    Dado que Kotlin es un lenguaje multipropósito, puede usarse para desarrollar aplicaciones Android, de escritorio, web o de consola.
  </p>
  
  <p>
    En esta unidad trataremos los <span class="negrita">fundamentos y la sintaxis de Kotlin</span>, 
    para posteriormente usar el lenguaje dentro de <span class="d-word">Android Studio</span> y desarrollar aplicaciones móviles Android. 
    Si quieres crear y probar scripts de Kotlin, debes tener instalado un JDK de Java. 
    Podríamos usar <a class="enlace" target="_blank" href="https://www.jetbrains.com/es-es/idea/">IntelliJ IDEA</a> de JetBrains, 
    que es el IDE en el que se basa Android Studio.
  </p>
  
  <a href="UD5/images/ud5-2023-09-15-16-32-08.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-15-16-32-08.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>
    También puedes probar scripts de Kotlin online mediante el enlace oficial: 
    <a class="enlace" target="_blank" href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a>
  </p>
  
  <a href="UD5/images/ud5-2023-09-15-16-31-13.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-15-16-31-13.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>
    No obstante, como ya tenemos <span class="d-word">Android Studio</span> instalado, será la herramienta que usemos para desarrollar aplicaciones Android y probar código Kotlin.
    <br>
    Para ello, tenemos varias opciones:
  </p>
  
  <p>
    Podemos iniciar un proyecto nuevo (o reutilizar uno anterior, aunque podría ensuciar la estructura de archivos y no es buena práctica) y crear un archivo Kotlin, por ejemplo 
    <span class="inline-file">Test.kt</span>, y añadir la función <span class="r-word">main</span> para nuestras pruebas.
  </p>
  
  <section class="marco-t inf">
    <span class="icono info"> </span> Ten en cuenta que el archivo Kotlin tiene la extensión <span class="negrita">.kt</span>.
  </section>
  <section class="marco-b"></section>
  
  <figure><img src="UD5/images/test_code.gif" /><br><figcaption>Archivo de prueba</figcaption></figure>
  <br>
  
  <p>Veamos un ejemplo sencillo de entrada y salida:</p>
  
  <section><pre><code class="language-kotlin">fun main(){
      val variable:String
      variable = readln()
      println("Has escrito $variable")
  }</code></pre></section><br>
  
  <p>Tras ejecutarlo, espera a que escribamos algo y pulsemos Intro, y después lo muestra por pantalla.</p>
  
  <figure><img src="UD5/images/Test_IO.gif" /><br><figcaption>Entrada/Salida</figcaption></figure>
  <br>
  
  <section class="marco-t inf">
    <span class="icono info"> </span> Entrada y salida
  </section>
  <section class="marco-b">
    <span class="r-word">println()</span>  -> Escribe en la salida estándar<br>
    <span class="r-word">readln()</span>  -> Lee de la entrada estándar (teclado)
  </section>
  
   
  <p>
    Otra opción sería, igualmente dentro de un proyecto (en nuestro caso el <span class="negrita">hola mundo</span> inicial). 
    Haciendo clic derecho sobre nuestro paquete, podemos crear un nuevo <span class="d-word">Scratch file</span>.
  </p>
  
  <a href="UD5/images/ud5-2023-09-15-16-37-39.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-15-16-37-39.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>
    Seleccionamos el lenguaje de programación que queramos, en este caso Kotlin.
  </p>
  
  <a href="UD5/images/ud5-2023-09-15-16-38-39.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-15-16-38-39.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>
    Veamos un ejemplo: <br>
    En este caso usamos la función <span class="r-word">println()</span>, y como vemos a la derecha, nos muestra la salida por pantalla. 
    Si creamos una variable, indica su tipo, y si mostramos la variable, muestra el valor de la variable en ese momento.
    Ten en cuenta que un scratch file se ejecuta de arriba a abajo, como se observa.
  </p>
  
  <figure><img src="UD5/images/Scratch_example.gif" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Guía de estilo de Kotlin</h3>
  
  <p>
    En cualquier lenguaje de programación, es importante que el <span class="negrita">código sea legible</span>. 
    Las plataformas oficiales suelen proporcionar <a class="enlace" target="_blank" href="guides de estilo">guías de estilo</a> para que los desarrolladores las sigan, 
    y es recomendable revisarlas para escribir código correcto. 
    <br>
    También puedes usar la opción <span class="negrita">Code -> Reformat Code (Ctrl+Alt+L)</span> en el IDE, para que el código se formatee según las guías de estilo 
    (siempre que la configuración del IDE no se haya modificado).
  </p>
  
  <h3>Saludos en Kotlin</h3>
  
  <p>
    Como se mencionó, los archivos Kotlin tienen la extensión <span class="negrita">.kt</span> y, a diferencia de Java, 
    <span class="negrita">no es necesario que todo esté dentro de clases</span>. 
    Las funciones pueden existir fuera de clases; en concreto, la función principal <span class="r-word">main</span> no necesita estar dentro de una clase. 
    La función main puede aceptar argumentos, pero no es obligatorio. Tampoco es necesario declarar la visibilidad de la función (public/static).
    La función <span class="r-word">println()</span> está disponible sin necesidad de usar System.out de Java, y 
    <span class="r-word">readln()</span> captura la entrada del usuario desde la consola como cadena.
    El punto y coma al final de cada sentencia es opcional, pero <span class="negrita">por convención no debe usarse</span>. 
    Los comentarios, tanto de línea como de bloque, son iguales que en Java: <span class="r-word">//</span> y <span class="r-word">/* */</span>.
  </p>
  
  <h3>Paquete e imports</h3>
  
  <p>
    Como en Java, el paquete al que pertenece el archivo y los imports deben colocarse en la parte superior del archivo.
  </p>
  
  <a href="UD5/images/ud5-2023-09-16-12-01-32.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-12-01-32.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <h3>Tipos de datos en Kotlin</h3>
  
  <p class="sub-section">Tipos numéricos</p>
  
  <p>
    Se indican con las palabras reservadas <span class="r-word">Int, Float, Long, Short, Byte y Double</span>.
  <ul>
    <li>
      Decimales: <span class="negrita">Double</span> (64 bits), <span class="negrita">Float</span> (32 bits)
    </li>
    <li>
      Enteros: <span class="negrita">Long</span> (64 bits), <span class="negrita">Int</span> (32 bits),
      <span class="negrita">Short</span> (16 bits), <span class="negrita">Byte</span> (8 bits)
    </li>
  </ul>
  <br>
  Ejemplos de literales:
  </p>
  
  <a href="UD5/images/ud5-2023-09-16-12-06-10.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-12-06-10.png" /><br><figcaption></figcaption></figure></a>
  <br>
  

<p>
  Kotlin permite usar el <span class="negrita">carácter guion bajo</span> (<em>underscore</em>, _) en <span class="negrita">literales numéricos</span> para mejorar la legibilidad. 
  <br>
  Ejemplos de literales: <br>
  <section><pre><code class="language-kotlin">2_000_000
44_294_051
6135_8442_0103_5610L</code></pre>
  </section><br><br>
</p>

<p class="sub-section">Caracteres</p>

<p>
  Indicados con la palabra reservada <span class="r-word">Char</span>.
</p>

<p>
  Se usa codificación UTF-16, por lo que los literales pueden indicarse con el carácter o su representación UNICODE entre comillas simples.
  <br>
  Ejemplos de <span class="negrita">literales</span>:
  <section><pre><code class="language-kotlin">'N'    ->    '\u004E'
'7'    ->    '\u0037'</code></pre>
  </section><br><br>
  No pueden tratarse como números.
</p>

<p>
  Existen una serie de <span class="r-word">caracteres de escape</span>:
  <ul>
    <li>
      \t   Tabulador
    </li>
    <li>
      \b   Retroceso
    </li>
    <li>
      \r   Retorno de carro
    </li>
    <li>
      \n   Nueva línea
    </li>
    <li>
      \'   Apóstrofe
    </li>
    <li>
      \"   Comillas dobles
    </li>
    <li>
      \\   Barra invertida
    </li>
    <li>
      \$   Signo dólar
    </li>
    <li>
      \u+XXXX   Símbolo Unicode (4 dígitos hexadecimales)
    </li>
  </ul>
</p>

<p class="sub-section">Booleanos</p>

<p>
  Indicados con la palabra reservada <span class="r-word">Boolean</span>.
  <br>
  Los valores posibles son <span class="cursiva">true</span> y <span class="cursiva">false</span>, y sus <span class="negrita">literales</span>:
  <section><pre><code class="language-kotlin">true
false</code></pre>
  </section><br><br>
</p>

<p class="sub-section">Cadenas (Strings)</p>

<p>
  Indicadas con la palabra reservada <span class="r-word">String</span>.
  <br>
  Los literales de cadena <span class="negrita">se indican con comillas dobles:</span>
  <section><pre><code class="language-kotlin">"¡Hola!"
"Rick Sanchez"</code></pre>
  </section><br><br>
</p>

<p>
  Con <span class="negrita">tres comillas dobles</span>, la cadena puede incluir saltos de línea; se conocen como <span class="subrayado">raw strings</span>, donde se incluyen todos los caracteres entre comillas.
</p>

<section><pre><code class="language-kotlin">"""Este es un texto
que ocupa varias líneas
o se muestra en múltiples
líneas"""
</code></pre>
</section><br><br>

<p>
  Se pueden eliminar espacios iniciales y finales, así como márgenes izquierdos.
</p>

<section><pre><code class="language-kotlin">"""|Este es un texto
|que ocupa varias líneas
|o se muestra en múltiples
|líneas""".trimMargin()
</code></pre>
</section><br><br>

<p>
  Por defecto, el carácter <span class="negrita">|</span> es el delimitador de margen, pero puede cambiarse: <span class="r-word">trimMargin(">")</span>.
</p>

<a href="UD5/images/ud5-2023-09-16-12-48-27.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-12-48-27.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Los <span class="negrita">templates de cadena</span> permiten integrar variables en cadenas usando el símbolo <span class="r-word">$</span> seguido del nombre de la variable. Kotlin lo sustituirá por el valor almacenado.
  <br>
  Si la variable es un objeto o quieres operar con ella, debes encerrarla entre llaves <span class="negrita">{ }</span>.
</p>

<section><pre><code class="language-kotlin">"El descuento es $discount %"
"El precio es ${product.price} €"

""" |Cuaderno $notebookPrice €
|Bolígrafo azul $penPrice €
|    Total: ${notebookPrice + penPrice}
""".trimMargin()
</code></pre>
</section><br><br>

<p>
  Se recomienda usar siempre <span class="negrita">templates de cadena</span> y <span class="negrita">raw strings</span>. 
  Aunque se pueden concatenar cadenas con el carácter <span class="negrita">+</span>, debe evitarse. 
  Además, también debe evitarse usar múltiples println seguidos.
</p>


<p class="sub-section">Arrays</p>

<p>
  Los arrays son <span class="negrita">estructuras de datos de longitud fija</span> que permiten almacenar múltiples valores del mismo tipo (números, caracteres, cadenas, booleanos, objetos).
</p>

<p>1 2 3 4 5 <br>
  "Rick", "Morty", "Summer" 
</p>

<p>
  Los veremos en detalle más adelante.
</p>

<h3>Declaración de variables</h3>

<p>
  Con la palabra reservada <span class="r-word">var</span> se declaran variables. <br>

  Las variables son como cajas que almacenan valores, y estos valores pueden cambiar durante la ejecución del programa. <br>

  Kotlin es un lenguaje de <span class="negrita">tipado estático</span>, lo que significa que una vez que una variable es de un tipo, ese tipo no puede cambiar (similar a Java).

  Al declarar una variable, puedes especificar el tipo de dato o no. <br>

  Si no se especifica, Kotlin inferirá el tipo a partir del valor asignado.
</p>

<p>
  Al declarar una variable, debe cumplirse una de estas dos opciones:

  <ul>
    <li><span class="negrita">Especificar el tipo</span> de dato a almacenar.</li>
    <li><span class="negrita">Especificar el valor</span> a almacenar (Kotlin inferirá el tipo).</li>
  </ul>
  <br>
  También puedes declarar una variable especificando tanto el tipo de dato como el valor a almacenar.
</p>

<p class="sub-section">Declaración de variables de tipo simple</p>

<section><pre><code class="language-kotlin">var name: String = "Rick Sanchez"
var dimension = "c-137" // se infiere el tipo de dato
var gender: Char = 'h'
var age: Int
age = 70
var isAlive: Boolean = true
</code></pre>
</section><br><br>


<p class="sub-section">Declaración de arrays</p>

<p>
  Los arrays son objetos y se crean con la clase <span class="r-word">Array</span>, que proporciona los métodos <span class="r-word">get</span> y <span class="r-word">set</span>, 
  pero por comodidad también pueden usarse los corchetes <span class="negrita">[ ]</span>.
</p>

<section><pre><code class="language-kotlin">// Se especifica el tipo de dato del array
var numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)

// Se infiere el tipo de dato del array
var names = arrayOf("Rick", "Morty", "Summer")

println(numbers[1])      // numbers.get(1)
numbers[3] = 12          // numbers.set(3, 12)

println("Hay ${names.size} nombres")
</code></pre>
</section><br><br>


<p>
  Puedes usar el constructor de la clase Array para indicar el tamaño e incluso una <span class="negrita">función lambda</span> para rellenar los elementos.
</p>

<section><pre><code class="language-kotlin">var array = Array(size = 10) { }          // array de 10 elementos vacíos (Unit)
var zeros = Array(size = 5) { 0 }         // array de 5 enteros, todos 0
var emptys = Array(size = 5) { "" }       // array de 5 cadenas, todas ""
var serie = Array(size = 100) { it }      // array de 100 enteros: 0, 1, 2, ... 99
var reverse = Array(size = 50) { 50 - it } // array de 50 enteros: 50, 49, 48, ... 0
</code></pre>
</section><br><br>


<p>
  El código entre llaves es una <span class="negrita">función lambda</span> (anónima), que se explicará más adelante.

  En esa lambda, la variable <span class="r-word">it</span> representa el número de iteración, empezando en cero.

  Como Android Studio tiene sugerencias de código activadas por defecto, si dejas un salto de línea entre llaves verás esta información.
</p>

<a href="UD5/images/ud5-2023-09-16-13-03-25.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-03-25.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Creando un array con los 10 primeros números pares.
</p>

<section><pre><code class="language-kotlin">val a = Array(10){
    it*2
}

for(b in a) print("$b ")</code></pre>
</section><br><br>

<p class="sub-section">Declaración de arrays multidimensionales</p>

<p>
  Los <span class="negrita">arrays multidimensionales</span> son arrays cuyos elementos a su vez son arrays.

  El caso más común son las matrices, que pueden representarse como una tabla.

  Hay varias formas de declarar un array multidimensional en Kotlin:
</p>

<a href="UD5/images/ud5-2023-09-16-13-10-35.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-10-35.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  El acceso a los elementos de una matriz se realiza <span class="negrita">usando los índices de fila y columna.</span>
</p>

<section><pre><code class="language-kotlin">val matrix = arrayOf(
    arrayOf(5, 3, 2, 0),
    arrayOf(4, 9, 4, 5),
    arrayOf(8, 1, 7, 6)
)

matrix[1][3] = 8 // Establece el valor en la fila 1, columna 3 a 8

for (row in matrix) {
    for (column in row) {
        print("$column ") // Imprime cada elemento seguido de un espacio
    }
    println() // Salta de línea tras imprimir una fila
}
</code></pre>
</section><br><br>



<p class="sub-section">El tipo Any</p>

<p>
  Todos los tipos de variable son clases y, en la jerarquía de Kotlin, tienen una superclase denominada <span class="r-word">Any</span> (similar a Object en Java).
  <br><br>
  Puedes declarar una variable con tipo Any y luego asignarle cualquier tipo de dato. Puede ser útil en ciertos casos, como se verá más adelante.
</p>

<section><pre><code class="language-kotlin">var number: Any = 6
var name: Any = "Rick Sanchez"
var isAlive: Any = true
var numbers = arrayOf(1, 2, 3)
</code></pre>
</section><br><br>


<p>
  Para usar una variable, debe almacenar un valor. 
  <br><br>
  Existe un tipo de dato que permite dejar una variable “vacía”, conocido como <span class="r-word">Unit</span> (similar a void en Java).
</p>

<section><pre><code class="language-kotlin">val variable1: Any
// Produce error porque la variable no ha sido inicializada
println("valor variable: $variable1")

val variable2: Any = Unit
// Funciona correctamente
println("valor variable: $variable2")
</code></pre>
</section><br><br>


<p class="sub-section">Ámbito (scope) de las variables</p>

<p>
  El ámbito de una variable es el área donde puede usarse. 
  <br><br>
  Por lo general, una variable <span class="negrita">puede utilizarse dentro de todo el bloque de código donde se declara</span>, el cual <span class="negrita">está delimitado por llaves { }</span>.
  <br>
  Una variable puede usarse dentro de todo el bloque, incluyendo otros bloques en su interior.
  <br><br>
  Si una variable <span class="negrita">se declara fuera de un bloque { }</span>, puede utilizarse <span class="negrita">en todos los archivos del proyecto</span>.
</p>

<h3>Conversión de tipos</h3>

<p>
  Si quieres realizar una conversión de tipo, debes <span class="negrita">usar un método de la clase correspondiente al tipo al que quieras convertir</span>.
  <br><br>
  Por ejemplo, para convertir un <span class="negrita">Double</span> a <span class="negrita">Int</span>, debes usar el método <span class="r-word">toInt</span> de la clase Double sobre la variable decimal. 
  <br><br>
  Esto truncará el valor, es decir, se perderá la parte decimal.
</p>

<section><pre><code class="language-kotlin">var decimalNumber: Double = 12.34
var intNumber: Int

intNumber = decimalNumber.toInt()
</code></pre>
</section><br><br>

<p>
  Los métodos de conversión suelen empezar por “to”:
</p>

<section><pre><code class="language-kotlin">toDouble()    toFloat()    toLong()    toInt()
toChar()      toShort()    toByte()    toString()</code></pre>
</section><br><br>

<p>
  Cuando se lee un valor por teclado, siempre se trata como cadena, por lo que si se pide un número, debe convertirse a entero o decimal según convenga:
</p>

<section><pre><code class="language-kotlin">var number = readln().toInt()</code></pre>
</section><br><br>

<h3>Declaración de constantes</h3>

<p>
  La palabra reservada <span class="r-word">val</span> se utiliza para declarar constantes. <br><br>
  Su uso es similar a las variables declaradas con <span class="r-word">var</span>, salvo que, una vez asignado un valor, no puede cambiar durante la ejecución del programa.
</p>

<a href="UD5/images/ud5-2023-09-16-13-32-06.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-32-06.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Sin embargo, las constantes pueden asignarse durante la ejecución del programa, por ejemplo, tras pedir un valor al usuario. 
  Justo después de definirla, debes inicializarla en la misma línea.
</p>

<a href="UD5/images/ud5-2023-09-16-13-36-11.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-36-11.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Los arrays y todos los objetos pueden declararse como <span class="negrita">val</span> y posteriormente cambiar sus valores.
  <br><br>
  Esto es porque son objetos, y con <span class="negrita">val</span> la referencia almacenada no puede cambiar, pero sí los valores internos del objeto.
</p>

<section><pre><code class="language-kotlin">val numbers = arrayOf(1, 2, 3, 4, 0)
// Se puede cambiar el contenido de los elementos
numbers[4] = 5

// Al estar declarado como val, no puede reasignarse el objeto
numbers = arrayOf(1, 2) // Producirá error
</code></pre>
</section><br><br>

<p>
  Puedes usar la palabra reservada <span class="r-word">const</span> antes de la declaración de <span class="negrita">val</span> para definir constantes con valores conocidos.
</p>

<a href="UD5/images/ud5-2023-09-16-13-38-47.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-38-47.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Estas constantes no pueden asignarse durante la ejecución del programa, por lo que deben definirse fuera de las funciones.
</p>

<a href="UD5/images/ud5-2023-09-16-13-39-29.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-39-29.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>
  Las constantes declaradas con <span class="negrita">const</span> pueden declararse dentro de <span class="negrita">objetos singleton</span> (una clase con una sola instancia, que se verá más adelante).
</p>

<a href="UD5/images/ud5-2023-09-16-13-41-26.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-41-26.png" /><br><figcaption></figcaption></figure></a>
<br>


<h3>Operadores</h3>

<p>Permiten crear expresiones. Son similares a los de Java:

  <ul>
    <li>
      Signo:  +    -
      </li>
    <li>
      Aritméticos:  +    -    *    /    %
    </li>
    <li>
      Asignación:  =    +=    -=    *=    /=    %=
      </li>
    <li>
      Incremento:  ++    --    (pueden ser pre o post)
    </li>
    <li>
      Relacionales:  ==    !=    &lt;    >    &lt;=    >=
      </li>
    <li>
      Lógicos:  &&    ||    !
    </li>
    <li>
      A nivel de bits:  and    or    xor    inv    shl (desplaza &lt;-)    shr (desplaza ->)
    </li>
  </ul>
</p>

<h3>Ejercicios 1</h3>

<a class="tarea" target="_blank" href="UD5/exercises/FirstProgramsInKotlin.pdf">Ejercicios</a>

</section> <!-- END SECTION-->


<!--*********************************************************Null Safety***********************************************************-->
<section class="apartado">
<a id="sNullSafety"></a>
<h2>Seguridad de nulos (Null Safety)</h2>

<p>Uno de los errores más comunes y temidos al programar es el famoso <span class="negrita">NullPointerException</span>.</p>

<p>Este error ocurre cuando el programador no inicializa un objeto o, por alguna razón, no se ha inicializado.</p>

<p>Por defecto, Kotlin no permite asignar <span class="r-word">null</span> a las variables para prevenir posibles errores.</p>

<a href="UD5/images/ud5-2023-09-16-13-47-37.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-47-37.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Sin embargo, Kotlin sí admite de forma nativa el valor <span class="r-word">null</span>.</p>

<p>Para declarar variables que puedan almacenar <span class="r-word">null</span>, hay que usar el símbolo <span class="r-word">?</span> tras el tipo de dato en la declaración.</p>

<a href="UD5/images/ud5-2023-09-16-13-49-15.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-49-15.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Kotlin impedirá realizar acciones que puedan provocar un error si la variable es nula.</p>

<a href="UD5/images/ud5-2023-09-16-13-49-54.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-49-54.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Como en Java, para variables que puedan almacenar null, puede hacerse una comprobación previa antes de intentar acceder a ellas.</p>
<section><pre><code class="language-kotlin">var nullableName: String? = "Morty Smith"

if (nullableName != null) {
    println("¡Hola $nullableName!")
} else {
    println("¡Hola invitado!")
}
</code></pre>
</section><br><br>


<p>El operador <span class="r-word">?</span> también permite hacer estas comprobaciones de forma más sencilla, reduciendo código.</p>
<section><pre><code class="language-kotlin">var nullableName: String? = "Morty Smith"
println("${nullableName?.length}")
</code></pre>
</section><br><br>


<p>Este operador permite realizar comprobaciones encadenadas.</p>
<a href="UD5/images/ud5-2023-09-16-13-52-00.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-52-00.png" /><br><figcaption></figcaption></figure></a>
<br>


<h3>Operador Elvis ?:</h3>
<p>El operador Elvis <span class="r-word">?:</span> permite proporcionar un valor por defecto cuando una variable contiene el valor null.</p>

<a href="UD5/images/ud5-2023-09-16-13-54-17.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-54-17.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Su uso más habitual es obtener un valor no nulo cuando una propiedad es nula o un método devuelve null.</p>

<a href="UD5/images/ud5-2023-09-16-13-54-54.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-54-54.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Este operador también puede usarse para <span class="negrita">lanzar</span> una excepción.</p>
<a href="UD5/images/ud5-2023-09-16-13-56-15.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-13-56-15.png" /><br><figcaption></figcaption></figure></a>
<br>


<p>Si tras el operador Elvis deben ejecutarse varias sentencias, han de encerrarse en un bloque <span class="negrita">run { }</span> (esto se explicará con más detalle más adelante).
<br>
La última sentencia del bloque debe ser el valor a asignar si la variable es null.
</p>

<section><pre><code class="language-kotlin">val a = b ?: run {
    val valueWhenBIsNull = c.notNullValue()
    storeValue(valueWhenBIsNull)
    valueWhenBIsNull // Este es el valor por defecto que devuelve el operador Elvis
}
</code></pre>
</section><br><br>


<h3>El operador !!</h3>
<p>Cuando estás <span class="negrita">absolutamente seguro</span> de que una variable que <span class="negrita">puede ser nula no es nula</span>,
  puedes usar el operador <span class="r-word">!!</span> para saltarte el mecanismo de comprobación de nulos de Kotlin.
<br><br>
En este caso, si la variable contiene null, se lanzará un <span class="negrita">NullPointerException</span>.
</p>

<section><pre><code class="language-kotlin">var nullableName: String? = "Morty Smith"
println(nullableName!!.uppercase())
</code></pre>
</section><br><br>

<p>Este operador suele aparecer en migraciones de Java a Kotlin.</p>

<section class="marco-t warn">
  <span class="icono warning"> </span> La filosofía de Kotlin es contraria a su uso. ¡Es decir, no se recomienda utilizarlo!
  </section>
<section class="marco-b">
    
</section>


</section> <!-- FIN SECCION Null Safety-->


<!--*********************************************************Expressiones Regulares***********************************************************-->
<section class="apartado">
  <a id="sExpresionesRegulares"></a>
  <h2>Expresiones regulares</h2>
  
  <p>En todo lenguaje de programación es necesario comprobar si los valores introducidos por el usuario cumplen determinadas reglas.</p>
  
  <p>Una acción muy habitual es comprobar si el usuario ha introducido un valor y si dicho valor es una cadena vacía o no.</p>
  
  <a href="UD5/images/ud5-2023-09-16-14-06-17.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-14-06-17.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>A veces, estas comprobaciones no son suficientes para los requisitos del programa, en cuyo caso se deben usar <span class="negrita">expresiones regulares</span>.</p>
  
  <p>Las expresiones regulares son patrones de caracteres que permiten comprobar si una cadena de texto coincide o no con dicho patrón. 
    <br>Ejemplos típicos de validaciones mediante expresiones regulares:
    <ul>
      <li>Que un nombre no contenga números.</li>
      <li>Que tenga una longitud determinada.</li>
      <li>Que los caracteres sigan un orden concreto (por ejemplo, un DNI: 8 dígitos y 1 letra).</li>
      <li>Que sea una dirección de correo electrónico válida.</li>
      <li>...</li>
    </ul>
   <br>
  
  Las expresiones regulares existen en muchos lenguajes de programación, por lo que es importante entender cómo funcionan.
  </p>
  
  <p>Para crear una expresión regular en Kotlin, se utiliza la clase <span class="r-word">Regex</span>:
  
    <section><pre><code class="language-kotlin">val checkDNI = Regex("expresion_regular")</code></pre>
    </section><br><br>
  
  También se pueden especificar modificadores para la expresión regular:
  
    <section><pre><code class="language-kotlin">val check = Regex("expresion_regular", RegexOption.IGNORE_CASE)</code></pre>
    </section><br><br>
  
  Diseñar expresiones regulares es una habilidad que se complica conforme se quieren comprobar patrones más avanzados.
  A continuación se muestra una breve guía de uso básico de las expresiones regulares.
  </p>
  
  <p><span class="negrita">Agrupaciones</span>
  
  <ul>
    <li>[ ]  [abc] contiene cualquiera de los caracteres indicados.</li>
    <li>[^ ]  [^abc] contiene cualquier carácter excepto los indicados.</li>
    <li>[ - ]  [0-9] contiene cualquier carácter dentro del rango.</li>
    <li>[^ - ]  [^A-B] contiene cualquier carácter fuera del rango.</li>
    <li>( | )  (x|y) contiene uno de los caracteres (usando | como separador).</li>
  </ul>
    
  <br>
  <span class="negrita">Cantidad de caracteres</span>
  <ul>
    <li>{ }  a{3} contiene exactamente 3 'a' seguidas.</li>
    <li>{ ,}  a{3,} contiene 3 o más 'a' seguidas.</li>
    <li>{ , }  a{3,5} contiene 3, 4 o 5 'a' seguidas.</li>
    <li>*  a* contiene 0 o más 'a'. Equivalente a: a{0, }</li>
    <li>+  a+ contiene 1 o más 'a'. Equivalente a: a{1, }</li>
    <li>?  a? contiene 0 o 1 'a'. Equivalente a: a{0,1}</li>
  </ul>
  
  </p>
  
  <p><span class="negrita">Inicio – Fin</span>
    <ul>
      <li>^  ^hola empieza por “hola”.</li>
      <li>$  hola$ termina en “hola”.</li>
      <li>^ $  ^hola$ coincide exactamente con “hola”.</li>
    </ul>
  
  <span class="negrita">Otros</span>
  <ul>
    <li><span class="negrita">\\s</span>  un carácter de espacio en blanco.</li>
    <li><span class="negrita">\\S</span>  cualquier carácter que no sea espacio.</li>
    <li><span class="negrita">\\w</span>  una letra o carácter alfanumérico.</li>
    <li><span class="negrita">\\C</span>  no es una letra.</li>
    <li><span class="negrita">\\d</span>  un dígito. Equivalente a: [0-9]</li>
    <li><span class="negrita">\\D</span>  no es un dígito. Equivalente a: [^0-9]</li>
  </ul>
  
  </p>
  
  <p>Ejemplos de expresiones regulares en Kotlin</p>
  <section><pre><code class="language-kotlin">// contiene 4 letras minúsculas
"[a-z]{4}"

// contiene 8 caracteres: letras y/o números
"[a-zA-Z0-9]{8}"

// 7 u 8 dígitos seguidos de 1 letra (DNI)
"^\\d{7,8}\\w{1}$"

// conjunto de letras, seguido de una @, seguido de letras, 
// seguido de un punto y de 2 o 3 letras 
// patrón simple de email: rick_sanchez@mail.com
"^[a-z_.]+@[a-z]+\\.[a-z]{2,3}$"
</code></pre>
  </section><br><br>
  
  <p>Para comprobar si una variable coincide con un patrón definido por una expresión regular, se pueden usar métodos tanto de la clase <span class="r-word">String</span> como de la clase <span class="r-word">Regex</span>:</p>
  
  <section><pre><code class="language-kotlin">val name = "Rick"
// Empieza con mayúscula seguida de al menos dos minúsculas
val checkName = Regex(pattern = "^[A-Z][a-z]{2,}$")

// Verificación con String
println(name.contains(checkName))

// Verificación con Regex
println(checkName.matches(name))
</code></pre>
  </section><br><br>
  
  
  <p>La clase Regex también dispone de otros métodos con diferentes funcionalidades, como:
  
    <ul>
      <li>replace</li>
      <li>find</li>
    </ul>	
  </p>
  
  <p>Para crear expresiones regulares puedes consultar “Cheat Sheets”:
    <a class="enlace" target="_blank" href="https://quickref.me/regex">https://quickref.me/regex</a>
  
  <br>
  También existen herramientas para probar expresiones regulares:
    <a class="enlace" target="_blank" href="https://regex101.com/">https://regex101.com/</a>
  </p>
  <a href="UD5/images/ud5-2023-09-16-14-22-42.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-14-22-42.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <h3>Excepciones</h3>
  
  <p>Las excepciones se capturan con bloques <span class="r-word">try – catch</span> de la misma forma que en Java.</p>
  
  <a href="UD5/images/ud5-2023-09-16-14-23-34.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-14-23-34.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <h3>Ejercicios</h3>
  
  <a class="tarea" target="_blank" href="UD5/exercises/ValidatingData.pdf">Ejercicios 2</a>
  

</section> <!-- FIN SECCION Expresiones Regulares-->


<!--*********************************************************Control de Flujo***********************************************************-->
<section class="apartado">
  <a id="sControldeFlujo"></a>
  <h2>Control de flujo</h2>
  <p>Son instrucciones que permiten alterar el flujo normal de ejecución del programa. Son muy similares a las de cualquier otro lenguaje.</p>
  
  <p>
    <ul>
      <li>if</li>
      <li>if – else</li>
      <li>if – else if – else</li>
      <li>when</li>
      <li>for</li>
      <li>while</li>
      <li>do – while</li>
      <li>repeat</li>
    </ul>
  </p>
  
  <p>Guía de estilo para las llaves <span class="negrita">{ }</span>:</p>
  
  <p>
    <ul>
      <li>
        No hacen <span class="negrita">falta</span> llaves en ramas de <span class="r-word">when</span> o en expresiones <span class="r-word">if</span> 
        que no tengan más de una rama <span class="r-word">else</span> y <span class="negrita">quepan en una sola línea</span>.
        </li>
      <li>
        Las llaves <span class="negrita">sí son necesarias</span> para cualquier rama de <span class="r-word">if, for, when, do</span>, 
        y para sentencias y expresiones <span class="r-word">while</span>, incluso si el cuerpo está vacío o contiene una sola sentencia.
      </li>
    </ul>
  </p>
  
  <h3>if, if-else e if-else if-else</h3>
  
  <p>Si se puede escribir en una línea, omite las llaves; se prefiere redactarlo así.</p>
  
  <a href="UD5/images/ud5-2023-09-16-23-59-05.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-16-23-59-05.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p class="sub-section">if como expresión</p>
  
  <p>La sentencia <span class="negrita">if</span> puede usarse como expresión, por ejemplo, para asignar un valor a una variable, como se ve en el ejemplo:
   <br>
  
  <a href="UD5/images/ud5-2023-09-17-00-01-02.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-01-02.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  En este caso, se puede escribir la expresión así, pero es obligatorio incluir la rama else.
  
  <a href="UD5/images/ud5-2023-09-17-00-02-29.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-02-29.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Si se usa como expresión, <span class="negrita">la rama else es obligatoria</span>.
  </p>
  
  <p>Al usar <span class="negrita">if</span> como expresión, se pueden utilizar llaves para varias sentencias. 
     En ese caso, <span class="negrita">la última sentencia dentro de las llaves debe ser el valor a asignar</span>.
  
  Si se usa como expresión con bloques de código, la última expresión será el valor asignado sin necesidad de igualarla a la variable.
  </p>
  
  <section><pre><code class="language-kotlin">var highNumber = if (number1 > number2) {
    // instrucciones
    number1
} else {
    // instrucciones
    number2
}

println("El número mayor es $highNumber")
</code></pre>
  </section><br><br>
  
  <h3>when</h3>
  <p>Una condición con múltiples ramas (similar a switch en Java):
  <a href="UD5/images/ud5-2023-09-17-00-05-39.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-05-39.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Si en alguna rama hay varias sentencias, se deben usar llaves en todas las ramas:
  <section><pre><code class="language-kotlin">when (number) {
    1 -> {
        // instrucciones
    }
    2 -> {
        // instrucciones
    }
}
</code></pre>
  </section><br><br>
  
  </p>
  
  <p>Con when se pueden agrupar valores:
  <a href="UD5/images/ud5-2023-09-17-00-07-21.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-07-21.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  También se pueden usar expresiones a evaluar:
  <a href="UD5/images/ud5-2023-09-17-00-07-58.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-07-58.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Es posible usar <span class="r-word">in</span> o <span class="r-word">!in</span> para evaluar rangos y colecciones:
  <a href="UD5/images/ud5-2023-09-17-00-08-33.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-08-33.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Puedes comprobar si la variable es de un tipo o no usando <span class="r-word">is</span> o <span class="r-word">!is</span>:
  <a href="UD5/images/ud5-2023-09-17-00-08-53.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-08-53.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>En algunos casos, <span class="subrayado">la rama else es obligatoria</span>, por ejemplo, si el resultado de la expresión es un <span class="negrita">boolean</span>:
  <a href="UD5/images/ud5-2023-09-17-00-13-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-13-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Si no se proporciona una variable para evaluar, when puede usarse para reemplazar bloques if-else:
  <a href="UD5/images/ud5-2023-09-17-00-13-46.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-13-46.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Puede usarse como expresión; en ese caso, la rama else es obligatoria salvo que el compilador pueda verificar que todas las opciones están cubiertas:
  
    <a href="UD5/images/ud5-2023-09-17-00-15-19.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-15-19.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <a href="UD5/images/ud5-2023-09-17-00-15-40.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-15-40.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    
  </p>
  
  <h3>for</h3>
  <p>Los bucles for en Kotlin son algo distintos: utilizan rangos, progresiones y colecciones para las iteraciones.
  
  <ul>
    <li>
      <span class="negrita">Rangos</span>: series ascendentes/descendentes de Int, Long o Char.
    </li>
    <li>
      <span class="negrita">Progresiones</span>: como un rango pero con un parámetro de paso entre elementos.
    </li>
    <li>
      <span class="negrita">Colecciones</span>: conjuntos de elementos como arrays.
    </li>
  </ul>
  </p>
  
  <p class="sub-section">Rangos y progresiones</p>
  <p>Existen distintas formas de crear rangos y progresiones. La imagen de la izquierda muestra cómo se crean, pero por defecto Android Studio tiene sugerencias de código activadas. Una vez creado el rango, verás en la imagen de la derecha más información.
  Todos los rangos pueden usarse como progresiones con paso por defecto 1 o convertirse en progresiones con un paso explícito como en el último ejemplo.
  
  <a href="UD5/images/ud5-2023-09-17-00-20-21.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-20-21.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p class="sub-section">Bucles for para rangos, progresiones y colecciones</p>
  
  <p>Los bucles for usan <span class="negrita">rangos, progresiones y colecciones</span>, y para iterarlos se utiliza la palabra <span class="r-word">in</span>.
  <a href="UD5/images/ud5-2023-09-17-00-22-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-22-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  <p>También funciona con rangos de caracteres:
    <a href="UD5/images/ud5-2023-09-17-00-23-22.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-23-22.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p>La sentencia for permite iterar objetos que proporcionan un <span class="negrita">iterator</span>, como <span class="subrayado">strings, listas, arrays o colecciones.</span>
  <br>
  Puedes acceder a la posición de dos maneras.
  <a href="UD5/images/ud5-2023-09-17-00-24-41.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-24-41.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>while y do-while</h3>
  <p>while: primero comprueba la condición; es posible que el cuerpo no se ejecute.
  
  <a href="UD5/images/ud5-2023-09-17-00-26-03.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-26-03.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  do-while: la condición se evalúa después de ejecutar el cuerpo, por lo que el cuerpo se ejecuta al menos una vez.
  <a href="UD5/images/ud5-2023-09-17-00-26-33.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-26-33.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>repeat</h3>
  <p>La función <span class="r-word">repeat</span> repite el cuerpo el número de veces indicado; internamente ejecuta un bucle for.
  <section><pre><code class="language-kotlin">repeat(times = 100) { 
    println("Los 'Billetes de Bart' no son de curso legal.") 
}

repeat(times = 100) { index ->
    println("${index + 1}.- Los 'Billetes de Bart' no son de curso legal.")
}
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>break, continue y return</h3>
  
  <p>Kotlin proporciona tres formas típicas de romper el flujo de un bucle.
  
    <ul>
      <li><span class="negrita">return</span>: sale del bucle y de la función que lo contiene.</li>
      <li><span class="negrita">break</span>: sale del bucle actual.</li>
      <li><span class="negrita">continue</span>: salta a la siguiente iteración del bucle.</li>
    </ul>
  </p>
  <p>En Kotlin se pueden etiquetar sentencias usando el carácter <span class="negrita">@</span> como <span class="d-word">nombreEtiqueta@</span>, permitiendo romper el flujo de cualquier serie de bucles anidados.
  <br>
  Añadiendo etiquetas, un break terminará el bucle que esté etiquetado.
  
  <section><pre><code class="language-kotlin">firstFor@ for (i in 1..10) {
    for (j in 1..5) {
        if (i % 2 == 0 && j == 2) break@firstFor
        println("$i - $j")
    }
}
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>Ejercicios</h3>
  
  <a class="tarea" target="_blank" href="UD5/exercises/ControlFlujoKotlin.pdf">Ejercicios 3</a>
  

</section> <!-- FIN SECCION Control de Flujo-->


<!--*********************************************************Colecciones***********************************************************-->
<section class="apartado">
  <a id="sColecciones"></a>
  <h2>Colecciones</h2>
  
  <p><span class="negrita">Las colecciones</span> son un tipo de dato que permite almacenar un número variable de elementos, cero o más.
  
  Normalmente, una colección almacenará elementos del mismo tipo de dato.
  
  Se pueden guardar datos de distintos tipos, pero en ese caso hay que tener especial cuidado al usar la colección.
  
  Además, las colecciones pueden almacenar el valor <span class="negrita">null</span> en cualquiera de sus elementos. En Kotlin hay cuatro tipos de colecciones:
  </p>
  
  <p><strong>Array</strong>:</p>
  <ul>
    <li>Colección de elementos.</li>
    <li>Los elementos se acceden por su índice de posición.</li>
    <li>Los elementos pueden repetirse.</li>
    <li>Dos arrays no son iguales aunque contengan los mismos elementos en la misma posición.</li>
  </ul>
  
  <p><strong>List</strong>:</p>
  <ul>
    <li>Colección <strong>ordenada</strong> de elementos.</li>
    <li>Los elementos se acceden por su índice de posición.</li>
    <li>Los elementos pueden repetirse.</li>
    <li>Dos List son iguales si contienen los mismos elementos en la misma posición.</li>
  </ul>
  
  <p><strong>Set</strong>:</p>
  <ul>
    <li>Colección de elementos <strong>sin orden</strong>.</li>
    <li>En un Set los elementos no pueden repetirse.</li>
    <li>Dos Set son iguales si contienen los mismos elementos, independientemente del orden.</li>
  </ul>
  
  <p><strong>Map</strong>:</p>
  <ul>
    <li>También llamados diccionarios.</li>
    <li>Un Map es un conjunto de pares <span class="negrita">clave-valor</span>, y la clave no puede repetirse.</li>
    <li>Dos Map son iguales si contienen los mismos pares clave-valor, independientemente del orden.</li>
  </ul>
  </p>
  
  <p>Para <span class="negrita">List, Set y Map</span>, Kotlin ofrece dos versiones:
  
  <ul>
    <li><span class="negrita">Inmutable</span>:
      <ul>
        <li>No se pueden añadir ni eliminar elementos de la colección.</li>
        <li>No se puede modificar ningún elemento de la colección.</li>
      </ul>
    </li>
  </ul>
  
  <ul>
    <li><span class="negrita">Mutable</span>:
      <ul>
        <li>Se pueden añadir, eliminar y modificar elementos en la colección.</li>        
      </ul>
    </li>
  </ul>
  <br>		
  </p>
  
  <h3>List y MutableList</h3>
  <p>
  Sean mutables o no, pueden declararse con <span class="r-word">val</span> o <span class="r-word">var</span>.
  
  Su comportamiento interno determina si pueden modificarse o no.
  <a href="UD5/images/ud5-2023-09-17-00-41-49.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-41-49.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <a href="UD5/images/ud5-2023-09-17-00-42-14.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-42-14.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  </p>
  
  <p>Algunas operaciones sobre List y MutableList
  <section class="marco-t warn">
    <span class="icono warning"> </span> Las operaciones que modifican solo son aplicables a MutableList
  </section>
  <section class="marco-b">
      
  </section>
  <section><pre><code class="language-kotlin">val list = listOf("uno", "dos", "tres", "cuatro, "cinco")
list.size                    // Devuelve el valor 5
list[2]                      // Devuelve la cadena "tres"
list.indexOf("cuatro")       // Devuelve el valor 3
list.lastIndexOf("dos")      // Devuelve el valor 1
list.subList(1, 3)           // Devuelve la lista ["dos", "tres"]

val mutableList = mutableListOf(1, 2, 3, 4, 5)
mutableList.add(6)           // Añade el elemento 6 al final de la lista
mutableList.add(index = 2, element = 100)  // Añade 100 en la posición 2, desplazando el resto a la derecha
mutableList.removeAt(index = 4)  // Elimina el elemento en la posición 4
mutableList[1] = 99          // Cambia el valor de la posición 1 a 99
mutableList.contains(3)      // Devuelve true/false si el valor se encuentra o no
mutableList.sort()           // Ordena los elementos del array de forma ascendente
mutableList.sortDescending() // Ordena los elementos del array de forma descendente
mutableList.max()            // Devuelve el elemento mayor
mutableList.min()            // Devuelve el elemento menor
mutableList.isEmpty()        // Devuelve true/false según si la lista está vacía
mutableList.isNotEmpty()     // Devuelve true/false según si la lista no está vacía
mutableList.shuffle()        // Baraja aleatoriamente los elementos del array
mutableList.shuffled()       // Devuelve un array con los elementos barajados aleatoriamente
mutableList.first()          // Devuelve el primer elemento del array
mutableList.last()           // Devuelve el último elemento del array
mutableList.count()          // Devuelve el número de elementos del array
mutableList.reverse()        // Invierte los elementos del array
mutableList.reversed()       // Devuelve un array con los elementos en orden inverso
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>Set y MutableSet</h3>
  <p class="sub-section">Set</p>
  <a href="UD5/images/ud5-2023-09-17-00-44-59.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-44-59.png" /><br><figcaption></figcaption></figure></a>
   <br>
  
  <p class="sub-section">MutableSet</p>
  <a href="UD5/images/ud5-2023-09-17-00-45-22.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-45-22.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>Algunas operaciones sobre Set y MutableSet
  <section class="marco-t warn">
    <span class="icono warning"> </span> Las operaciones que modifican solo son aplicables a MutableSet
  </section>
  <section class="marco-b">
      
  </section>
  <section><pre><code class="language-kotlin">val names = mutableSetOf("Ana", "Jorge", "Lucía")
names.add("Lucas")          // Añade un nuevo elemento
names.add("Ana")            // No añade el elemento porque ya existe
names.add("ana")            // Añade el elemento -> "ana" != "Ana"
names.remove(element = "Jorge") // Elimina el elemento si se encuentra. Devuelve true/false
names.contains("ana")       // Comprueba si existe el elemento. Devuelve true/false

names.min()                 // Devuelve el menor elemento
names.max()                 // Devuelve el mayor elemento
names.isEmpty()             // Devuelve true/false si el conjunto está vacío
names.isNotEmpty()          // Devuelve true/false si el conjunto no está vacío
names.first()               // Devuelve el primer elemento del conjunto
names.last()                // Devuelve el último elemento del conjunto
names.reversed()            // Devuelve un conjunto con los elementos en orden inverso
names.shuffled()            // Devuelve un conjunto with los elementos en orden aleatorio
names.isEmpty()             // Devuelve true/false si el conjunto está vacío
names.isNotEmpty()          // Devuelve true/false si el conjunto no está vacío
names.count()               // Devuelve el número de elementos del conjunto

val set1 = setOf(1, 3, 4, 8, 7, 12, 15)
val set2 = setOf(24, 7, 5, 1, 8, 6)

// Devuelve un conjunto con los elementos de ambos grupos sin repeticiones
val joinedGroups = set1 union set2

// Devuelve un conjunto con los elementos comunes a ambos grupos
val commonElements = set1 intersect set2

// Devuelve un conjunto con los elementos de group2 que están en group1
val differentElements = set1 subtract set2
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>Map</h3>
  <p>Creación de un Map</p>
  <a href="UD5/images/ud5-2023-09-17-00-48-58.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-48-58.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>Creación de un MutableMap</p>
  <section><pre><code class="language-kotlin">val person: MutableMap<String, Any> = mutableMapOf(
    "name" to "Rick Sanchez",
    "age" to 70,
    "alive" to true,
    "dimension" to "c-137"
)
</code></pre>
  </section><br><br>
  
  <p>Algunas operaciones sobre Map y MutableMap
  <section class="marco-t warn">
    <span class="icono warning"> </span> Las operaciones que modifican solo son aplicables a MutableMap
  </section>
  <section class="marco-b">
      
  </section>
  
  <section><pre><code class="language-kotlin">val person = mutableMapOf(
    "name" to "Rick Sanchez",
    "age" to 70,
    "alive" to true
)

person.put("dimension", "c-137")  // Añade el par clave-valor al Map
person.remove(key = "age")        // Elimina y devuelve el elemento cuya clave coincida
person.keys                       // Devuelve una lista de claves
person.values                     // Devuelve una lista de valores
person.size                       // Devuelve el número de pares clave-valor
person.clear()                    // Vacía el Map

// Recorrer un Map o MutableMap
for ((key, value) in person) {
    println("$key -> $value")
}
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>Operaciones sobre colecciones</h3>
  
  <p>Algunas operaciones sobre colecciones devuelven un valor booleano indicando si la operación tuvo éxito o no. 
    Por ejemplo, <span class="negrita">add</span> y <span class="negrita">remove</span>.
  
  Si quieres conocer todas las operaciones disponibles para <span class="negrita">List, Set y Map</span>, tanto mutables como de solo lectura, debes consultar la documentación oficial.
  </p>
  
  <p>Existen operaciones sobre colecciones que permiten realizar operaciones sobre todos los elementos de la colección y devuelven una nueva colección con los resultados.
  
  Se podría decir que “iteran” sobre la colección.
  
  Estas operaciones aceptan una <span class="negrita">función lambda</span>, lo que implica usar llaves para delimitar las instrucciones. (El uso de una lambda también se vio en la declaración de arrays, y se explicará en detalle más adelante).
  
  Dentro de la función lambda, <span class="negrita">it</span> estará disponible <span class="subrayado">como el elemento actual.</span>
  </p>
  
  <p class="sub-section">forEach</p>
  
  <p>Itera por todos los elementos de la colección, permitiendo realizar acciones sobre ellos.
    <a href="UD5/images/ud5-2023-09-17-00-54-04.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-54-04.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p class="sub-section">filter</p>
  
  <p>Devuelve la colección con los elementos que cumplen la condición.
    <a href="UD5/images/ud5-2023-09-17-00-55-46.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-55-46.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p class="sub-section">map</p>
  
  <p>Devuelve la colección aplicando una transformación a cada elemento.
    <a href="UD5/images/ud5-2023-09-17-00-55-23.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-00-55-23.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <h3>Secuencias</h3>
  
  <p>Las secuencias permiten optimizar las operaciones sobre colecciones.</p>
  
  <section><pre><code class="language-kotlin">val list = listOf("Uno", "Dos", "Tres", "Cuatro", "Cinco")
val secondList = list.filter { it.length > 3 }
    .map { it.uppercase() }
</code></pre>
  </section><br><br>
  
  <p>
  En el ejemplo anterior, ambas operaciones se realizan sobre todos los elementos de la lista, generando listas intermedias que no desaparecen hasta que finalizan todas las operaciones.
  
  Este comportamiento, cuando la colección tiene muchos elementos y/o se realizan muchas operaciones sobre ella, penalizará el rendimiento de la aplicación.
  </p>
  <p>Para mejorar este comportamiento, puedes convertir la colección en secuencia, realizar todas las operaciones y finalmente volver a generar la colección.
    La secuencia no genera colecciones intermedias.
    
  <section><pre><code class="language-kotlin">val list = listOf("Uno", "Dos", "Tres", "Cuatro", "Cinco")
val secondList = list.asSequence()
    .filter { it.length > 3 }
    .map { it.uppercase() }
    .toList()
</code></pre>
  </section><br><br>
    
  </p>
  
  <p>Las secuencias solo generan sus elementos cuando se usan, permitiendo generar un número infinito de valores y consumirlos después.
  Hay que tener cuidado, ya que la aplicación podría quedarse bloqueada esperando a que la secuencia termine.
  
  </p>

  <section><pre><code class="language-kotlin">// Genera una secuencia infinita de números impares
val oddNumbers = generateSequence(seed = 1) { it + 2 }

// Recorre la secuencia y genera una lista con los elementos menores de 200
val oddNumbersTo200 = oddNumbers.takeWhile { it &lt; 200 }.toList()
</code></pre>
  </section><br><br>
  
</section> <!-- Fin Sección Colecciones-->


<!--*********************************************************Funciones***********************************************************-->
<section class="apartado">
  <a id="sFunciones"></a>
  <h2>Funciones</h2>
  
  <h3>Funciones incorporadas</h3>
  <p>Como en cualquier lenguaje de programación, Kotlin incorpora gran cantidad de funciones ya programadas y listas para usar.
  
  Algunas ya las hemos visto: <span class="negrita">println, toInt, toString</span>… <br>
  
  Para arrays, por ejemplo, tienes funciones como:
    <section><pre><code class="language-kotlin">min()      max()      isEmpty()      indexOf()
sort()     sorted()   reverse()      reversedArray()</code></pre>
    </section><br><br>
  
  Puedes consultarlas todas en la documentación.
  </p>
  
  <h3>Funciones personalizadas</h3>
  <p>En Kotlin, las funciones se declaran con la palabra clave <span class="r-word">fun</span>.
  
  Ejemplo de una función y su llamada:
  <a href="UD5/images/ud5-2023-09-17-01-04-49.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-04-49.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Las funciones pueden no tener parámetros y no devolver valores.
  
  Si no se especifica tipo de retorno, devuelve <span class="r-word">Unit</span>, equivalente a <span class="negrita">void</span> en otros lenguajes. 
  Si no se devuelve nada, se puede omitir <span class="r-word">: Unit</span>.
  <a href="UD5/images/ud5-2023-09-17-01-06-10.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-06-10.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Los parámetros se separan por comas y se permite el uso de <span class="negrita">trailing comma</span> (coma final).
  </p>

  <section><pre><code class="language-kotlin">fun areEqual(
    num1: Int,
    num2: Int,
): Boolean {
    return if (num1 == num2) true else false
}

areEqual(num1 = 26, num2 = 123)
</code></pre>
  </section><br><br>
  
  <p><span class="subrayado">Los parámetros de entrada son inmutables</span>, es decir, no pueden cambiar su valor dentro del cuerpo de la función, como si se hubieran declarado con <span class="r-word">val</span>.
  
  Para modificarlos, hay que crear una copia.
  <a href="UD5/images/ud5-2023-09-17-01-09-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-09-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Si la función puede escribirse en una sola línea, puedes <span class="negrita">eliminar las llaves y añadir el símbolo =</span> antes del cuerpo.
  <a href="UD5/images/ud5-2023-09-17-01-10-33.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-10-33.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Otras funciones:
  <section><pre><code class="language-kotlin">fun saludo(nombre: String) = println("¡Hola $nombre!") 
// Imprime un saludo con el nombre proporcionado

fun suma(num1: Int, num2: Int): Int = num1 + num2
// Suma dos números y devuelve el resultado

fun esPar(num: Int): Boolean = num % 2 == 0
// Comprueba si un número es par y devuelve true/false

// Si no se especifica el tipo de retorno, Kotlin lo infiere
fun enRango(num: Int, min: Int, max: Int) = num in min..max
// Comprueba si el número está dentro del rango definido por min y max

fun enRango(num: Int, rango: IntRange) = num in rango
// Comprueba si el número está dentro del IntRange dado
</code></pre>
  </section><br><br>
  
  </p>
  
  <p class="sub-section">Parámetros con nombre</p>
  
  <p>Puedes usar los nombres de los parámetros al invocar una función, lo que permite cambiar el orden de los parámetros.
  
  Igual que con los rangos, Android Studio muestra sugerencias con los nombres de los parámetros.
  <a href="UD5/images/ud5-2023-09-17-01-12-40.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-12-40.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p class="sub-section">Valores por defecto</p>
  
  <p>Es posible definir valores por defecto para los parámetros de entrada, permitiendo omitirlos si se desea.
    <a href="UD5/images/ud5-2023-09-17-01-14-26.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-14-26.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p>Si se usan valores por defecto en la definición y parámetros con nombre en la llamada, se pueden omitir parámetros intermedios.
  
    <section><pre><code class="language-kotlin">fun precioFinal(
    precio: Double,
    iva: Int = 21,
    descuento: Int = 0,
): Double {
    var resultado = precio
    if (descuento != 0) resultado -= precio * descuento / 100
    return resultado + resultado * iva / 100
}

// Ejemplos de llamada:
precioFinal(precio = 355.0, iva = 10, descuento = 5)  // Descuento e IVA explícitos
precioFinal(precio = 355.0, iva = 10)                 // Descuento por defecto
precioFinal(precio = 355.0, descuento = 20)           // IVA por defecto
</code></pre>
    </section><br><br>
    
  </p>
  
  <p>Si en la llamada se mezclan parámetros con nombre y sin nombre, los argumentos con nombre deben ir al final salvo que ocupen su lugar correcto.
    <a href="UD5/images/ud5-2023-09-17-01-17-29.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-17-29.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <h3>Número variable de parámetros</h3>
  <p>Es posible declarar un número variable de parámetros.
  
  Se hace usando un parámetro con la palabra clave <span class="r-word">vararg</span>.
  
  Suele ser el último parámetro. Si no lo es, los parámetros posteriores deben pasarse usando su nombre.
  
  Con un <span class="negrita">IntArray</span> o una <span class="negrita">colección convertible a IntArray</span>, puedes usar el operador <span class="negrita">*</span>
  (spread operator) para pasarlo entero al parámetro <span class="negrita">vararg</span>.
  <a href="UD5/images/ud5-2023-09-17-01-19-00.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-19-00.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>Sobrecarga de funciones</h3>
  
  <p>Kotlin permite la sobrecarga de funciones aunque no estén definidas dentro de una clase.
    <a href="UD5/images/ud5-2023-09-17-01-20-14.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-20-14.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p>En ejemplos anteriores se creó la función <span class="negrita">max</span>, que ya existe, provocando una sobrecarga. Puedes ver tanto tu función como la del sistema.
  <a href="UD5/images/ud5-2023-09-17-01-22-00.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-22-00.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>Ámbito de las funciones</h3>
  <p>Al igual que con las variables, el ámbito de una función determina dónde puede usarse.
  
  En Kotlin existen los siguientes tipos de funciones:
  
  <ul>
    <li>Funciones de <span class="negrita">nivel superior</span>.</li>
    <li>Funciones <span class="negrita">locales</span>.</li>
    <li>Funciones <span class="negrita">miembro</span>.</li>
    <li>Funciones de <span class="negrita">extensión</span>.</li>
  </ul>
  
  Según el tipo, podrá usarse en distintas partes del código.
  </p>
  
  <p class="sub-section">Funciones de nivel superior</p>
  
  <p>Se definen sin estar dentro de ningún bloque { } ni clase.
  
  Se utilizan típicamente como librerías de funciones, donde un archivo incluye varias funciones de nivel superior reutilizables.
  
  Pueden usarse en todo el archivo y en cualquier archivo donde se importen.
  <a href="UD5/images/ud5-2023-09-17-01-24-51.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-24-51.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  

  <p class="sub-section">Locales</p>

  <p>
  Las funciones locales se definen dentro de otra función y pueden usarse en todo el bloque { } de esa función, incluso desde otras funciones locales dentro de la misma función padre.
  
  Deben definirse antes de cualquier llamada a ellas.
  
  Las funciones locales pueden usar las variables locales de la función contenedora.
  <a href="UD5/images/ud5-2023-09-17-01-25-59.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-01-25-59.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p class="sub-section">Miembro</p>
  
  <p>
  Son funciones definidas dentro de clases u objetos.
  En programación orientada a objetos se conocen como <span class="negrita">métodos</span>.
  Se tratan en la siguiente sección, <span class="negrita">POO</span> (Programación Orientada a Objetos).
  </p>
  
  <p class="sub-section">Funciones de extensión</p>
  
  <p>
  Kotlin permite extender la funcionalidad de las clases añadiéndoles funciones.
  Estas funciones solo existen dentro del ámbito en el que se definen.

  <section><pre><code class="language-kotlin">fun main() {
    val numero = (0..100).random() // Genera un número aleatorio entre 0 y 100
    if (numero.esImpar()) println("$numero es impar") // Comprueba si es impar
    else println("$numero es par") // En caso contrario, es par
}

// Añade una función a la clase Int
fun Int.esImpar(): Boolean {
    return this % 2 != 0 // Devuelve true si no es divisible entre 2
}
</code></pre>
  </section><br><br>
  
  </p>
  
  <h3>Funciones inline</h3>
  <p>En una función normal, su código se almacena en memoria una vez. Cada vez que se invoca, se apilan los parámetros y se llama a la función.</p>
  
  <p>En una <span class="d-word">función inline</span> no se produce la invocación: el código de la función se inserta allí donde se usa.</p>
  
  <p>En teoría, una función inline tiene mejor rendimiento que una función normal porque evita usar la pila para pasar parámetros y las instrucciones de salto/retorno. 
  No obstante, esto depende de cómo se compile el código. 
  Por ejemplo, en la JVM, incluso las instrucciones de máquina usan la pila. 
  Como el código se “copia” cada vez que se llama a la función inline, el tamaño del ejecutable aumentará cuanto más crezca la función inline.</p>
  
  <section><pre><code class="language-kotlin">inline fun suma(a: Int, b: Int) = a + b
val c = suma(2, 2)</code></pre>
  </section><br><br>
  
  <p>La ventaja real de las funciones inline aparece al aplicarlas a funciones de orden superior. 
  Las funciones de orden superior tienen ciertas penalizaciones de rendimiento (tanto en tiempo como en memoria). 
  Al invocar el parámetro Lambda, se crea un nuevo objeto en memoria que contiene un método con los parámetros especificados en la Lambda.</p>
  
  <h3>Ejercicios</h3>
  
  <a class="tarea" target="_blank" href="UD5/exercises/Actividades Reutilizar código.pdf">Ejercicios 4</a>
  

</section><!-- Fin sección Funciones-->


<!--*********************************************************Programación Orientada a Objetos***********************************************************-->
<section class="apartado">
  <a id="sPOO"></a>
  <h2>Programación Orientada a Objetos (POO)</h2>
  
  <p>Como se mencionó al inicio de esta unidad, Kotlin busca ser conciso y evitar escribir código en exceso.
  Esto se vuelve muy evidente al desarrollar clases.
  Estudiaremos tanto la forma “tradicional” de codificar clases como en Java, como el enfoque recomendado en Kotlin.
  </p>
  
  <p>Para crear clases se utiliza la palabra reservada <span class="r-word">class</span>, igual que en Java.
  
  Kotlin permite definir más de una clase pública en un único archivo <span class="negrita">.kt</span> (en Java no está permitido).
  Si solo se define una clase en un archivo <span class="negrita">.kt</span>, entonces el <span class="subrayado">nombre del archivo puede ser descriptivo</span> (no es obligatorio que coincida con el nombre de la clase, aunque es una práctica habitual).
  Si se definen varias clases en un archivo <span class="negrita">.kt</span>, se recomienda elegir un nombre de archivo representativo.
  </p>
  
  <p>En Kotlin, todas las clases heredan de la clase <span class="r-word">Any</span> (en Java, de Object).
  
  La clase <span class="negrita">Any</span> define tres métodos heredados por sus subclases:
  <ul>
    <li><span class="negrita">equals</span> → indica si un objeto es igual a otro</li>
    <li><span class="negrita">hashCode</span> → devuelve el código hash de un objeto</li>
    <li><span class="negrita">toString</span> → devuelve la representación en texto de un objeto</li>
  </ul>
  </p>
  
  <p>Ejemplo de definición de una clase en Kotlin:
  
  <a href="UD5/images/ud5-2023-09-17-13-14-35.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-14-35.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  Kotlin es tan conciso que una clase sin cuerpo puede definirse así:
  
  <a href="UD5/images/ud5-2023-09-17-13-15-00.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-15-00.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  Incluso sin cuerpo, puede instanciarse un objeto de esta clase:
  <a href="UD5/images/ud5-2023-09-17-13-15-39.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-15-39.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Se puede observar que la estructura para definir una clase es similar a la usada en Java.
  
  Los <span class="negrita">getters</span> y <span class="negrita">setters</span> se definen tras cada propiedad.
  
  El constructor se define con la palabra <span class="r-word">constructor</span>.
  <section><pre><code class="language-kotlin">class Product {
    var name: String
        get() {
            return field // Devuelve el valor de la propiedad
        }
        set(name: String) {
            field = name // Actualiza el valor de la propiedad
        }

    var price: Double
        get() {
            return field // Devuelve el valor de la propiedad
        }
        set(price: Double) {
            field = price // Actualiza el valor de la propiedad
        }

    constructor(name: String, price: Double) {
        this.name = name // Inicializa la propiedad name
        this.price = price // Inicializa la propiedad price
    }
}
</code></pre>
  </section><br><br>
  
  
  Su uso también es similar a Java:
  <a href="UD5/images/ud5-2023-09-17-13-18-05.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-18-05.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Si no se indica lo contrario, las clases, propiedades y métodos son <span class="negrita">public</span> por defecto.
  
  Existen modificadores de visibilidad:
  <ul>
    <li><span class="negrita">public</span></li>
    <li><span class="negrita">private</span></li>
    <li><span class="negrita">protected</span></li>
    <li><span class="negrita">internal</span> → visible dentro del mismo <em>módulo</em></li>
  </ul>
  
  <a href="UD5/images/ud5-2023-09-17-13-20-49.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-20-49.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Kotlin ahorra código usando funciones de expresión (en una línea):
    <a href="UD5/images/ud5-2023-09-17-13-21-58.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-21-58.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    
  </p>
  
  <p>Kotlin también ahorra código haciendo implícitos los getters y setters:
    <a href="UD5/images/ud5-2023-09-17-13-22-55.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-22-55.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    
  </p>
  
  <p>Kotlin permite reducir aún más incorporando propiedades en la definición de la clase, haciendo el <span class="negrita">constructor implícito</span>:
  <a href="UD5/images/ud5-2023-09-17-13-23-48.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-23-48.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>Constructores</h3>
  
  <p>Con esta estructura obtienes constructor, getters y setters:
  
  <a href="UD5/images/ud5-2023-09-17-13-24-47.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-24-47.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  Si no se requieren acciones específicas en constructor, getters o setters, esta sintaxis ahorra mucho código.
  
  Usando esta sintaxis, al constructor se le denomina <span class="negrita">constructor primario</span>.
  </p>
  
  <p>Los constructores definidos en el cuerpo de la clase se llaman <span class="negrita">constructores secundarios</span>.
  
  Los constructores se declaran con la palabra reservada <span class="r-word">constructor</span>.
  
  Existe sobrecarga de constructores, como puede verse en el ejemplo.
  
  Si una propiedad no aparece en ningún constructor, <span class="subrayado">debe tener un valor por defecto</span> (o delegarse/posponerse su inicialización).
  
  <a href="UD5/images/ud5-2023-09-17-13-35-03.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-35-03.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <a href="UD5/images/ud5-2023-09-17-13-35-37.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-35-37.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Si se usan constructor primario y secundarios, en los secundarios debe emplearse la palabra <span class="r-word">this</span>.
  
  La palabra <span class="negrita">this</span> llama al constructor primario (similar a <code>this(...)</code> en Java).
  </p>
  
  <p>Puede no haber constructores explícitos en absoluto.
  
  En ese caso, las propiedades deben recibir un valor en su declaración.
  <a href="UD5/images/ud5-2023-09-17-13-37-57.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-37-57.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Si se usa el constructor primario pero se requieren acciones sobre las propiedades, se debe usar un bloque <span class="negrita">init</span>.
  <a href="UD5/images/ud5-2023-09-17-13-38-59.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-38-59.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <h3>Funciones miembro</h3>
  
  <p>Pueden definirse funciones miembro (métodos) dentro de las clases.
  <a href="UD5/images/ud5-2023-09-17-13-39-48.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-39-48.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  La misma función definida con cuerpo:
  <a href="UD5/images/ud5-2023-09-17-13-40-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-40-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Si se sobreescribe una función de una clase padre, debe añadirse la palabra <span class="r-word">override</span> en la definición.
  <a href="UD5/images/ud5-2023-09-17-13-41-26.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-41-26.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Obviamente, puede combinarse todo lo anterior:
    <ul>
      <li>Constructor primario</li>
      <li>Bloque <code>init</code> para acciones del constructor primario</li>
      <li>Constructor secundario</li>
      <li>Getters y setters implícitos</li>
      <li>Sobrescritura de funciones heredadas</li>
    </ul>
  
    <section><pre><code class="language-kotlin">class Product(var name: String) {
    var price: Double = -1.0 // Precio por defecto

    init {
        name = name.uppercase() // Convierte el nombre a mayúsculas en la inicialización
    }

    constructor(name: String, price: Double) : this(name) {
        this.price = price // Asigna el precio recibido
    }

    override fun toString(): String {
        return "$name: $price €" // Representación en texto del producto
    }
}
</code></pre>
    </section><br><br>
    
  </p>
  
  <p>Para cambiar el tipo de acceso de las propiedades de la clase, basta con añadirlo antes de su declaración.
    <a href="UD5/images/ud5-2023-09-17-13-44-11.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-44-11.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </p>
  
  <p>Dado que los getters y setters son implícitos, tendrán por defecto la misma visibilidad que la propiedad, aunque puede hacerse el <em>setter</em> más restrictivo.
  
  Este comportamiento puede ser problemático si se desea encapsular las propiedades (una característica típica de la POO), ya que no habrá acceso directo cuando se usen los objetos.
  
  <section><pre><code class="language-kotlin">fun main(){
    val p1 = Producto(name = "Mesa")
    println(p1.name) //Sin acceso de lectura
    p1.name = "Silla" //Sin acceso de escritura
    println(p1.price) //Acceso de lectura permitido
    p1.price = 20.0   //Sin acceso de escritura
    println("Adiós mundo")
}

class Producto(private var name: String){
    var price: Double = 10.0
        get() = field //No imprescindible aquí
        private set

    init{
        name = name.uppercase()
    }

    constructor(name: String, price: Double): this(name){
        this.price = price
    }

    override fun toString(): String {
        return "$name: $price €"
    }
}
</code></pre>
  </section><br><br>
  </p>
  
  <p>Para resolverlo, pueden crearse métodos públicos que expongan propiedades privadas.
  
  <span class="negrita">Aunque esta solución va contra la filosofía de concisión de Kotlin.</span>
  <a href="UD5/images/ud5-2023-09-17-13-57-15.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-57-15.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  

  <p>Como ya se ha visto, una vez declarada una clase, su uso es similar a Java.

    El acceso a propiedades y funciones se realiza con notación punto:
    <a href="UD5/images/ud5-2023-09-17-13-59-24.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-13-59-24.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    </p>
    
    <h3>Clases enum en Kotlin</h3>
    <p>La <span class="negrita">enum class</span> permite definir un conjunto de constantes relacionadas.
    
    Aporta una forma segura de manejar estos valores sin riesgo de errores.
    <a href="UD5/images/ud5-2023-09-17-14-01-18.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-14-01-18.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    </p>
    
    <h3>Data class en Kotlin</h3>
    <p>Las data classes son una forma de modelar datos cuando el propósito de sus objetos es simplemente almacenar información.
    
    <span class="negrita">Son clases muy simples que contienen atributos.</span>
    
    Se usan para interactuar con otras clases o APIs externas.
    
    Para declararlas se usa la palabra clave <span class="r-word">data</span>.
    <a href="UD5/images/ud5-2023-09-17-14-03-01.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-14-03-01.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    </p>
    
    <p>Kotlin proporciona a las data classes un conjunto de <span class="negrita">funciones utilitarias</span> o características:
      <ul>
        <li><span class="negrita">equals()</span>: Compara dos objetos de la clase (compara contenido).</li>
        <li><span class="negrita">hashCode()</span>: Código hash (relacionado con equals).</li>
        <li><span class="negrita">copy()</span>: Crea una copia del objeto, propiedad a propiedad, pero con identidad distinta.</li>
        <li><span class="negrita">toString()</span>: Genera una cadena legible con los datos del objeto.</li>
        <li><span class="negrita">component1(), component2()</span>: Permiten obtener cada propiedad en su orden de declaración.</li>
      </ul>
    
      <a href="UD5/images/ud5-2023-09-17-14-06-34.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-14-06-34.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
    </p>
    
    <p>Las propiedades que no estén en el constructor primario no se benefician de estas características.
    Por ejemplo, en <span class="negrita">toString</span> solo aparecerán las del constructor primario.
    Con <span class="negrita">copy</span> pueden copiarse objetos completos y cambiar valores de propiedades durante la copia.
    <a href="UD5/images/ud5-2023-09-17-14-07-54.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-14-07-54.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    </p>
    
    <p>Los objetos de una data class pueden <span class="negrita">desestructurarse</span>, extrayendo los valores de sus propiedades a variables.
    
    Si un valor no es necesario, debe usarse el símbolo <span class="d-word">_</span>.
    
    Si los valores no deseados están al final, simplemente pueden omitirse.
    <a href="UD5/images/ud5-2023-09-17-14-08-48.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-14-08-48.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    </p>
    
    <h3>Inicialización con <code>lateinit</code> vs <code>lazy</code> (delegación)</h3>
    
    <p>Normalmente, las variables no nulas deben inicializarse en el constructor. 
      Sin embargo, no siempre es la mejor opción. 
      Si no queremos inicializar una propiedad en el constructor, tenemos dos alternativas: <span class="r-word">lateinit</span> y <span class="r-word">lazy</span>. 
      Con <span class="r-word">lateinit</span> logramos inicialización tardía, 
      informando al compilador de que la inicialización ocurrirá más adelante en el código. Si intentamos acceder a una variable antes de inicializarla, 
      obtendremos un error como <span class="negrita">Caused by:</span>:</p>
    
    <section class="marco-t err">
      <span class="icono error"> </span>  kotlin.UninitializedPropertyAccessException: lateinit property test has not been initialized.
    </section>
    <section class="marco-b">
        
    </section>
    
    <section><pre><code class="language-kotlin">lateinit var text: String
fun doSomething() {
   text = "un valor"
   println("La longitud es " + text.length)
   text = "Otro valor"
}
</code></pre>
    </section><br><br>
    
    <p>El modificador <span class="r-word">lateinit</span> solo puede usarse para variables mutables (<code>var</code>) declaradas en el cuerpo de la clase (no en el constructor primario) 
      y únicamente cuando esa variable no tenga <span class="negrita">getter</span> o <span class="negrita">setter</span> personalizados.</p>
    
    <p>Con <span class="r-word">lazy</span> conseguimos inicialización diferida: 
      una variable no se inicializa hasta que se usa por primera vez. 
      Se inicializará una sola vez y mantendrá su valor de ahí en adelante.</p>
    
      <section><pre><code class="language-kotlin">class Example {
   val name: String by lazy { "Rosa López" }

   fun printNameLengthIf(condition: Boolean) {
       if (condition) println("${name.length}") // La inicialización ocurre aquí
   }
}
</code></pre></section><br><br>
    
    <p>En el ejemplo anterior, tanto la primera como las posteriores lecturas de <code>name</code> devolverán "Rosa López".</p>
    
    <p>¿Cuándo usar cada opción?</p>
    <p><ul>
        <li><span class="d-word">lazy</span> solo puede usarse en variables inmutables <span class="d-word">val</span>, mientras que
          <span class="d-word">lateinit</span> solo puede aplicarse a variables mutables <span class="d-word">var</span> (no puede compilarse como <span class="d-word">final</span>).</li>
        <li>Una variable <span class="d-word">lateinit</span> puede inicializarse en cualquier punto del objeto donde sea visible.
          Si necesitamos que la variable se inicialice “desde fuera”, de forma no conocida de antemano (por ejemplo, inyección de dependencias), recurriremos a <span class="d-word">lateinit</span>.</li>
      </ul></p>
    

  
</section><!-- Fin sección Programación Orientada a Objetos-->


<!--*********************************************************Funciones de Extensión***********************************************************-->
<section class="apartado">
  <a id="sFuncionesExtension"></a>
  <h2>Funciones de extensión</h2>
  
  <p>Kotlin te permite <span class="negrita">extender la funcionalidad</span> de clases existentes, 
    ya sean clases del sistema o propias, sin usar herencia, incluso si la clase existente es final.</p>
  
  <p>
  <span class="negrita">Las funciones de extensión</span> se definen fuera de la definición de la clase, lo que significa que <span class="negrita">solo pueden usarse en el ámbito donde se definen</span>.
  </p>
  <p>
  Aunque la función de extensión se define fuera de la clase, se comporta como si estuviera definida dentro de la clase, funcionando como un método adicional. Puede acceder tanto a propiedades como a métodos de la clase, incluso si son privados.
  </p>
  
  <p>Un ejemplo de función de extensión ya se mostró en la sección de funciones:
  <a href="UD5/images/ud5-2023-09-17-19-13-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-13-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Estas funciones se definen como cualquier otra función, pero con el nombre de la clase a la que se extienden.
  
  Aquí tienes un ejemplo de una función de extensión para una clase existente:
  <a href="UD5/images/ud5-2023-09-17-19-14-20.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-14-20.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  Y una función de extensión para tu propia clase:
  <a href="UD5/images/ud5-2023-09-17-19-14-41.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-14-41.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Un caso de uso típico para las funciones de extensión ocurre con colecciones.
  
  Gracias a una función de extensión, puedes realizar una acción sobre cada elemento de la colección.
  <a href="UD5/images/ud5-2023-09-17-19-16-48.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-16-48.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <br>La salida sería:
  <a href="UD5/images/ud5-2023-09-17-19-17-16.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-17-16.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  
  <p>Una función de extensión no puede anular una función miembro.
  
  Una función de extensión sí puede sobrecargar una función miembro.
  
  Aunque no se muestre ningún error, si intentas anular una función miembro con una función de extensión, la función miembro siempre será la que se ejecute en tiempo de ejecución.
  <a href="UD5/images/ud5-2023-09-17-19-19-01.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-17-19-19-01.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  </p>
  

</section><!-- End section Funciones de Extensión-->


<!--*********************************************************Singleton***********************************************************-->
<section class="apartado">
  <a id="sSingleton"></a>
  <h2>Singleton</h2>

  <p>En Kotlin puedes crear un <span class="negrita">singleton</span>, que es un objeto único de su clase. Es decir, solo puede existir una instancia.</p>

  <section><pre><code class="language-kotlin">object Author{
    var name = "Carlos Tarazona"
    var company = "2DAM"
    var date = Date()

    override fun toString(): String {
        return """$name ($company)
            |$date""".trimMargin()
    }
}</code></pre>
  </section><br><br>

  <p>También puedes añadir <span class="negrita">funciones de extensión</span> al tipo del singleton, igual que con cualquier otra clase.
  <br>
  Si se declaran a nivel superior (top-level) en el archivo <span class="inline-file">.kt</span>, se añaden de la misma manera que para cualquier otra clase.</p>
</section><!-- Fin sección singleton-->


<!--*********************************************************Herencia***********************************************************-->
<section class="apartado">
  <a id="sHerencia"></a>
  <h2>Herencia</h2>

  <p>En <span class="negrita">Kotlin, todas las clases son final por defecto</span>, es decir, no permiten herencia salvo que se indique explícitamente.</p>
  <p>Para permitir que una clase actúe como superclase debes usar la palabra reservada <span class="negrita">open</span>.</p>

  <p>Si usas el constructor primario con getters y setters por defecto:</p>
  <a href="UD5/images/ud5-2023-09-17-19-31-58.png" target="_BLANK">
    <figure><img src="UD5/images/ud5-2023-09-17-19-31-58.png" /><br><figcaption></figcaption></figure>
  </a>
  <br>

  <p>Este código aporta:
    <ul>
      <li>La clase <span class="negrita">Product</span> con constructor, getters y setters.</li>
      <li>La clase <span class="negrita">Monitor</span>, cuyo constructor llama al de la clase padre e hereda sus getters y setters.</li>
    </ul>
  </p>

  <p>También se pueden añadir propiedades y métodos nuevos.
    <a href="UD5/images/ud5-2023-09-17-19-32-52.png" target="_BLANK">
      <figure><img src="UD5/images/ud5-2023-09-17-19-32-52.png" /><br><figcaption></figcaption></figure>
    </a>
    <br>
  </p>

  <p>En la clase hija, <span class="negrita">el constructor primario llama al constructor del padre</span>. Además, se puede definir un constructor secundario que delegue en el primario usando <span class="negrita">this</span>.</p>

  <h3>Clases abstractas</h3>

  <p>Para declarar una clase abstracta se usa la palabra reservada <span class="r-word">abstract</span> antes de <span class="r-word">class</span>.</p>
  <p>Las clases abstractas no pueden instanciarse.</p>

  <section><pre><code class="language-kotlin">abstract class Product(var name: String, var trademark: String) {
    abstract var price: Double // Propiedad abstracta que deben implementar las subclases
    abstract fun powerOn()     // Método abstracto a implementar
    abstract fun powerOff()    // Método abstracto a implementar

    fun information() {
        println("$name ($trademark): $price €")
    }
}

class Monitor(
    name: String,
    trademark: String,
    var color: String,
    override var price: Double
) : Product(name, trademark) {
    override fun powerOn()  { println("Encendido") }
    override fun powerOff() { println("Apagado")   }
}
</code></pre></section><br><br>

  <div class="tarea">
    <p>En este ejercicio crearemos un sistema de gestión de empleados usando POO con herencia, polimorfismo y sobrecarga de funciones y constructores. El sistema tendrá tres tipos: <span class="negrita">Empleado</span>, <span class="negrita">Gerente</span> y <span class="negrita">Técnico</span>. Cada tipo tendrá propiedades y comportamientos específicos.</p>

    <p>Definiciones de clases</p>

    <p>Crea una clase base Empleado con las siguientes propiedades y métodos:</p>
    <ul>
      <li><span class="negrita">Propiedades</span>: nombre (String), edad (Int), salario (Double).</li>
      <li><span class="negrita">Métodos</span>: calcularPagoMensual(), que calcula el pago mensual del empleado.</li>
    </ul>

    <p>Crea una clase Gerente que herede de Empleado con propiedades y métodos adicionales:</p>
    <ul>
      <li><span class="negrita">Propiedades</span>: departamento (String), bono (Double).</li>
      <li><span class="negrita">Métodos</span>: calcularPagoMensual(), que sobrescribe el método base para incluir el bono.</li>
    </ul>

    <p>Crea una clase Técnico que herede de Empleado con propiedades y métodos adicionales:</p>
    <ul>
      <li><span class="negrita">Propiedades</span>: nivel (String), horasExtra (Int).</li>
      <li><span class="negrita">Métodos</span>: calcularPagoMensual(), que sobrescribe el método base considerando las horas extra.</li>
    </ul>
  </div>

  <section class="marco-t inf">
    <span class="icono info"> </span> Solución:
  </section>
  <section class="marco-b">
    <section><pre><code class="language-kotlin">open class Empleado(val nombre: String, val edad: Int, val salario: Double) {
    open fun calcularPagoMensual(): Double = salario
}

class Gerente(
    nombre: String, edad: Int, salario: Double,
    val departamento: String, val bono: Double
) : Empleado(nombre, edad, salario) {
    override fun calcularPagoMensual(): Double = salario + bono
}

class Tecnico(
    nombre: String, edad: Int, salario: Double,
    val nivel: String, val horasExtra: Int
) : Empleado(nombre, edad, salario) {
    override fun calcularPagoMensual(): Double {
        val pagoHorasExtra = horasExtra * 10.0 // 10 €/hora extra (ejemplo)
        return salario + pagoHorasExtra
    }
}

fun main() {
    val empleado1 = Empleado("Juan Pérez", 30, 3000.0)
    val gerente1  = Gerente("Ana López", 35, 5000.0, "Ventas", 1000.0)
    val tecnico1  = Tecnico("Luis García", 25, 2500.0, "Junior", 20)

    val empleados = listOf(empleado1, gerente1, tecnico1)
    for (empleado in empleados) {
        println("Nombre: ${empleado.nombre}, Pago Mensual: ${empleado.calcularPagoMensual()}")
    }
}
</code></pre></section><br><br>

    <p>En el ejercicio se crea una jerarquía con la clase base Empleado y dos derivadas (Gerente y Técnico). Cada clase redefine <span class="negrita">calcularPagoMensual()</span> para adaptar el cálculo a su caso. En <span class="r-word">main()</span> se instancian y se calcula su pago mensual.</p>
  </section>

  <h3>Clases selladas (sealed)</h3>

  <p>Las clases selladas se usan para representar una jerarquía de clases que heredan de una misma clase padre y se declaran en el mismo archivo.</p>

  <p>Imaginemos una clase padre <span class="d-word">Figura</span> de la que extienden <span class="d-word">Triangulo</span>, <span class="d-word">Cuadrado</span> y <span class="d-word">Circulo</span>. Es una técnica típica para polimorfismo.</p>

  <section><pre><code class="language-kotlin">sealed class Figura {
   class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figura()
   class Cuadrado(val lado:Int) : Figura()
   class Circulo(val radio:Int) : Figura()
}
</code></pre></section><br><br>

  <p>Desde Kotlin 1.1 ya no es necesario que las subclases estén anidadas dentro de la clase padre (pero deben estar en el <span class="negrita">mismo archivo</span>):</p>

  <section><pre><code class="language-kotlin">sealed class Figura
class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figura()
class Cuadrado(val lado:Int) : Figura()
class Circulo(val radio:Int) : Figura()
</code></pre></section><br><br>

  <p>Una clase sellada es abstracta; al crear instancias debemos usar una de sus subclases. Al estar “cerrada”, el conjunto de subclases es conocido por el compilador.</p>

  <p>Gracias a eso, con una expresión <span class="r-word">when</span> podemos cubrir todos los casos sin <span class="r-word">else</span>:</p>

  <section><pre><code class="language-kotlin">val figura: Figura = Cuadrado(5)
val texto = when (figura) {
   is Triangulo -> "triángulo"
   is Cuadrado  -> "cuadrado"
   is Circulo   -> "círculo"
}
</code></pre></section><br><br>

  <p class="sub-section">Object</p>

  <p>Si queremos contemplar un estado “sin datos” o un tipo sin necesidad de almacenar estado, podemos añadir <span class="negrita">elementos object</span> a la sealed:</p>

  <section><pre><code class="language-kotlin">sealed class Figura
class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figura()
class Cuadrado(val lado:Int) : Figura()
class Circulo(val radio:Int) : Figura()
object Punto : Figura()
object SinDefinir : Figura()
</code></pre></section><br><br>

  <p>Y reflejarlo en el <span class="negrita">when</span>:</p>

  <section><pre><code class="language-kotlin">val texto = when(figura) {
   is Triangulo -> "triángulo"
   is Cuadrado  -> "cuadrado"
   is Circulo   -> "círculo"
   Punto        -> "punto"
   SinDefinir   -> "indefinida"
}
</code></pre></section><br><br>

  <p>Estos elementos no son clases; son singletons. Se crean la primera vez que se usan y se reutiliza la misma instancia (como en los enum).</p>

  <p>Ejemplo:</p>

  <section><pre><code class="language-kotlin">sealed class Figura(open var color:Int = 0) {
   abstract fun area(): Int

   class Cuadrado (override var color: Int, val lado: Int) : Figura(color) {
      override fun area() = lado * lado
   }

   object Punto : Figura(1) {
     override fun area() = 0
     init { println("Punto creado") }
   }
}
</code></pre></section><br><br>

  <section><pre><code class="language-kotlin">fun main(){
  val p1 = Figura.Punto
  val p2 = Figura.Punto
  val c  = Figura.Cuadrado(2, 8)

  p1.color = 3
  println("color c=${c.color}")
  println("color p2=${p2.color}")
}
</code></pre></section><br><br>

  <div class="tarea">
    <p>Con el código anterior:</p>
    <ol>
      <li>¿Qué salida produce?</li>
      <li>¿Por qué “Punto creado” aparece solo una vez?</li>
      <li>¿Por qué el color de <span class="cursiva">p2</span> pasa a ser 3 si lo cambiamos en <span class="cursiva">p1</span>?</li>
      <li>¿Por qué el color de <span class="cursiva">c</span> sigue siendo 2?</li>
      <li>¿Cómo haríamos para que cada punto tuviera su propio color?</li>
    </ol>
  </div>

  <section class="marco-t inf">
    <span class="icono info"> </span> Solución:
  </section>
  <section class="marco-b">
    <p>Las instancias <span class="d-word">object</span> son únicas (singleton). <span class="d-word">Punto</span> se crea una sola vez; tanto <span class="cursiva">p1</span> como <span class="cursiva">p2</span> referencian la misma instancia. En cambio, <span class="negrita">c</span> es un objeto independiente con sus propias propiedades.</p>
    <ol>
      <li>Se crea un único objeto <span class="d-word">Punto</span>.</li>
      <li>Porque los <span class="negrita">object</span> se inicializan una única vez (lazy + singleton).</li>
      <li>Porque <span class="cursiva">p1</span> y <span class="cursiva">p2</span> apuntan al mismo objeto.</li>
      <li>Porque <span class="cursiva">c</span> es otra instancia (de la clase <span class="d-word">Cuadrado</span>).</li>
      <li>Usando una <span class="negrita">clase</span> <span class="d-word">Point</span> (no un object) para que cada instancia tenga su propio estado.</li>
    </ol>
  </section>

  <p>El ejemplo anterior define tipos de figuras, pero las subclases no tienen por qué estar relacionadas semánticamente entre sí. Una clase sellada también sirve para representar un valor que puede ser de varios tipos no relacionados.</p>

  <p>Por ejemplo, una petición HTTP puede devolver una <span class="negrita">página</span> o un <span class="negrita">código de error</span>:</p>

  <section><pre><code class="language-kotlin">sealed class RespuestaHTTP
data class Correcta(val contenido: String) : RespuestaHTTP()
data class Error(val codigo: Int, val mensaje: String) : RespuestaHTTP()

fun getUrl(url: String): RespuestaHTTP {
   val valido = true // ...
   return if (valido) Correcta("Contenido…")
          else        Error(404, "No encontrado")
}

val respuesta = getUrl("/")
when (respuesta) {
   is Correcta -> println(respuesta.contenido)
   is Error    -> println(respuesta.mensaje)
}
</code></pre></section><br><br>

</section><!-- Fin sección Herencia-->


<!--*********************************************************Funciones de alcance***********************************************************-->
<section class="apartado">
  <a id="sFuncionesdealcance"></a>
  <h2>Funciones de alcance</h2>
  <p>Kotlin ofrece las llamadas <span class="negrita">funciones de alcance</span> que permiten ejecutar un bloque de código <span class="negrita">en el contexto del objeto que las invoca</span>.</p>
  <p>
  Al ejecutarse en el contexto del objeto llamante, ese objeto está disponible dentro del cuerpo de la función. Existen cinco funciones de alcance:
  <ul>
    <li>let</li>
    <li>run</li>
    <li>with</li>
    <li>apply</li>
    <li>also</li>
  </ul>
  </p>
  
  <p>Estas funciones devuelven un valor, aunque no es necesario capturarlo (almacenarlo) en ninguna variable.</p>
  
  <table>
      <thead>
          <tr>
              <td>Función</td>
              <td>Uso</td>
              <td>Contexto</td>
              <td>Devuelve</td>
          </tr>
      </thead>
      <tbody>
          <tr>
              <td>let</td>
              <td>Ejecutar un bloque de código asegurando que el objeto no es nulo.</td>
              <td>El propio objeto accesible con <span class="negrita">it</span></td>
              <td>Resultado de la última expresión</td>
          </tr>
          <tr>
              <td>apply</td>
              <td>Configuración del objeto.</td>
              <td>El propio objeto accesible con <span class="negrita">this</span></td>
              <td>El propio objeto</td>
          </tr>
          <tr>
              <td>run</td>
              <td>Configuración del objeto y ejecución de instrucciones sobre él.</td>
              <td>El propio objeto accesible con <span class="negrita">this</span></td>
              <td>Resultado de la última expresión</td>
          </tr>
          <tr>
              <td>run</td>
              <td>Ejecutar instrucciones cuando se requiere una expresión, usado sin llamarlo desde un objeto.</td>
              <td>-</td>
              <td>Resultado de la última expresión</td>
          </tr>
          <tr>
              <td>also</td>
              <td>Seguir realizando acciones sobre el objeto.</td>
              <td><span class="r-word">it</span></td>
              <td>El propio objeto</td>
          </tr>
          <tr>
              <td>with</td>
              <td>Agrupar llamadas a funciones sobre un objeto.</td>
              <td><span class="r-word">this</span></td>
              <td>Resultado de la última expresión</td>
          </tr>
      </tbody>
  </table>
  
  <p>Todas las funciones de alcance se usan con un bloque de llaves <span class="negrita">{ } (lambda).</span></p>
  
  <p>Android Studio muestra sugerencias de código para ayudar a entender cómo funciona cada una.</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-07-47.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-07-47.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <h3>let</h3>
  <p>
  <ul>
    <li><span class="negrita">Contexto</span>: el objeto desde el que se llama, accesible con <span class="negrita">it</span>.</li>
    <li><span class="negrita">Devuelve</span>: el resultado de la última expresión.</li>
  </ul>
  </p>
  
  <a href="UD5/images/ud5-2023-09-18-09-09-47.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-09-47.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>El uso de <span class="negrita">let</span> asegura que el objeto no es <span class="negrita">null</span> antes de ejecutar las instrucciones.</p>
  <a href="UD5/images/ud5-2023-09-18-09-10-40.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-10-40.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <p>En el <span class="negrita">caso de que el objeto product sea nulo, el bloque let no se ejecutará</span>.</p>
  
  <h3>run</h3>
  <p>Tiene dos usos:</p>
  <ol>
    <li>Llamado desde un objeto como let, pero no comprueba si la variable es nula.
      <ul>
        <li><span class="negrita">Contexto</span>: el objeto desde el que se llama, accesible con <span class="negrita">this</span>. No es necesario usar explícitamente <span class="negrita">this</span> para acceder a propiedades.</li>
        <li><span class="negrita">Devuelve</span>: el resultado de la última expresión.</li>
      </ul>
      <a href="UD5/images/ud5-2023-09-18-09-14-08.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-14-08.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
    </li>
    <li>Llamado sin usar un objeto.
      <ul>
        <li><span class="negrita">Contexto</span>: sin contexto.</li>
        <li><span class="negrita">Devuelve</span>: el resultado de la última expresión.</li>
      </ul>
      <a href="UD5/images/ud5-2023-09-18-09-15-08.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-15-08.png" /><br><figcaption></figcaption></figure></a>
      <br>
      
    </li>
  </ol>
  
  <h3>also</h3>
  <p>Permite realizar acciones adicionales (also = además) sobre el objeto llamante.
    <ul>
      <li><span class="negrita">Contexto</span>: el objeto desde el que se llama, accesible con <span class="r-word">it</span>.</li>
      <li><span class="negrita">Devuelve</span>: el propio objeto (automáticamente).</li>
    </ul>
  <a href="UD5/images/ud5-2023-09-18-09-25-36.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-25-36.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <h3>apply</h3>
  <p>Se usa para configurar (asignar valores a) un objeto.
    <ul>
      <li><span class="negrita">Contexto</span>: el objeto desde el que se llama, accesible con <span class="r-word">this</span>.</li>
      <li><span class="negrita">Devuelve</span>: el propio objeto (automáticamente).</li>
    </ul>
  <a href="UD5/images/ud5-2023-09-18-09-27-00.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-27-00.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <h3>with</h3>
  <p>Permite agrupar acciones sobre un objeto.
    <ul>
      <li><span class="negrita">Contexto</span>: el objeto desde el que se llama, accesible con <span class="r-word">this</span>.</li>
      <li><span class="negrita">Devuelve</span>: el resultado de la última expresión.</li>
    </ul>
  <a href="UD5/images/ud5-2023-09-18-09-28-10.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-28-10.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  <a href="UD5/images/ud5-2023-09-18-09-29-03.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-29-03.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
</section><!-- End section Funciones de alcance-->

<!--*********************************************************Funciones Lambda***********************************************************-->
<section class="apartado">
  <a id="sFuncionesLambda"></a>
  <h2>Funciones lambda</h2>
  
  <p>Generalmente, una función debe declararse y recibir un identificador para poder usarse:</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-31-08.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-31-08.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Las funciones lambda, también llamadas funciones anónimas o funciones flecha, son funciones que <span class="negrita">no se declaran</span> (no tienen identificador) y <span class="negrita">se usan como expresiones</span>.</p>
  
  <p>Las lambdas se escriben <span class="negrita">entre llaves { }</span>, pueden tener parámetros o no y deben tener un cuerpo. El <span class="negrita">resultado de la última instrucción en una lambda se devuelve (SIN RETURN)</span>. Si la función contiene múltiples instrucciones, Android Studio mostrará sugerencias de código.</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-33-22.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-33-22.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Si las sugerencias de código no aparecen en Android Studio, pueden activarse desde File -> Settings (CTRL+ALT+S):</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-35-18.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-35-18.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Si una lambda tiene parámetros, se separan del cuerpo usando el símbolo <span class="r-word">-></span>, de ahí el nombre "funciones flecha".</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-36-08.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-36-08.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>En las lambdas anteriores, Kotlin infiere los tipos de datos. También se pueden indicar tipos explícitos:</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-37-56.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-37-56.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Si la lambda tiene solo un parámetro, puede omitirse y usarse <span class="negrita">it</span>:</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-37-19.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-37-19.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Las lambdas se usan como expresiones, por lo que deben asignarse a algún elemento. Si una lambda se asigna a una variable, se comporta igual que una función normal. No obstante, esto no aporta nueva funcionalidad por sí mismo.</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-42-30.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-42-30.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Las lambdas <span class="negrita">pueden pasarse como parámetros a otras funciones</span>, lo que introduce funcionalidades ampliamente usadas en lenguajes y frameworks modernos. Pasar lambdas como parámetros permite:</p>
  
  <ul>
    <li>Crear funciones callback.</li>
    <li>Devolver respuestas diferentes desde una función.</li>
    <li>Permitir que el desarrollador introduzca lógica personalizada.</li>
  </ul>
  
  <p>Sintaxis para pasar una lambda como parámetro a una función:</p>
  
  <section><pre><code class="language-kotlin">fun nameOfFun(parameter1: Type, lambdaName: (Type1, Type2…) -> TypeReturn) { … }</code></pre></section>
  
  <br>
  
  <p>Si la lambda no recibe parámetros:</p>
  
  <section><pre><code class="language-kotlin">fun nameOfFun(parameter1: Type, lambdaName: () -> TypeReturn) { … }</code></pre></section>
  
  <br>
  
  <p>Si la lambda no devuelve nada:</p>
  
  <section><pre><code class="language-kotlin">fun nameOfFun(parameter1: Type, lambdaName: (Type1, Type2…) -> Unit) { … }</code></pre></section>
  
  <br>
  
  <p>Si la lambda no recibe parámetros ni devuelve nada:</p>
  
  <section><pre><code class="language-kotlin">fun nameOfFun(parameter1: Type, lambdaName: () -> Unit) { … }</code></pre></section>
  
  <br>
  
  <h3>Crear funciones callback</h3>
  
  <p>Las funciones callback garantizan que un conjunto de instrucciones se ejecute después de una operación específica, típico en la ejecución <span class="negrita">asíncrona</span> (por ejemplo, hilos). En el siguiente ejemplo, funciones sobrecargadas reciben una lambda que se ejecuta al final del cuerpo de la función <span class="cursiva">doLogin</span>:</p>
  
  <a href="UD5/images/ud5-2023-09-18-09-45-54.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-09-45-54.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>La función <span class="cursiva">doLogin</span> anterior puede invocarse como se muestra:</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-04-58.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-04-58.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Si la lambda es el <span class="negrita">último parámetro</span>, puede colocarse fuera de los paréntesis:</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-05-57.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-05-57.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Si la lambda es el <span class="negrita">único parámetro</span>, pueden omitirse los paréntesis en la llamada:</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-07-29.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-07-29.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <h3>Devolver respuestas diferentes desde una función</h3>
  
  <p>Una función puede aceptar múltiples parámetros, y cualquiera o todos ellos pueden ser funciones lambda. Esto permite ejecutar diferentes lambdas según sea necesario:</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-27-11.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-27-11.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Un posible uso con su salida se muestra a continuación:</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-29-25.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-29-25.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <p>Dependiendo del cuerpo de la lambda, una o más de estas funciones pueden ejecutarse. En el ejemplo anterior, tanto las funciones <span class="d-word">correct</span> como <span class="d-word">error</span> devuelven resultado, pero solo la última llamada a las lambdas tendrá efecto en la asignación final.</p>
  
  <h3>Permitir que los desarrolladores introduzcan lógica personalizada</h3>
  
  <p>Si la función <span class="d-word">calculate</span> forma parte de una librería externa, usar lambdas permite que los desarrolladores incorporen lógica personalizada dentro de esa función.</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-35-04.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-35-04.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  
  <h3>Usos previos de lambdas</h3>
  
  <ul>
    <li>En la creación de arrays:</li>
    <a href="UD5/images/ud5-2023-09-18-10-36-49.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-36-49.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <li>En funciones como forEach, filter y map:</li>
    <a href="UD5/images/ud5-2023-09-18-10-37-31.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-37-31.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
    <li>En funciones de alcance:</li>
    <a href="UD5/images/ud5-2023-09-18-10-37-57.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-37-57.png" /><br><figcaption></figcaption></figure></a>
    <br>
    
  </ul>
  
  <h3>Lambdas en el desarrollo Android</h3>
  
  <p>Las lambdas son fundamentales en el desarrollo de aplicaciones Android, especialmente al usar <span class="negrita">Jetpack Compose</span>, como se verá en el siguiente módulo.</p>
  
  <a href="UD5/images/ud5-2023-09-18-10-39-22.png" target="_BLANK"><figure><img src="UD5/images/ud5-2023-09-18-10-39-22.png" /><br><figcaption></figcaption></figure></a>
  <br>
  
  

</section><!-- End section Funciones Lambda-->


<!--*********************************************************Ejercicios Interactivos en Kotlin***********************************************************-->
<section class="apartado">
<a id="sEjerciciosInteractivos"></a>
<h2>Interactive exercises en Kotlin</h2>
<div class="" style="width: 100%;">
  <p>Do this exercises from <a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> </p> <br>
  <iframe src="https://play.kotlinlang.org/koans/Introduction/Hello,%20world!/Task.kt" frameborder="1" style="width: 100%;height: 1500px;"></iframe>
</div>


</section><!-- End section Ejercicios Interactivos en Kotlin-->

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
  <script src="../script/prism.js"></script>
</body>
</html>
