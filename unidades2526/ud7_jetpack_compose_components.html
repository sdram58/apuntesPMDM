<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Componentes Jetpack Compose</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">
    <div class="fila">
      <a href="#sIntroduccion" title="1. Introducción">1. Introducción</a>
      <a href="#sOrganizandoCodigo" title="2. Organización del código">2. Organización del código</a>
      <a href="#sComponentesdeJetpackCompose" title="3.- Componentes de Jetpack Compose">3.- Componentes de Jetpack
        Compose</a>
    </div>

    <div class="fila">
      <a href="#sMaterial3" title="4.- Material 3">4.- Material 3</a>
      <a href="#sComponentesTextyBasicText" title="5.- Componentes Text y BasicText">5.- Componentes Text y
        BasicText</a>
      <a href="#sModifier" title="6.- Modifier">6.- Modifier</a>
    </div>
    <div class="fila">
      <a href="#sComponenteButton" title="7.- Componente Button">7.- Componente Button</a>
      <a href="#sComponentespropios" title="8.- Componentes propios">8.- Componentes propios</a>
      <a href="#sComponenteSpacer" title="9.- Componente Spacer">9.- Componente Spacer</a>
    </div>
    <div class="fila">
      <a href="#sImagenes" title="10.- Imágenes">10.- Imágenes</a>
      <a href="#sComponenteBadge" title="11.- Componente Badge">11.- Componente Badge</a>
      <a href="#sComponentesDivider" title="12.- Componentes Divider">12.- Componentes Divider</a>
    </div>
    <div class="fila">
      <a href="#sConceptos" title="13.- Conceptos">13.- Conceptos</a>
      <a href="#sComponentesparaintroducirinformacion" title="14.- Componentes para introducir información">14.-
        Componentes para introducir información</a>
      <a href="#sStateHoisting" title="15.- Elevación del estado">15.- Elevación del estado</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSwitch" title="16.- Componente Switch">16.- Componente Switch</a>
      <a href="#sComponenteCheckBox" title="17.- Componente Checkbox">17.- Componente Checkbox</a>
      <a href="#sComponenteRadioButton" title="18.- Componente Radio Button">18.- Componente Radio Button</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSlider" title="19.- Componente Slider">19.- Componente Slider</a>
      <a href="#sComponenteExposedDropdownMenu" title="20.- Componente ExposedDropdownMenu">20.- Componente
        ExposedDropdownMenu</a>
      <a href="#sComponenteDatePicker" title="21.- Componente Date Picker">21.- Componente Date Picker</a>
    </div>
    <div class="fila">
      <a href="#sComponentesChips" title="22.- Componentes Chip">22.- Componentes Chip</a>
      <a href="#sComponenteIconButton" title="23.- Componente IconButton">23.- Componente IconButton</a>
      <a href="#sComponenteProgressIndicator" title="24.- Componente ProgressIndicator">24.- Componente
        ProgressIndicator</a>
    </div>
    <div class="fila">
      <a href="#sComponentesSearchBar" title="25.- Componentes SearchBar">25.- Componentes SearchBar</a>
      <a href="#sComponenteAlertDialog" title="26.- Componente AlertDialog">26.- Componente AlertDialog</a>
      <a href="#sLayout" title="27.- Diseño (Layout)" class="">27.- Diseño (Layout)</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSurface" title="28.- Componente Surface">28.- Componente Surface</a>
      <a href="#sComponenteCard" title="29.- Componente Card">29.- Componente Card</a>
      <a href="#sComponenteBox" title="30.- Componente Box">30.- Componente Box</a>
    </div>
    <div class="fila">
      <a href="#sComponentesColumnyRow" title="31.- Componentes Column y Row">31.- Componentes Column y Row</a>
      <a href="#sScroll" title="32.- Scroll">32.- Scroll</a>
      <a href="#sComponenteListItem" title="33.- Componente ListItem">33.- Componente ListItem</a>
    </div>
    <div class="fila">
      <a href="#sComponenteScaffold" title="34.- Componente Scaffold">34.- Componente Scaffold</a>
      <a href="#sComponenteConstraintLayout" title="35.- Componente ConstraintLayout">35.- Componente
        ConstraintLayout</a>
      <a href="#sComponentesModal" title="36.- Componentes Modal">36.- Componentes Modal</a>
    </div>
    <div class="fila">
      <a href="#sComponentesPager" title="37.- Componentes Pager">37.- Componentes Pager</a>
      <a href="#sComponentesTooltipBox" title="38.- Componentes TooltipBox">38.- Componentes TooltipBox</a>
      <a href="" class="relleno"></a>
    </div>
  </nav> <!-- BTM_MENU-->

  <h1>U7.- Componentes de Jetpack Compose</h1>

  <div class="main-menu">
    <div class="fila">
      <a href="#sIntroduccion" title="1. Introducción">1. Introducción</a>
      <a href="#sOrganizandoCodigo" title="2. Organización del código">2. Organización del código</a>
      <a href="#sComponentesdeJetpackCompose" title="3.- Componentes de Jetpack Compose">3.- Componentes de Jetpack
        Compose</a>
    </div>

    <div class="fila">
      <a href="#sMaterial3" title="4.- Material 3">4.- Material 3</a>
      <a href="#sComponentesTextyBasicText" title="5.- Componentes Text y BasicText">5.- Componentes Text y
        BasicText</a>
      <a href="#sModifier" title="6.- Modifier">6.- Modifier</a>
    </div>
    <div class="fila">
      <a href="#sComponenteButton" title="7.- Componente Button">7.- Componente Button</a>
      <a href="#sComponentespropios" title="8.- Componentes propios">8.- Componentes propios</a>
      <a href="#sComponenteSpacer" title="9.- Componente Spacer">9.- Componente Spacer</a>
    </div>
    <div class="fila">
      <a href="#sImagenes" title="10.- Imágenes">10.- Imágenes</a>
      <a href="#sComponenteBadge" title="11.- Componente Badge">11.- Componente Badge</a>
      <a href="#sComponentesDivider" title="12.- Componentes Divider">12.- Componentes Divider</a>
    </div>
    <div class="fila">
      <a href="#sConceptos" title="13.- Conceptos">13.- Conceptos</a>
      <a href="#sComponentesparaintroducirinformacion" title="14.- Componentes para introducir información">14.-
        Componentes para introducir información</a>
      <a href="#sStateHoisting" title="15.- Elevación del estado">15.- Elevación del estado</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSwitch" title="16.- Componente Switch">16.- Componente Switch</a>
      <a href="#sComponenteCheckBox" title="17.- Componente Checkbox">17.- Componente Checkbox</a>
      <a href="#sComponenteRadioButton" title="18.- Componente Radio Button">18.- Componente Radio Button</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSlider" title="19.- Componente Slider">19.- Componente Slider</a>
      <a href="#sComponenteExposedDropdownMenu" title="20.- Componente ExposedDropdownMenu">20.- Componente
        ExposedDropdownMenu</a>
      <a href="#sComponenteDatePicker" title="21.- Componente Date Picker">21.- Componente Date Picker</a>
    </div>
    <div class="fila">
      <a href="#sComponentesChips" title="22.- Componentes Chip">22.- Componentes Chip</a>
      <a href="#sComponenteIconButton" title="23.- Componente IconButton">23.- Componente IconButton</a>
      <a href="#sComponenteProgressIndicator" title="24.- Componente ProgressIndicator">24.- Componente
        ProgressIndicator</a>
    </div>
    <div class="fila">
      <a href="#sComponentesSearchBar" title="25.- Componentes SearchBar">25.- Componentes SearchBar</a>
      <a href="#sComponenteAlertDialog" title="26.- Componente AlertDialog">26.- Componente AlertDialog</a>
      <a href="#sLayout" title="27.- Diseño (Layout)" class="">27.- Diseño (Layout)</a>
    </div>
    <div class="fila">
      <a href="#sComponenteSurface" title="28.- Componente Surface">28.- Componente Surface</a>
      <a href="#sComponenteCard" title="29.- Componente Card">29.- Componente Card</a>
      <a href="#sComponenteBox" title="30.- Componente Box">30.- Componente Box</a>
    </div>
    <div class="fila">
      <a href="#sComponentesColumnyRow" title="31.- Componentes Column y Row">31.- Componentes Column y Row</a>
      <a href="#sScroll" title="32.- Scroll">32.- Scroll</a>
      <a href="#sComponenteListItem" title="33.- Componente ListItem">33.- Componente ListItem</a>
    </div>
    <div class="fila">
      <a href="#sComponenteScaffold" title="34.- Componente Scaffold">34.- Componente Scaffold</a>
      <a href="#sComponenteConstraintLayout" title="35.- Componente ConstraintLayout">35.- Componente
        ConstraintLayout</a>
      <a href="#sComponentesModal" title="36.- Componentes Modal">36.- Componentes Modal</a>
    </div>
    <div class="fila">
      <a href="#sComponentesPager" title="37.- Componentes Pager">37.- Componentes Pager</a>
      <a href="#sComponentesTooltipBox" title="38.- Componentes TooltipBox">38.- Componentes TooltipBox</a>
      <a href="" class="relleno"></a>
    </div>
  </div>

  <!--*********************************************************Introduction***********************************************************-->
  <section class="apartado">
    <a name="sIntroduccion"></a>
    <h2>Introducción</h2>

    <p>
      En esta unidad, estudiaremos los diferentes componentes que ofrece <span class="negrita">Jetpack Compose</span>
      para diseñar interfaces.
    </p>
    <p>Veremos componentes de <span class="negrita">presentación e interacción</span> como texto, imágenes, diálogos,
      etc.</p>

    <p>También veremos componentes de <span class="negrita">layout</span> que permiten organizar elementos de la
      interfaz, como columnas, rejillas, tarjetas, etc.</p>

    <p>En la documentación oficial, puedes encontrar:
    <ul>
      <li>Su documentación y uso: <a class="enlace" target="_blank"
          href="https://developer.android.com/develop/ui/compose/components">Developer Android</a></li>
      <li>Guías de estilo: <a class="enlace" target="_blank" href="https://m3.material.io/components">Material
          Design</a></li>
    </ul>
    </p>

    <h3>Aviso</h3>
    <p>Dada la gran cantidad de componentes de Jetpack Compose y el rango de opciones de cada uno, es imposible cubrir
      todo en clase.</p>
    <p>Por lo tanto, en clase solo explicaremos su funcionalidad y los puntos más importantes.</p>
    <p>Es responsabilidad de cada persona estudiar cada componente y realizar las pruebas que considere necesarias.
    </p>
    <p>Por supuesto, después de estudiar cada componente, podrás preguntar dudas en clase y/o en el foro de Aules.</p>

    <h3>Ejemplo de Switch</h3>
    <a href="UD7/images/ud_7-2025-01-06-23-06-54.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-06-54.png" /><br>
        <figcaption>Componentes</figcaption>
      </figure>
    </a>
    <br>
    <a href="UD7/images/ud_7-2025-01-06-23-07-27.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-07-27.png" /><br>
        <figcaption>Switch</figcaption>
      </figure>
    </a>
    <br>
    <a href="UD7/images/ud_7-2025-01-06-23-07-54.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-07-54.png" /><br>
        <figcaption>Referencia</figcaption>
      </figure>
    </a>
    <br>
    <a href="UD7/images/ud_7-2025-01-06-23-08-12.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-08-12.png" /><br>
        <figcaption>Material</figcaption>
      </figure>
    </a>
    <br>

    <p>La última versión de Jetpack Compose utiliza Material Design 3. Material Design es un estilo de diseño de
      interfaces desarrollado por Google.</p>
    <a href="UD7/images/ud_7-2025-01-06-23-09-00.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-09-00.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>La web de <a class="enlace" target="_blank" href="https://m3.material.io/components">Material Design 3</a>
      ofrece información muy importante sobre cómo usar los componentes en la sección <span
        class="negrita">Guidelines</span>:</p>
    <a href="UD7/images/ud_7-2025-01-06-23-10-51.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-10-51.png" /><br>
        <figcaption>Guías</figcaption>
      </figure>
    </a>
    <br>
  </section><!-- End section Introducción-->


  <!--*********************************************************Organizando el código***********************************************************-->
  <section class="apartado">
    <a name="sOrganizandoCodigo"></a>
    <h2>Organizando el código</h2>

    <p>
      Antes de profundizar en los componentes de <span class="negrita">Jetpack Compose</span>, es importante mantener
      organizado el código
      de la aplicación. Por ello, ten en cuenta lo siguiente:
    </p>
    <ul>
      <li>Puedes crear tantos archivos como necesites.</li>
      <li>Si la aplicación tiene varias pantallas, cada una debe tener su código de interfaz en un archivo separado.
      </li>
      <li>El archivo que contiene una clase que extiende Activity no debe incluir componentes de UI.</li>
      <li>Debes crear un componente base para la aplicación que pueda usarse desde cualquier sitio.</li>
      <li>Todos los archivos de UI deben colocarse dentro de la carpeta <span class="inline-folder">ui</span>.</li>
      <li>Si varios componentes pertenecen a la misma sección de pantalla, debes crear un componente que los agrupe.
      </li>
      <li>Cuando un componente se repite con el mismo estilo, debes crear un componente personalizado que lo extienda.
      </li>
    </ul>

    <p>
      Para ilustrar esto, modificaremos el proyecto <span class="negrita">Click Counter</span> de la U6
      siguiendo todos estos principios. Además, indicaremos dónde debe colocarse cada elemento estudiado.
    </p>

    <p>
      El primer paso es crear un nuevo elemento <span class="r-word">Composable</span> llamado
      <span class="d-word">ClickCounterContent</span>:
      Clic derecho sobre la carpeta <span class="inline-file">ui</span>
      <span class="negrita">&rarr; New &rarr; Kotlin Class/File</span>.
    </p>

    <a href="UD7/images/ud7-2023-10-20-16-14-32.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud7-2023-10-20-16-14-32.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>
      Especifica el nombre: <span class="d-word">ClickCounterContent</span>, selecciona <span
        class="negrita">File</span> y pulsa Enter.
    </p>

    <a href="UD7/images/ud_7-2025-01-06-23-27-38.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-27-38.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>
      Dentro del archivo ClickCounterContent, incluye lo siguiente:
    </p>

    <!-- Código Kotlin respetado -->
    <section>
      <pre><code class="language-kotlin">@Composable
fun ClickCounterContent(content: @Composable (modifier: Modifier) -> Unit) {
    ClickCounterEnhancedTheme {
        Scaffold(
            modifier = Modifier.fillMaxSize()
        ) { innerPadding ->
            content(Modifier.padding(innerPadding))
        }
    }
}
</code></pre>
    </section><br><br>

    <p>
      Después, este componente debe usarse desde la función <span class="r-word">onCreate</span> del
      archivo <span class="d-word">MainActivity</span>:
    </p>

    <p>
      Así, siempre que crees una pantalla nueva o quieras previsualizar un componente, usarás
      <span class="d-word">ClickCounterContent</span> y el estilo de la app se mantendrá.
    </p>

    <p>
      Ahora toca renombrar la función <span class="negrita">Content</span> a <span class="d-word">ClickCounter</span>.
      Debes cambiar también sus llamadas tanto en <span class="negrita">onCreate</span> como en la preview.
    </p>

    <section>
      <pre><code class="language-kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            ClickCounterContent { modifier ->
                ClickCounter(modifier)
            }
        }
    }
}
</code></pre>
    </section><br><br>

    <p>
      Finalmente, moveremos la función <span class="d-word">ClickCounter</span> a un archivo independiente.
    </p>

    <p>
      Clic derecho en la carpeta <span class="cursiva">ui</span> &rarr; <span class="cursiva">New &rarr;
        Package</span>.
    </p>

    <figure>
      <img src="UD7/images/ud7-2023-10-22-23-23-28.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Introduce el nombre del paquete: <span class="negrita">screens</span> y pulsa Enter.</p>

    <p>
      Clic derecho sobre la nueva carpeta <span class="cursiva">screens</span> &rarr; <span class="cursiva">New &rarr;
        Kotlin Class/File</span>:
    </p>

    <figure>
      <img src="UD7/images/ud7-2023-10-22-23-24-32.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>
      Introduce el nombre del archivo: <span class="d-word">ClickCounter</span>, selecciona <span
        class="negrita">File</span> y pulsa Enter.
    </p>

    <figure>
      <img src="UD7/images/ud7-2023-10-22-23-24-48.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>
      La función <span class="d-word">ClickCounter</span> y la preview <span class="d-word">ClickCounterPreview</span>
      se eliminan de <span class="inline-file">MainActivity.kt</span> y se colocan en el archivo <span
        class="inline-file">ClickCounter</span>:
    </p>

    <!-- CODE BLOCK respetado -->
    <section class="marco-t file-">
      <span class="icono file"> </span> <span class="negrita">ClickCounter.kt</span>
    </section>
    <section class="marco-b">
      <section>
        <pre><code class="language-kotlin">@Composable
fun ClickCounter() {
    var times by rememberSaveable { mutableStateOf(0) }
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = stringResource(
                R.string.counter_text,
                times
            ),
            fontSize = 25.sp
        )
        Spacer(modifier = Modifier.height(20.dp))
        Button(onClick = {
            times++
            Log.i(
                BUTTON_CLICK,
                "Button pressed. Value of times: $times"
            )
        }) {
            Text(
                text = stringResource(id = R.string.clickme),
                fontSize = 30.sp,
                modifier = Modifier.padding(16.dp),
            )
        }
        Spacer(modifier = Modifier.height(20.dp))
        Button(
            onClick = {
                times = 0
                Log.i(
                    BUTTON_CLICK,
                    "RESET pressed"
                )
            },
            shape = RectangleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = Color.White,
                contentColor = Color.Black
            ),
            border = BorderStroke(
                2.dp,
                Color.Red
            ),
            enabled = times != 0
        ) {
            Text(
                text = stringResource(id = R.string.reset),
                fontSize = 15.sp,
                modifier = Modifier.padding(2.dp),
            )
        }
    }
}
</code></pre>
      </section>
    </section>

    <p>
      De esta manera, la estructura del proyecto queda más organizada.
    </p>

    <p>
      Si una pantalla constará de varios archivos, se recomienda crear un <span class="negrita">nuevo paquete</span>
      con el nombre de la pantalla dentro de <span class="negrita">screens</span>.
    </p>

    <p>
      Si algunos componentes se comparten entre pantallas, crea un paquete llamado <span class="negrita">common</span>,
      <span class="negrita">share</span> o <span class="negrita">partials</span> y
      colócalos ahí.
    </p>

    <a href="UD7/images/ud7-2023-10-22-23-29-40.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud7-2023-10-22-23-29-40.png" /><br>
        <figcaption>Estructura de proyecto de ejemplo.</figcaption>
      </figure>
    </a>
    <br>

    <section class="marco-t inf">
      <span class="icono info"> </span> Es importante mantener una organización consistente.
    </section>
    <section class="marco-b">
    </section>

  </section>


  <!--*********************************************************Componentes de Jetpack Compose***********************************************************-->
  <section class="apartado">
    <a name="sComponentesdeJetpackCompose"></a>
    <h2>Componentes de Jetpack Compose</h2>

    <p>Los componentes de Jetpack Compose pueden clasificarse informalmente en dos tipos:</p>

    <table>
      <thead>
        <th colspan="2">
          <p>
            <span class="subrayado">Layout</span>
          </p>
          <p>Permiten organizar los elementos de la interfaz gráfica</p>
        </th>
      </thead>
      <tbody>
        <tr>
          <td>Box</td>
          <td>Surface</td>
        </tr>
        <tr>
          <td>Column</td>
          <td>Row</td>
        </tr>
        <tr>
          <td>Card</td>
          <td>ConstraintLayout</td>
        </tr>
        <tr>
          <td>Scaffod</td>
          <td>TopAppBar</td>
        </tr>
        <tr>
          <td>BottomBar</td>
          <td>ModalDrawer</td>
        </tr>
        <tr>
          <td>LazyColumn</td>
          <td>LazyRow</td>
        </tr>
        <tr>
          <td>LazyVerticalGrid</td>
          <td>LazyHorizontalGrid</td>
        </tr>
        <tr>
          <td>LazyVerticalStaggeredGrid</td>
          <td>LazyHorizontalStaggeredGrid</td>
        </tr>
        <tr>
          <td colspan="2">...</td>
        </tr>
      </tbody>
    </table>
    <br><br>

    <table>
      <thead>
        <th colspan="2">
          <p>
            <span class="subrayado">Presentación de información</span>
          </p>
          <p>Permiten mostrar información al usuario.<br>
            El usuario puede interactuar con ellos.
          </p>
        </th>
      </thead>
      <tbody>
        <tr>
          <td>Text</td>
          <td>TextField</td>
        </tr>
        <tr>
          <td>Button</td>
          <td>Image</td>
        </tr>
        <tr>
          <td>Spacer</td>
          <td>Switch</td>
        </tr>
        <tr>
          <td>Slider</td>
          <td>CheckBox</td>
        </tr>
        <tr>
          <td>RadioButton</td>
          <td>ElevatedButton</td>
        </tr>
        <tr>
          <td>Icon</td>
          <td>IconButton</td>
        </tr>
        <tr>
          <td>SnackBar</td>
          <td>BadgedBox</td>
        </tr>
        <tr>
          <td>Slider</td>
          <td>FloatingActionButton</td>
        </tr>
        <tr>
          <td colspan="2">...</td>
        </tr>
      </tbody>
    </table>
    <br>

    <p>En la unidad anterior ya se utilizaron algunos componentes: <span class="cursiva">Column, Row, Text, Button,
        Spacer, Surface</span>.</p>

    <p><span class="negrita">Toda la interfaz</span> se construirá con:</p>
    <ul>
      <li><span class="negrita">Componentes ofrecidos por Jetpack Compose</span></li>
      <li><span class="negrita">Componentes personalizados</span> que amplían o agrupan los componentes existentes.
      </li>
    </ul>

    <p>Los componentes de Jetpack Compose son <span class="negrita">funciones</span> etiquetadas con <span
        class="r-word">@Composable</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-22-23-47-00.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Para crear <span class="negrita">tu propio componente</span>, debes crear una función etiquetada con <span
        class="d-word">@Composable</span>.</p>

    <p>Además, la documentación indica:</p>
    <ul>
      <li>Si la función <span class="negrita">@Composable</span> no devuelve nada, su nombre debe empezar por
        mayúscula.</li>
      <li>Si devuelve algo, debe empezar por minúscula.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-22-23-49-09.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section>


  <!--*********************************************************Material 3***********************************************************-->
  <section class="apartado">
    <a name="sMaterial3"></a>
    <h2>Material 3</h2>
    <p>La última versión de Jetpack Compose utiliza Material Design 3. Material Design es un estilo de diseño de
      interfaces creado por Google.
    </p>

    <p>Todos los componentes de Jetpack Compose pueden consultarse en la <a class="enlace" target="_blank"
        href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary">documentación
        oficial</a>
      con un ejemplo visual y un enlace a <a class="enlace" target="_blank"
        href="https://m3.material.io/components">Material
        Design 3</a>:
      para que puedas ver cómo usar cada componente y las guías de estilo:</p>

    <figure><img src="UD7/images/ud7-2023-10-22-23-53-55.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>La web de <a class="enlace" target="_blank" href="https://m3.material.io/components">Material Design 3</a>
      ofrece
      información muy importante
      sobre cómo usar los componentes en la sección <span class="negrita">Guidelines</span> (guías de estilo):</p>

    <figure><img src="UD7/images/ud7-2023-10-22-23-56-06.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>ExperimentalMaterial3Api</h3>

    <p>A veces, algunos componentes de Jetpack Compose están en fase experimental, pero pueden utilizarse sin
      problema.</p>
    <p>En estos casos, Android Studio solicitará añadir esta anotación.</p>
    <p>En la ayuda contextual de Android Studio podrás especificarla de la siguiente manera:
    <ul>
      <li>Al principio del componente que contiene el elemento experimental.</li>
      <li>En todo el archivo actual.</li>
      <li>O bien puedes propagarla para que el componente padre también deba especificarla.</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-26-13-25-42.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Material 3-->

  <!--*********************************************************Componentes Text y BasicText***********************************************************-->
  <section class="apartado">
    <a name="sComponentesTextyBasicText"></a>
    <h2>Componentes Text y BasicText</h2>

    <p>Los componentes <span class="negrita">Text</span> y <span class="negrita">BasicText</span> permiten mostrar una
      cadena de texto en la interfaz.</p>

    <p>La diferencia es que <span class="negrita">Text utiliza principios de Material</span> mientras que BasicText
      no.</p>

    <p>Su uso básico ya se ha estudiado en clase y es el siguiente:</p>
    <figure><img src="UD7/images/ud7-2023-10-22-23-57-45.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Es <span class="negrita">importante saber cómo funcionan los componentes de Jetpack Compose</span>. Pulsa <span
        class="negrita">CTRL y mantenlo pulsado mientras haces clic izquierdo</span> sobre el nombre de la clase.
      También funciona situando el cursor encima y pulsando CTRL+B.</p>
    <p>Esto abrirá el código del componente en Android Studio. Puedes hacerlo con cualquier clase, función u objeto…
    </p>

    <figure><img src="UD7/images/KotlinDoc.gif" /><br>
      <figcaption>Pulsar ctrl+B sobre el componente para ver su definición.</figcaption>
    </figure>
    <br>

    <p>Todas las funciones cuentan con documentación <span class="cursiva">KotlinDoc</span>, donde se explican sus
      parámetros.</p>

    <p>Cuando llamas a la función Text usando nombres de parámetros como recomienda Jetpack Compose, puedes alterar su
      orden.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-06-03.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Cuando utilices componentes de Jetpack Compose, igual que con cualquier clase que no es tuya, es importante
      revisar los parámetros que tienen y cómo funcionan.</p>

    <p>Con el cursor sobre una clase/función/parámetro/variable, pulsa CTRL+B y Android Studio abrirá el archivo donde
      está definido para que puedas revisarlo.</p>

    <p>Por ejemplo:</p>
    <ul>
      <li>text requiere un String</li>
      <li>modifier requiere un Modifier</li>
      <li>fontWeight requiere un FontWeight</li>
    </ul>

    <p>Navegando entre los parámetros con CTRL+B puedes ver qué tipo de dato acepta cada uno. También puede
      consultarse online en la documentación oficial.</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-07-47.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El único parámetro <span class="negrita">obligatorio</span> es <span class="negrita">text</span>, la cadena que
      se debe mostrar.</p>

    <p>Todos los demás parámetros son opcionales (ya tienen valor). Si los omites, Kotlin usará sus valores por
      defecto.</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-08-54.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Algunos ejemplos de <span class="negrita">Text</span> con parámetros:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-10-25.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Con el parámetro <span class="negrita">style</span> puedes configurar varias propiedades de estilo a la vez.
    </p>

    <p>Aunque también puedes usar parámetros específicos como <span class="negrita">color</span>, <span
        class="negrita">fontSize…</span></p>

  </section><!-- End section Componentes Text y BasicText-->

  <!--*********************************************************Modifier***********************************************************-->
  <section class="apartado">
    <a name="sModifier"></a>
    <h2>Modifier</h2>

    <p>Todo componente tiene un parámetro <span class="r-word">modifier</span>.</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-11-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Por defecto, el parámetro modifier contiene un objeto <span class="negrita">Modifier</span> con una
      configuración básica.</p>

    <p>El objeto <span class="r-word">Modifier</span> es un <span class="negrita">Companion Object</span> con
      numerosas funciones de extensión para modificar componentes.</p>

    <p>Además, es del tipo <span class="negrita">builder</span>, así que puedes encadenar llamadas a estas funciones
      usando puntos.</p>

    <p>El <span class="negrita">orden</span> en el que llames a estas funciones es <span
        class="negrita">importante</span> y genera efectos distintos.</p>

    <p>Podemos clasificar las funciones de extensión de Modifier <span class="cursiva">de forma no oficial</span> así:
    </p>

    <br>
    <table>
      <tr>
        <th>Posicionamiento y tamaño</th>
        <td>fillMaxSize, fillMaxWidth, fillMaxHeight, wrapContentSize, wrapContentHeigtht, width, height,
          aspectRatio…</td>
      </tr>
      <tr>
        <th>Funcionalidad</th>
        <td>clickable, toggleable, horizontalScroll, verticalScroll…</td>
      </tr>
      <tr>
        <th>Apariencia</th>
        <td>padding, border, alpha…</td>
      </tr>
      <tr>
        <th>Listeners</th>
        <td>onClick, onFocusChanged, onKeyEvent, onSizeChanged…</td>
      </tr>
    </table>

    <br><br>
    <p>Ejemplo de <span class="negrita">Text</span> con <span class="negrita">modifier</span>:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-17-50.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El <span class="negrita">orden de llamada</span> de las funciones del Modifier cambia el comportamiento:</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-18-28.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Gracias a Modifier, todos los componentes pueden ser <span class="negrita">clicables</span>:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-19-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El orden en que coloques <span class="negrita">clickable</span> también cambia el comportamiento.</p>

    <p>Hay más manejadores de eventos: <span class="cursiva">onFocusChanged</span>, <span
        class="cursiva">onKeyEvent…</span></p>

    <p>Si el contenido de un componente no cabe en la pantalla por cualquier motivo,
      gracias a Modifier puedes especificar <span class="negrita">verticalScroll</span> o <span
        class="negrita">horizontalScroll</span>
      para poder desplazarlo y verlo completo.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-20-25.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Si aplicas <span class="negrita">verticalScroll</span> o <span class="negrita">horizontalScroll</span>
      en un componente que ocupa toda la pantalla, el resto de elementos no se verá salvo que indiques un tamaño al
      componente desplazable.</p>

    <p>Si un elemento puede desplazarse verticalmente, no debería haber otro desplazable vertical dentro.
      Si uno puede desplazarse horizontalmente, no deberías tener otro desplazable horizontal dentro.</p>

    <p>Más adelante verás <span class="negrita">rememberScrollState</span>.</p>

    <p>Puedes consultar todas las funciones de extensión del objeto Modifier en la documentación:
      <br>
      <a class="enlace" target="_blank"
        href="https://developer.android.com/jetpack/compose/modifiers-list">https://developer.android.com/jetpack/compose/modifiers-list</a>
    </p>

    <p>La mayoría de funciones de <span class="negrita">Modifier</span> pueden usarse en cualquier ámbito, pero
      algunas solo pueden usarse en ámbitos específicos.</p>

    <a href="UD7/images/ud_7-2025-01-06-23-44-25.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-44-25.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

  </section><!-- End section Modifier-->

  <!--*********************************************************Componente Button***********************************************************-->
  <section class="apartado">
    <a name="sComponenteButton"></a>
    <h2>Componente Button</h2>

    <p>Un <span class="r-word">Button</span> permite realizar una acción cuando el usuario interactúa.</p>

    <p>Tiene dos parámetros obligatorios: <span class="r-word">onClick</span> y <span class="r-word">content</span>,
      ambos funciones lambda, y el segundo es el último parámetro para que pueda extraerse fuera de los paréntesis.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-24-56.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El parámetro <span class="negrita">content</span> es una función lambda que recibe <span
        class="negrita">@Composable</span>, lo que significa que puedes poner componentes de Jetpack Compose en su
      interior.</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-26-30.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Además, implementa <span class="negrita">RowScope</span> (ámbito de fila) por lo que se comporta como un <span
        class="negrita">Row</span>, y cualquier componente incluido se colocará en fila.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-27-28.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="r-word">Button</span> define algunos valores por defecto en la clase <span
        class="r-word">ButtonDefaults</span>, y para ciertas personalizaciones debes usar dicha clase:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-28-25.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El componente <span class="r-word">Button</span> tiene <span class="negrita">distintas variaciones</span> con
      estilos predefinidos:</p>
    <figure><img src="UD7/images/ud7-2023-10-23-00-29-58.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Internamente, todos estos componentes son de tipo Button.</p>

  </section><!-- End section Componente Button-->


  <!--*********************************************************Componentes propios***********************************************************-->
  <section class="apartado">
    <a name="sComponentespropios"></a>
    <h2>Componentes propios</h2>

    <p>Para mantener el código organizado, es habitual crear tus propios componentes que amplíen o agrupen los
      componentes existentes de Jetpack Compose.</p>

    <p>Para crear tu propio componente, debes crear una función etiquetada con
      <span class="r-word">@Composable</span>.
    </p>

    <p>Además, la documentación indica que:
    <ul>
      <li>Si la función <span class="r-word">@Composable</span> <strong>no</strong> devuelve nada (lo más habitual),
        su nombre debe empezar con mayúscula.</li>
      <li>Si la función <span class="r-word">@Composable</span> <strong>sí</strong> devuelve algo, su nombre debe
        empezar con minúscula.</li>
    </ul>

    <a href="UD7/images/ud_7-2025-01-06-23-51-40.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-06-23-51-40.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-33-25.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Puedes diseñar tu propio componente que combine un <span class="r-word">Modifier</span> interno con el Modifier
      recibido como parámetro.</p>

    <p>Cuando creas un componente que amplía otro, puedes definirlo para que reciba un <span
        class="r-word">modifier</span> como parámetro, que posteriormente se aplicará al componente extendido.</p>

    <p>Además, puedes combinar el <span class="r-word">Modifier</span> recibido como parámetro con el definido dentro
      del componente usando el método <span class="negrita">then</span>.
      Ten en cuenta que la ubicación donde llames a <span class="negrita">then</span> alterará su comportamiento.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-34-52.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <section class="marco-t warn">
      <span class="icono warning"> </span> Dónde llames a <span class="negrita">then</span> cambia su comportamiento.
    </section>
    <section class="marco-b">
    </section>

    <p>También puedes indicar que, si se recibe un <span class="r-word">Modifier</span>, se use ese; en caso
      contrario, cargar uno interno.</p>

    <a href="UD7/images/ud_7-2025-01-07-00-00-12.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-07-00-00-12.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Tus propios componentes te permiten dividir el código para una mejor organización.</p>

    <p>Es importante que tus componentes personalizados sean <span class="negrita">lo más pequeños posible</span> y
      tengan <span class="negrita">nombres semánticos</span>, de modo que se expliquen por sí mismos.</p>

    <p>Además, puedes crear componentes personalizados que agrupen otros para reutilizarlos todos a la vez y organizar
      mejor el código.</p>

    <p>Los ejemplos anteriores son ideales para comprender este concepto.</p>

  </section><!-- End section Componentes propios-->

  <!--*********************************************************Componente Spacer***********************************************************-->
  <section class="apartado">
    <a name="sComponenteSpacer"></a>
    <h2>Componente Spacer</h2>

    <p>El componente <span class="r-word">Spacer</span> te permite colocar espacio entre otros componentes y
      <span class="negrita">solo</span> acepta el parámetro <span class="negrita">modifier</span>.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-00-39-08.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Es recomendable crear tu propio componente que extienda Spacer para simplificar su uso:</p>

    <a href="UD7/images/ud_7-2025-01-07-00-04-59.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-07-00-04-59.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

  </section><!-- End section Componente Spacer-->

  <!--*********************************************************Imágenes***********************************************************-->
  <section class="apartado">
    <a name="sImagenes"></a>
    <h2>Imágenes</h2>

    <p>En una aplicación Android, las imágenes deben importarse al proyecto o descargarse desde internet.</p>

    <p>Las imágenes importadas deben estar en alguno de estos formatos: vector, jpg, png o webp.</p>

    <p>En cuanto a las imágenes rasterizadas (jpg, png y webp), es preferible usar el formato <span
        class="negrita">webp</span>. Por ello, explicaremos cómo convertir imágenes importadas en formato jpg y png a
      webp.</p>

    <p>Para añadir imágenes al proyecto, abre el panel <span class="d-word">Resource Manager</span> situado a la
      izquierda y pulsa el botón <span class="d-word">+</span>.</p>

    <a href="UD7/images/ud_7-2025-01-07-00-07-29.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-07-00-07-29.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Para añadir imágenes rasterizadas (jpg, png y webp), selecciona <span class="d-word">Import Drawables</span>.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-28-59.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Una vez eliges la imagen, aparece una ventana de importación:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-29-38.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Si quieres, puedes seleccionar un <span class="d-word">QUALIFIER</span>, lo cual permitirá cargar imágenes de
      distinto tamaño según las características del dispositivo.</p>

    <p>Finalmente, pulsa <span class="d-word">Import</span> y la imagen estará lista.</p>

    <p>Para añadir imágenes vectoriales, normalmente iconos de Google, selecciona <span class="d-word">Vector
        Asset</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-31-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Se abrirá una ventana donde podrás elegir el icono y especificar su nombre, tamaño, color y opacidad.</p>

    <p>Puedes elegir entre <span class="negrita">Clip art</span> (iconos por defecto de Google) o <span
        class="negrita">Local file</span> si el recurso es externo.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-33-19.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Finalmente, haz clic en Finish y la imagen estará lista.</p>

    <p>Todas las imágenes importadas, sin importar su tipo, se encuentran en la carpeta <span
        class="inline-folder">res</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-35-18.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Si has elegido <span class="cursiva">QUALIFIERS</span>, las imágenes aparecerán organizadas según dicho <span
        class="cursiva">QUALIFIER</span>.</p>

    <h3>Convertir imágenes rasterizadas a webp</h3>

    <p>Google recomienda el formato webp porque está más optimizado y ocupa menos espacio.</p>

    <p>Usar webp puede <span class="subrayado">reducir el tamaño de la aplicación hasta un 80%</span>.</p>

    <p>El formato webp es compatible desde API 14 con pérdida de calidad y desde API 18 sin pérdida.</p>

    <p>Dado que en el curso trabajamos con API 24 o superior, no hay problemas de calidad.</p>

    <p>Haz clic derecho sobre la imagen en el proyecto:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-40-38.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Elige las opciones necesarias: 100% o <span class="cursiva">Lossless encoding → maximum quality</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-09-41-22.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Aparece una vista previa mostrando la calidad final, el tamaño final y las diferencias.
      También puedes ajustar la calidad final si lo deseas.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-19-38.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En el ejemplo, una imagen al 30% de calidad apenas pierde nitidez y pasa de 421.3 KB a 14.5 KB (un 3.5% del
      tamaño original).</p>

    <p>Finalmente, pulsa Finish para convertir la imagen a formato webp.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-20-27.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Con imágenes más grandes, la optimización es aún más notable:
    <ul>
      <li>Imagen original: 7.9 MB</li>
      <li>Imagen final: 400 KB</li>
      <li>Reducción: 6.1%</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-23-05.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente Image</h3>

    <p>El componente <span class="r-word">Image</span> permite cargar imágenes importadas en el proyecto.<br>

      La función tiene dos parámetros obligatorios:
    <ul>
      <li><span class="negrita">painter</span>: indica qué recurso cargar.</li>
      <li><span class="negrita">contentDescription</span>: descripción de la imagen.</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-25-01.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Usando la función <span class="r-word">Modifier.clip()</span>, puedes dar forma a cualquier componente.
      Si aplicas un borde, debes usar la misma forma que en el clip.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-26-41.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Si indicas a la imagen que ocupe el espacio disponible mediante el parámetro <span
        class="r-word">ContentScale</span>,
      puedes especificar cómo debe llenar ese espacio:</p>

    <p>Con <span class="r-word">Crop</span>: se ajusta a la dimensión más pequeña del contenedor.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-27-46.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Imágenes de Internet</h3>

    <p>Usando la librería <span class="d-word">Coil</span> y el componente <span class="r-word">AsyncImage</span>,
      puedes cargar imágenes desde internet.</p>

    <p>Necesitas permiso de acceso a la red. Para ello, en el archivo
      <span class="inline-file">AndroidManifest.xml</span>,
      en <span class="cursiva">manifest → AndroidManifest.xml</span> debes añadir:
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-31-08.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En el archivo <span class="inline-file">libs.versions.toml</span>:</p>

    <ul>
      <li>En la sección <span class="cursiva">[versions]</span>:</li>

      <section>
        <pre><code class="language-kotlin">coil="3.0.4"</code></pre>
      </section>
      <br><br>

      <li>En la sección <span class="cursiva">[libraries]</span>:</li>

      <section>
        <pre><code class="language-kotlin">coil-compose = { group = "io.coil-kt.coil3", name = "coil-compose", version.ref = "coil" }
coil-network-okhttp = { group = "io.coil-kt.coil3", name = "coil-network-okhttp", version.ref = "coil" }
</code></pre>
      </section>
      <br><br>
    </ul>

    <p>A continuación, añade la dependencia en el archivo
      <span class="inline-file">build.gradle.kts (Module: app)</span>
      y pulsa <span class="negrita">Sync Now</span> en la esquina superior derecha.
    </p>

    <section>
      <pre><code class="language-kotlin">implementation(libs.coil.compose)
implementation(libs.coil.network.okhttp)
</code></pre>
    </section>
    <br><br>

    <a href="UD7/images/ud_7-2025-01-07-00-18-57.png" target="_BLANK">
      <figure>
        <img src="UD7/images/ud_7-2025-01-07-00-18-57.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Cuando finalice la sincronización, ya puedes usar el componente <span class="r-word">AsyncImage</span>.</p>

    <p>Dado que las <span class="negrita">@Preview</span> <span class="subrayado">no tienen acceso a internet</span>,
      debes ejecutar la aplicación para ver el resultado.</p>

    <p>AsyncImage tiene dos parámetros obligatorios: <span class="negrita">model</span> y <span
        class="negrita">contentDescription</span>.
      También dispone del parámetro <span class="negrita">contentScale</span> para indicar cómo la imagen llena el
      espacio disponible.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-33-07.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="r-word">AsyncImage</span> también cuenta con el parámetro <span class="r-word">contentScale</span>
      para especificar cómo debe llenar el espacio disponible.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-35-07.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Puedes dar forma a imágenes con <span class="r-word">AsyncImage</span> y la función <span
        class="r-word">Modifier.clip()</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-43-46.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Coil ofrece la función <span class="r-word">crossfade</span> para mostrar la imagen gradualmente:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-43-30.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente Icon</h3>

    <p>El componente <span class="r-word">Icon</span> muestra un icono en la aplicación, similar a <span
        class="r-word">Image</span>, pero con soporte de Material Design.</p>

    <p>Solo acepta imágenes vectoriales o raster (convertidas a webp).</p>

    <p>Solo puede mostrar un color.</p>

    <p>Por defecto, su tamaño es 24dp, pero admite los siguientes tamaños:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-50-14.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En el ejemplo, usar una imagen como Icon descarta sus colores.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-51-14.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Con la clase <span class="negrita">Icons</span>, puedes usar iconos del sistema.</p>

    <p>Lo habitual es usar iconos vectoriales de <span class="cursiva">Material Design</span>.</p>

    <p>Android Studio solo incluye algunos iconos por defecto.
      Si necesitas el conjunto completo, añade la siguiente dependencia en:</p>

    <ul>
      <li>Archivo <span class="inline-file">libs.versions.toml</span>, en la sección <span
          class="cursiva">[libraries]</span>:<br>
        <section>
          <pre><code class="language-kotlin">androidx-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }</code></pre>
        </section>
      </li>

      <li>Archivo <span class="inline-file">build.gradle.kts (Module: app)</span> y sincroniza:</li>

      <section>
        <pre><code class="language-kotlin">implementation(libs.androidx.material.icons.extended)</code></pre>
      </section>
      <br>
    </ul>

    <p>Recuerda pulsar <span class="negrita">Sync Now</span> tras añadir la dependencia.</p>

    <p>Una vez añadida, tendrás acceso a <a class="enlace" target="_blank" href="https://fonts.google.com/icons">todos
        los iconos</a>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-53-52.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En la clase Icon, tenemos subclases de iconos:</p>

    <ul>
      <li><span class="negrita">Default</span>: mismo uso que Filled.</li>
      <li><span class="negrita">Filled</span>: icono completamente en un color.</li>
      <li><span class="negrita">Outlined</span>: icono mostrando solo los bordes.</li>
      <li><span class="negrita">TwoTone</span>: icono con dos tonos.</li>
      <li><span class="negrita">Sharp</span>: icono con esquinas anguladas.</li>
      <li><span class="negrita">Rounded</span>: icono con esquinas redondeadas.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-23-12-55-48.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Puedes usar el parámetro <span class="r-word">tint</span> para cambiar el color del icono.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-56-33.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Imágenes-->

  <!--*********************************************************Componente Badge***********************************************************-->
  <section class="apartado">
    <a name="sComponenteBadge"></a>
    <h2>Componente Badge</h2>

    <p>El componente <span class="r-word">Badge</span> te permite mostrar información dinámica, como el número de
      mensajes pendientes.</p>

    <p>Un Badge solo debe mostrar un icono o un texto corto.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-12-58-57.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente BadgedBox</h3>

    <p>El componente <span class="r-word">BadgedBox</span> muestra información dinámica, como el número de mensajes
      pendientes, encima de otro elemento, como un icono.</p>

    <p>Se usa habitualmente en barras de navegación.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-00-11.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componente Badge-->

  <!--*********************************************************Componentes Divider***********************************************************-->
  <section class="apartado">
    <a name="sComponentesDivider"></a>
    <h2>Componentes Divider</h2>

    <p>Existen tres componentes <span class="r-word">Divider</span>:</p>

    <ul>
      <li><span class="negrita">Divider</span>: disponible hasta material3 v1.1.1, deprecado en material3 v1.2.0.</li>
      <li><span class="negrita">HorizontalDivider</span>: disponible en material3 v1.2.0.</li>
      <li><span class="negrita">VerticalDivider</span>: disponible en material3 v1.2.0.</li>
    </ul>

    <p>Como la versión 1.2.0 está en Alpha, puedes seguir usando Divider.</p>

    <p>Si quieres usar <span class="negrita">HorizontalDivider</span> y <span class="negrita">VerticalDivider</span>,
      debes actualizar la dependencia en <span class="inline-file">build.gradle.kts (Module)</span> y sincronizar.</p>

    <p><span class="negrita">Divider</span> (una línea horizontal), <span class="negrita">HorizontalDivider</span> y
      <span class="negrita">VerticalDivider</span> dibujan líneas para separar elementos, normalmente en Rows o
      Columns.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-04-56.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Los tres componentes comparten los mismos parámetros: <span class="negrita">modifier</span>, <span
        class="negrita">thickness</span> y <span class="negrita">color</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-05-49.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <div class="tarea">
      <p>
        Crea un proyecto en Android Studio llamado <span class="negrita">ProfileYou</span>.
      </p>
      <p>
        Usando los componentes vistos hasta ahora en esta unidad, diseña una pantalla que haga de perfil de usuario en
        una red social,
        mostrando:
      <ul>
        <li>Tu nombre</li>
        <li>Una foto tuya (tipo carné)</li>
        <li>Una lista de hobbies o gustos, cada uno con un icono delante</li>
        <li>Un botón para seguir o dejar de seguir</li>
        <li>Dos imágenes pequeñas de lo que quieras</li>
        <li>Un botón con icono para dar like o quitar like a cada una de esas imágenes</li>
        <li>Una BadgedBox con un icono de sobre mostrando el número de mensajes sin leer</li>
        <li>Un botón abajo con un + que incremente el contador de mensajes</li>
      </ul>
      </p>
    </div>

    <p>La aplicación podría verse así:</p>

    <figure><img src="UD7/images/DemoProfile.gif" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Aquí tienes una posible <a class="enlace" target="_blank"
        href="https://github.com/sdram58/EJEMPLOSPMDM2526/tree/master/UD7/Profile">solución</a>; recuerda que solo es
      una referencia, y deberías intentar hacerlo por tu cuenta.</p>

  </section><!-- End section Componentes Divider-->

  <!--*********************************************************Conceptos***********************************************************-->
  <section class="apartado">
    <a name="sConceptos"></a>
    <h2>Conceptos</h2>
    <h3>Composición y Recomposición</h3>

    <p><span class="negrita">Composición</span> y <span class="negrita">recomposición</span> son comportamientos
      típicos en las interfaces de usuario declarativas.</p>

    <ul>
      <li><span class="negrita">Composición</span>: la primera ejecución de una función de composición (@Composable)
        -> renderizado de un componente en la interfaz.</li>

      <li><span class="negrita">Recomposición</span>: la segunda o más ejecuciones de una función de composición
        (@Composable) -> se vuelve a renderizar la interfaz solo en los componentes afectados.</li>
    </ul>

    <p>Si, durante la ejecución, un componente cambia, ese componente se recompone.</p>

    <p>Por ello, la interfaz de usuario siempre muestra la última versión del componente.</p>

    <h3>Estados</h3>

    <p>En Jetpack Compose, un <span class="negrita">estado</span> es una variable ligada al estado de la aplicación.
    </p>

    <p>Si, mientras se ejecuta la aplicación, un <span class="negrita">estado</span> (una variable ligada al estado de
      la aplicación)
      cambia de valor, cualquier elemento de la interfaz que dependa de él se recompone (se vuelve a renderizar).</p>

    <p>En el ejemplo de la UD6 <span class="cursiva">"Clicks Counter"</span>, usamos un estado para volver a
      renderizar la interfaz cuando se pulsa el botón.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-18-23.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="r-word">mutableStateOf</span>: indica que la variable es un estado
      (una variable ligada al estado de la aplicación).
      Si esta variable cambia, cualquier función <span class="negrita">@Composable</span> que la utilice se recompone.
    </p>

    <p>El problema es que, si la función <span class="negrita">@Composable</span> se vuelve a ejecutar, el estado
      vuelve a su valor inicial.</p>

    <p>Podemos resolverlo con:
      <li><span class="negrita">remember</span>: indica a Android que una variable debe <span
          class="subrayado">recordarse durante la recomposición</span>.</li>
      <li><span class="negrita">rememberSaveable</span>: lo anterior, pero además <span class="subrayado">permanece
          tras destruirse y recrearse la Activity</span>.</li>
    </p>

    <p>Los estados pueden crearse con <span class="negrita">=</span>, pero eso implica usar <span
        class="negrita">.value</span>
      para leer y modificar su valor.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-21-52.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Para simplificar el uso de estados, puedes usar el delegado <span class="negrita">by</span>,
      como en los ejemplos, permitiendo referirte al estado directamente con el nombre de la variable.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-22-09.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Cuando hablamos del parámetro <span class="negrita">modifier</span>,
      comentamos que si el contenido no cabe en la pantalla, puedes aplicar
      <span class="negrita">verticalScroll</span> o <span class="negrita">horizontalScroll</span> para permitir el
      desplazamiento.
    </p>

    <p>Usamos <span class="r-word">rememberScrollState</span> para ello.</p>

    <p>Esta función establece un estado mediante <span class="negrita">rememberSaveable</span>, por lo que
      el desplazamiento se recuerda tras cambios de orientación/configuración:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-24-13.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Gracias a la recomposición, es sencillo cambiar la apariencia de la interfaz:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-26-35.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Otro ejemplo</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-27-32.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Conceptos-->

  <!--*********************************************************Componentes para introducir información***********************************************************-->
  <section class="apartado">
    <a name="sComponentesparaintroducirinformacion"></a>
    <h2>Componentes para introducir información</h2>

    <p>A continuación veremos un conjunto de componentes de Jetpack Compose que permiten <span class="negrita">recoger
        información del usuario</span>.</p>

    <p>Estos componentes suelen utilizarse en formularios o pantallas de ajustes.</p>

    <p>Como estos componentes cambian al introducir o seleccionar datos, es necesario usar estados para gestionarlos
      correctamente.</p>

    <h3>Componente TextField</h3>

    <p>Los componentes <span class="r-word">TextField</span> permiten que el usuario introduzca datos desde el teclado
      del dispositivo.</p>

    <p>Hay tres tipos de TextField:</p>
    <ul>
      <li><span class="negrita">BasicTextField</span>: un campo de texto básico.</li>
      <li><span class="negrita">TextField</span>: usa los principios de Material.</li>
      <li><span class="negrita">OutlinedTextField</span>: igual que TextField pero con un borde por defecto en el
        parámetro <span class="negrita">shape</span>.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-23-13-31-32.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Como vimos anteriormente, es importante conocer los parámetros que pueden tener los componentes.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-32-04.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Todos los parámetros que aceptan una función <span class="negrita">lambda</span> permiten realizar acciones.
      <span class="negrita">Si la lambda es además @Composable</span>, puedes incluir más componentes de Jetpack
      Compose dentro.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-33-03.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Ejemplo con dos campos, uno para email y otro para contraseña:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-33-50.png" /><br>
      <figcaption>Ejemplo con dos campos, uno para el email y otro para la contraseña</figcaption>
    </figure>
    <br>

    <p>Ejemplo de un campo de contraseña que permite mostrar el texto escrito:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-35-31.png" /><br>
      <figcaption>Ejemplo de un campo de contraseña que permite ver el texto introducido</figcaption>
    </figure>
    <br>

    <p>Ejemplo en el que el botón solo se activa si los campos tienen datos:</p>

    <p>Gracias a los estados y la recomposición, no necesitas un <span class="r-word">if</span> para habilitar el
      botón:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-37-18.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El parámetro keyboardOptions permite controlar el tipo de teclado que se muestra.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-38-12.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El parámetro keyboardActions te permite especificar qué ocurre cuando el usuario pulsa el botón (imeAction).
    </p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-39-17.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componentes para introducir información-->

  <!--*********************************************************State Hoisting***********************************************************-->
  <section class="apartado">
    <a name="sStateHoisting"></a>
    <h2>State Hoisting</h2>

    <p>Como se mencionó antes, es muy habitual crear componentes personalizados que envuelvan uno o varios componentes
      de Jetpack Compose.</p>

    <p>En este punto, existen dos posibilidades:</p>
    <ul>
      <li><span class="negrita">Componente stateless</span>: tu propio componente que no declara estado.</li>
      <li><span class="negrita">Componente stateful</span>: tu propio componente que declara un estado.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-23-13-43-44.png" /><br>
      <figcaption>Stateless</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-23-13-44-05.png" /><br>
      <figcaption>Stateful</figcaption>
    </figure>
    <br>

    <p>Desde fuera de un componente <span class="negrita">stateful</span>, <span class="subrayado">no puedes acceder a
        su estado</span>.</p>

    <p>Imagina un formulario donde <span class="negrita">todos los componentes son personalizados y stateful</span>.
      ¿Cómo accederías a los datos introducidos por el usuario?</p>

    <p>En el ejemplo anterior, todos los componentes están codificados directamente, así que no hay problema, pero…
      ¿qué ocurriría si los hubieras extraído como componentes personalizados (como se recomienda para mantener el
      código limpio)?</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-47-21.png" /><br>
      <figcaption>Extrayendo componentes como componentes propios</figcaption>
    </figure>
    <br>

    <p>La solución es <span class="negrita">State Hoisting</span>, que permite acceder al estado desde fuera.
      Al usar <span class="negrita">State Hoisting</span>, el estado deja de declararse dentro del componente
      stateful,
      convirtiéndolo en un componente stateless.
      <span class="subrayado">La práctica recomendada es mantener los componentes stateless siempre que sea
        posible.</span>
    </p>

    <p>
      Si un componente tiene un estado que no necesitas desde fuera, puede permanecer <span
        class="negrita">stateful</span>.
    </p>

    <p>La técnica de <span class="negrita">State Hoisting</span> consiste en eliminar el estado de un componente
      stateful
      (volviéndolo stateless) y sustituirlo por dos parámetros que deben proporcionarse al usarlo:
    </p>

    <ul>
      <li>Uno para proporcionar el valor al componente</li>
      <li>Otro, una lambda para modificar dicho valor</li>
    </ul>

    <p>Esta técnica ya la usa, por ejemplo, el componente <span class="negrita">TextField</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-51-14.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Ejemplo previo aplicando State Hoisting:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-52-27.png" /><br>
      <figcaption><span class="negrita">Componentes stateless</span></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-23-13-52-59.png" /><br>
      <figcaption>Cómo usar los componentes</figcaption>
    </figure>
    <br>

    <p>Puedes hacerlo de una manera más limpia usando <span class="negrita">=</span> en lugar de <span
        class="negrita">by</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-56-31.png" /><br>
      <figcaption>Estado único</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-23-13-57-22.png" /><br>
      <figcaption>Múltiples estados</figcaption>
    </figure>
    <br>

  </section><!-- End section State Hoisting-->

  <!--*********************************************************Componente Switch***********************************************************-->
  <section class="apartado">
    <a name="sComponenteSwitch"></a>
    <h2>Componente Switch</h2>

    <p>Los <span class="r-word">Switch</span> son interruptores que permiten <span class="negrita">activar</span> o
      <span class="negrita">desactivar</span> funcionalidades.
      Son muy comunes en las secciones de preferencias.
    </p>

    <p>El parámetro <span class="negrita">thumbContent</span> permite añadir un icono al switch.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-13-59-22.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>También puedes personalizar los colores:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-14-00-45.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <div class="tarea">
      <p>
        Crea un nuevo proyecto en Android Studio llamado <span class="negrita">ConverterV2You</span>
      </p>
      <p>
        La aplicación debe contener:
      <ul>
        <li>Tu nombre</li>
        <li>Una foto tuya (tipo carné)</li>
        <li>Un campo de texto para que el usuario introduzca un número a convertir a binario o decimal.</li>
        <li>Un switch (Switch) para decidir si convertir a decimal o binario.</li>
        <li>Un botón para realizar la conversión.</li>
        <li>Un texto mostrando el resultado. Será de un color si es binario y de otro si es decimal.</li>
        <li>Un botón para limpiar tanto el campo de texto como el resultado.</li>
      </ul>
      </p>
    </div>

    <p>Aquí tienes un ejemplo de cómo podría verse la aplicación:</p>

    <figure><img src="UD7/images/ConverterExample.gif" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En este <a class="enlace" target="_blank"
        href="https://github.com/sdram58/EJEMPLOSPMDM2526/tree/master/UD7/ConverterV2">enlace</a> puedes encontrar una
      solución en GitHub. Una vez más, es solo una referencia; se espera que lo intentes por tu cuenta.</p>

  </section><!-- End section Componente Switch-->

  <!--*********************************************************Componente CheckBox***********************************************************-->
  <section class="apartado">
    <a name="sComponenteCheckBox"></a>
    <h2>Componente Checkbox</h2>

    <p>El componente <span class="r-word">Checkbox</span> permite que los usuarios seleccionen una o varias opciones.
    </p>

    <p>Puedes personalizar sus colores de manera similar a los Switch.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-16-55-45.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Dado que <span class="r-word">Checkbox</span> suele ir acompañado de un texto,
      puedes crear un componente personalizado que agrupe un <span class="negrita">Text</span>,
      un <span class="negrita">Spacer</span> y un <span class="negrita">Checkbox</span> dentro de un
      <span class="negrita">Row</span> para reutilizarlo en cualquier parte.
    </p>

    <p>Aquí tienes un ejemplo de cómo definirlo:</p>

    <section>
      <pre><code class="language-kotlin">//Data class for MyCheckbox objects
data class Check(
    var title: String,
    var selected: Boolean,
    var onCheckedChange: (Boolean) -> Unit
)

//Function that receives a set of titles and converts them
//into a list of Check objects
@Composable
fun getChecks(vararg titles: String): List<Check> {
    return titles.map {
        var state by rememberSaveable {
            mutableStateOf(false)
        }
        Check(
            title = it,
            selected = state,
            onCheckedChange = { selected -> state = selected }
        )
    }
}

//Custom stateless Checkbox component
@Composable
fun MyCheckBox(check: Check) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Checkbox(
            checked = check.selected, 
            onCheckedChange = { check.onCheckedChange(it) }
        )
        Text(text = check.title)
    }
}
</code></pre>
    </section><br><br>

    <p>Y cómo usarlo:</p>

    <section>
      <pre><code class="language-kotlin">Column(
    modifier = Modifier.fillMaxSize(),
    verticalArrangement = Arrangement.Center,
    horizontalAlignment = Alignment.CenterHorizontally
) {
    val myOptions = getChecks("Opción 1", "Opción 2", "Opción 3")
    myOptions.forEach {
        MyCheckBox(check = it)
    }
    Button(onClick ={
        myOptions.map {option ->
            Log.i("---->", "${option.title}: ${option.selected}")
        }

    }) {
        Text(text = "Guardar")
    }
}
</code></pre>
    </section><br><br>

    <p>El resultado sería el siguiente:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-17-32-09.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Y si hacemos clic en la segunda y tercera casilla, la salida del <span class="cursiva">logcat</span> sería:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-17-33-07.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente TriStateCheckBox</h3>

    <p>El componente <span class="r-word">TriStateCheckbox</span> es como un <span class="negrita">Checkbox</span>,
      pero con tres estados.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-17-34-34.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Se utiliza junto con otros checkbox para que el icono cambie según el número de casillas seleccionadas:</p>

    <ul>
      <li>Ninguna seleccionada.</li>
      <li>Alguna seleccionada.</li>
      <li>Todas seleccionadas.</li>
    </ul>

    <p>Ejemplo usando TriStateCheckbox:</p>

    <section>
      <pre><code class="language-kotlin">//State for the single check
var essentialsState by rememberSaveable { mutableStateOf(value = true) }
var thirdsState by rememberSaveable { mutableStateOf(value = true) }
//State for the TriStateCheckBox that calculate its value depending on the single checks
val cookiesState = rememberSaveable(
    essentialsState,
    thirdsState
) {
    if (essentialsState && thirdsState) ToggleableState.On //rememberSaveable
    else if (!essentialsState && !thirdsState) ToggleableState.Off //rememberSaveable
    else ToggleableState.Indeterminate //rememberSaveable
}

//Row for the TriStateCheckBox component
Row(verticalAlignment = Alignment.CenterVertically) { // this: RowScope
    TriStateCheckbox(
        state = cookiesState,
        //If TriStateCheckBox is pressed change the others
        onClick = {
            val s = cookiesState != ToggleableState.On
            essentialsState = s
            thirdsState = s
        }
    )
    Text(text = "Cookies")
}

//Column for the single CheckBox
Column(modifier = Modifier.padding(16.dp, 0.dp, 0.dp, 0.dp)) { // this: ColumnScope
    Row(verticalAlignment = Alignment.CenterVertically) { // this: RowScope
        Checkbox(
            checked = essentialsState,
            onCheckedChange = { essentialsState = it }
        )
        Text(text = "Esenciales")
    }

    Row(verticalAlignment = Alignment.CenterVertically) { // this: RowScope
        Checkbox(
            checked = thirdsState,
            onCheckedChange = { thirdsState = it }
        )
        Text(text = "De terceros")
    }
}
</code></pre>
    </section><br><br>

    <p>El resultado sería algo así:</p>

    <figure><img src="UD7/images/ud7-2023-10-23-17-37-56.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section ComponenteCheckBox-->

  <!--*********************************************************Componente RadioButton***********************************************************-->
  <section class="apartado">
    <a name="sComponenteRadioButton"></a>
    <h2>Componente RadioButton</h2>

    <p>El componente <span class="r-word">RadioButton</span> permite elegir una única opción entre varias.</p>

    <p>Los elementos <span class="r-word">RadioButton</span> de un conjunto <span class="subrayado">deben
        agruparse</span>
      en un layout usando el parámetro <span class="negrita">Modifier.selectableGroup()</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-23-17-41-40.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Lo cual produce este resultado:</p>
    <figure><img src="UD7/images/ud7-2023-10-23-17-42-05.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>A menudo es deseable que al pulsar sobre toda la fila, y no solo sobre el <span
        class="r-word">RadioButton</span>,
      se active la selección:</p>

    <section>
      <pre><code class="language-kotlin">var selected by rememberSaveable {
    mutableStateOf("")
}
Column(
    modifier = Modifier
        .selectableGroup()
        .fillMaxSize(),
    horizontalAlignment = Alignment.CenterHorizontally,

) {
    Row(
        modifier = Modifier.selectable(
                selected = selected == "DAM",
                onClick = { selected = "DAM" }
            ),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        RadioButton(selected = selected == "DAM", onClick = { selected = "DAM" })
        Text(text = "DAM")
    }

    Row(
        modifier = Modifier.selectable(
                selected = selected == "DAW",
                onClick = { selected = "DAW" }
            ),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        RadioButton(selected = selected == "DAW", onClick = { selected = "DAW" })
        Text(text = "DAW")
    }
}
</code></pre>
    </section><br><br>

    <p>Podemos generalizarlo con una lista de opciones tipo String:</p>

    <section>
      <pre><code class="language-kotlin">val listOfOptions = listOf("SMX", "ASIX", "DAM", "DAW")
var selected by rememberSaveable {
    mutableStateOf("")
}
Column(
    modifier = Modifier
        .selectableGroup()
        .fillMaxSize(),
    horizontalAlignment = Alignment.CenterHorizontally
) {
    listOfOptions.forEach() { option ->
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.selectable(
                selected = selected == option,
                onClick = { selected = option }
            )) {
            RadioButton(selected = selected == option, onClick = { selected = option })
            Text(text = option)
        }
    }
}
</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-10-23-23-36-03.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Ejemplo con varios <span class="negrita">RadioButton</span> y <span class="negrita">StateHoisting</span>.</p>

    <section>
      <pre><code class="language-kotlin">@Composable
fun MyRadioButton(vararg options:String, selected:String, onClick:(String)->Unit) {
    Column(modifier = Modifier.selectableGroup().fillMaxSize(),
           horizontalAlignment = Alignment.CenterHorizontally) {

        options.forEach { option ->
            Row(
                verticalAlignment = Alignment.CenterVertically,
            ) {
                RadioButton(
                  selected = selected == option,
                   onClick = { onClick(option) }
                )
                Text(text = option)
            }
        }
    }
}
</code></pre>
    </section><br><br>

    <p>Y podemos usar el componente así:</p>

    <section>
      <pre><code class="language-kotlin">var option by rememberSaveable {
    mutableStateOf("")
}
MyRadioButton(
    "Opción 1", "Opción 2", "Opción 3",
    selected = option,
    onClick = {option = it}
)
</code></pre>
    </section><br><br>

  </section><!-- End section Componente RadioButton-->

  <!--*********************************************************ComponenteSlider***********************************************************-->
  <section class="apartado">
    <a name="sComponenteSlider"></a>
    <h2>Componente Slider</h2>

    <p>Los <span class="r-word">Slider</span> son barras con un indicador arrastrable para elegir un valor.</p>

    <p>Por defecto, puedes seleccionar valores entre 0.0 y 1.0, pero esto se puede modificar.</p>

    <p>También puedes personalizar el indicador arrastrable.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-00-28-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-24-00-28-42.png" /><br>
      <figcaption>Slider personalizando el indicador</figcaption>
    </figure>
    <br>

    <h3>Componente RangeSlider</h3>

    <p>El componente <span class="r-word">RangeSlider</span> funciona de manera similar al <span
        class="negrita">Slider</span>,
      pero permite seleccionar un rango de valores.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-00-30-59.png" /><br>
      <figcaption>RangeSlider</figcaption>
    </figure>
    <br>

    <p>Puedes modificar los indicadores inicial (<span class="negrita">starThumb</span>) y final (<span
        class="negrita">endThumb</span>).</p>

    <p>En el ejemplo, dos estados almacenan los valores mínimo y máximo; podrías crear un estado personalizado con un
      rango (actualmente experimental).</p>

  </section><!-- End section ComponenteSlider-->

  <!--*********************************************************Componente ExposedDropdownMenu***********************************************************-->
  <section class="apartado">
    <a name="sComponenteExposedDropdownMenu"></a>
    <h2>Componente ExposedDropdownMenu</h2>

    <p>El componente <span class="r-word">ExposedDropdownMenu</span> muestra un <span class="negrita">TextField</span>
      con un menú desplegable.</p>

    <p>Dependiendo de cómo esté codificado su contenido, un <span class="r-word">ExposedDropdownMenu</span> puede
      utilizarse de diferentes formas:</p>

    <ul>
      <li><span class="negrita">No editable</span>: solo permite seleccionar una opción.</li>
      <li><span class="negrita">Editable</span>: puedes seleccionar una opción o escribir en el campo.</li>
      <li><span class="negrita">Editable con autocompletado</span>: editable con filtrado de resultados.</li>
    </ul>

    <p>Un <span class="r-word">ExposedDropdownMenu</span> está formado por un TextField con el modificador <span
        class="negrita">menuAnchor()</span>
      y varios componentes <span class="negrita">DropdownMenuItem</span> para las opciones disponibles.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-00-37-10.png" /><br>
      <figcaption>Ejemplo de un ExposedDropdownMenu <span class="negrita">no editable</span></figcaption>
    </figure>

    <section>
      <pre><code class="language-kotlin">var classes = listOf("Bárbaro", "Bardo", "Brujo","Clérigo", "Druida", "Explorador",
    "Guerrero", "Hechicero", "Mago", "Monje", "Paladín", "Pícaro")

var showMenu by rememberSaveable {
    mutableStateOf(false)
}
var selectedOptionText by rememberSaveable() {
    mutableStateOf("Selecciona una clase")
}

ExposedDropdownMenuBox(
    expanded = showMenu,
    onExpandedChange = {showMenu = !showMenu}) {
    OutlinedTextField(
        modifier = Modifier.menuAnchor(),
        value = selectedOptionText,
        onValueChange = {},
        label = { Text(text = "Clase")},
        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = showMenu)}
    )
    ExposedDropdownMenu(expanded = showMenu, onDismissRequest = { showMenu = false }) {
        classes.forEach(){ option ->
            DropdownMenuItem(
                text = { Text(option) },
                onClick = {
                    selectedOptionText = option
                    showMenu = false
                })
        }
    }
}
</code></pre>
    </section><br><br>

    <p>Resultado:</p>

    <figure><img src="UD7/images/ud7-2023-10-24-00-37-56.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componente ExposedDropdownMenu-->

  <!--*********************************************************Componente DatePicker***********************************************************-->
  <section class="apartado">
    <a name="sComponenteDatePicker"></a>
    <h2>Componente DatePicker</h2>

    <p>El componente <span class="r-word">DatePicker</span> permite seleccionar o introducir manualmente una fecha.
    </p>

    <p>Se puede indicar una fecha inicial seleccionada y modificar el encabezado y el título.</p>

    <p>También se puede mostrar un icono para cambiar entre los modos de introducción de fecha.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-11-29-08.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Podría verse así:</p>

    <figure><img src="UD7/images/ud7-2023-10-24-11-31-19.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>También existen
      <a class="enlace" target="_blank"
        href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#DatePickerDialog(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.material3.DatePickerColors,androidx.compose.ui.window.DialogProperties,kotlin.Function1)">DatePickerDialog</a>
      (disponible) y
      <a class="enlace" target="_blank"
        href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#DateRangePicker(androidx.compose.material3.DateRangePickerState,androidx.compose.ui.Modifier,androidx.compose.material3.DatePickerFormatter,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.material3.DatePickerColors)">DateRangePicker</a>
      (Jetpack Compose v1.2.0-alpha06).
    </p>

    <h3>TimePicker y TimeInput</h3>

    <p>Los componentes <span class="r-word">TimePicker</span> (con dial) y <span class="r-word">TimeInput</span>
      (con teclado) permiten seleccionar una hora.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-11-36-50.png" /><br>
      <figcaption>TimePicker</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-24-11-37-33.png" /><br>
      <figcaption>TimeInput</figcaption>
    </figure>
    <br>

  </section><!-- End section Componente DatePicker-->

  <!--*********************************************************Componentes Chips***********************************************************-->
  <section class="apartado">
    <a name="sComponentesChips"></a>
    <h2>Componentes Chip</h2>

    <p>Los <span class="negrita">Chips</span> son pequeños componentes con texto que sirven para iniciar entrada de
      información,
      lanzar acciones, filtrar contenido o realizar selecciones.</p>

    <p>Hay cuatro tipos:</p>
    <ul>
      <li><span class="negrita">Assist</span>: representan acciones predefinidas en la app, como añadir al calendario
        o cómo llegar.</li>
      <li><span class="negrita">Filter</span>: representan filtros aplicables a elementos de una colección.</li>
      <li><span class="negrita">Input</span>: representan pequeñas entradas de usuario, como direcciones de email
        añadidas.</li>
      <li><span class="negrita">Suggestion</span>: limitan acciones ofreciendo sugerencias generadas dinámicamente.
      </li>
    </ul>

    <p>También existen variantes <span class="negrita">ElevatedAssistChip</span>,
      <span class="negrita">ElevatedFilterChip</span> y <span class="negrita">ElevatedSuggestionChip</span>.
    </p>

    <p>Los Chips:</p>
    <ul>
      <li>No son botones.</li>
      <li>No deben usarse para acciones finales; para eso están los botones.</li>
      <li>Reaccionan a acciones del usuario.</li>
      <li>Son contextuales al contenido de la aplicación.</li>
      <li>Deben aparecer siempre como grupo.</li>
      <li>Deben mostrarse con desplazamiento horizontal.</li>
    </ul>

    <p>Todos los componentes <span class="negrita">Chip</span> se basan en el componente privado <span
        class="r-word">Chip</span>,
      por lo que se muestran de manera similar, aunque cada tipo tiene parámetros específicos.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-12-13-48.png" /><br>
      <figcaption>SuggestionChip y AssistChip</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-24-12-15-04.png" /><br>
      <figcaption>FilterChip e InputChip</figcaption>
    </figure>
    <br>

  </section><!-- End section Componentes Chips-->

  <!--*********************************************************Componente IconButton***********************************************************-->
  <section class="apartado">
    <a name="sComponenteIconButton"></a>
    <h2>Componente IconButton</h2>

    <p>El componente <span class="r-word">IconButton</span> se utiliza cuando se necesitan botones compactos,
      normalmente en barras de herramientas.</p>

    <p>Existen varios tipos:</p>
    <ul>
      <li><span class="r-word">IconButton</span></li>
      <li><span class="r-word">IconToggleButton</span></li>
      <li><span class="r-word">FilledIconButton</span></li>
      <li><span class="r-word">FilledToggleIconButton</span></li>
      <li><span class="r-word">FilledTonalIconButton</span></li>
      <li><span class="r-word">FilledTonalIconToggleButton</span></li>
      <li><span class="r-word">OutlinedIconButton</span></li>
      <li><span class="r-word">OutlinedIconToggleButton</span></li>
    </ul>

    <p>Las variantes <span class="negrita">Toggle</span> tienen dos estados: seleccionado o no seleccionado.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-12-19-13.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componente IconButton-->

  <!--*********************************************************Componente ProgressIndicator***********************************************************-->
  <section class="apartado">
    <a name="sComponenteProgressIndicator"></a>
    <h2>Componente ProgressIndicator</h2>

    <p>Los componentes <span class="r-word">LinearProgressIndicator</span> y <span
        class="r-word">CircularProgressIndicator</span>
      permiten notificar al usuario que una acción está ocurriendo en segundo plano.</p>

    <p>Estas barras de progreso pueden ser:</p>
    <ul>
      <li><span class="negrita">Indeterminadas</span>: no tienen un punto final.</li>
      <li><span class="negrita">Determinadas</span>: comienzan vacías y se rellenan hasta completarse.</li>
    </ul>

    <p>Para que una barra de progreso sea determinada, debes asignar el parámetro <span class="negrita">progress</span>
      con un valor entre <span class="negrita">0.0f</span> y <span class="negrita">1.0f</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-12-25-49.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Los componentes <span class="r-word">LinearProgressIndicator</span> y <span
        class="r-word">CircularProgressIndicator</span>
      tienen múltiples constructores para distintos aspectos visuales.</p>

    <p>Parámetros disponibles:</p>
    <ul>
      <li><span class="negrita">progress</span>: porcentaje rellenado.</li>
      <li><span class="negrita">color</span>: color del progreso.</li>
      <li><span class="negrita">trackColor</span>: color del fondo del progreso.</li>
      <li><span class="negrita">strokeCap</span>: forma del borde de la línea de progreso.</li>
      <li><span class="negrita">strokeWidth</span> (solo circular): grosor de la línea de progreso.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-24-12-28-36.png" /><br>
      <figcaption>CircularProgressIndicator</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-24-12-30-45.png" /><br>
      <figcaption>LinearProgressIndicator</figcaption>
    </figure>
    <br>

  </section><!-- End section Componente ProgressIndicator-->

  <!--*********************************************************Componentes SearchBar***********************************************************-->
  <section class="apartado">
    <a name="sComponentesSearchBar"></a>
    <h2>Componentes SearchBar</h2>

    <p>Existen dos componentes para crear barras de búsqueda:</p>
    <ul>
      <li><span class="negrita">SearchBar</span>: el cuerpo ocupa toda la pantalla.</li>
      <li><span class="negrita">DockedSearchBar</span>: el cuerpo ocupa parte de la pantalla (configurable).</li>
    </ul>

    <p>El componente <span class="r-word">SearchBar</span> tiene varios parámetros para su configuración, algunos de
      ellos dependientes de un estado.
      Por tanto, la configuración mínima sería la siguiente:</p>

    <figure><img src="UD7/images/ud7-2023-10-24-13-24-02.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Puedes utilizar varios métodos:</p>
    <ul>
      <li>Rellenar todo el cuerpo con todos los elementos y filtrarlos según la consulta del usuario.</li>
      <li>Dejar el cuerpo vacío y cambiarlo según los resultados filtrados.</li>
      <li>Crear un estado para el cuerpo y actualizarlo según el resultado de búsqueda.</li>
      <li>…</li>
    </ul>

    <p>Ejemplo de uso:</p>

    <section>
      <pre><code class="language-kotlin">//Lista de elementos a buscar
val dragonBallCharacters = listOf(
    "Son Goku",
    "vegeta",
    "Piccolo",
    "Son Gohan",
    "Trunks",
    "Bulma",
    "Krillin",
    "Master Roshi",
    "Freezer",
    "Cell"
)

//En algunas acciones, necesitamos un context (normalmente la Activity)
val myContext = LocalContext.current

var querySearchstate by rememberSaveable {
    mutableStateOf("")
}

var activeSearchState by rememberSaveable {
    mutableStateOf(false)
}

SearchBar(
    query = querySearchstate,
    onQueryChange = {querySearchstate = it},
    onSearch = {
        Toast.makeText(myContext, "Buscando: $it", Toast.LENGTH_SHORT).show()
    },
    active = activeSearchState,
    onActiveChange = {activeSearchState = it},
    placeholder = { Text("Introduce el personaje a buscar")},
    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = showMenu)}
) {
  //Contenido filtrado
  val charactersToShow = if (querySearchstate.isEmpty()){
      dragonBallCharacters
  }else{
      dragonBallCharacters.filter {
          it.contains(other = querySearchstate, ignoreCase = true)
      }
  }
  Column{
      charactersToShow.forEach {
          Text(
              text = it,
              modifier = Modifier
                  .padding(8.dp)
                  .clickable {
                      Toast.makeText(myContext, "Seleccionado $it", Toast.LENGTH_SHORT).show()
                      querySearchstate = it
                      activeSearchState = false
                  }
          )
      }
  }
}
</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-10-24-14-19-05.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <section class="marco-t warn">
      <span class="icono warning"> </span>
      <p>El componente <span class="negrita">SearchBar</span> del ejemplo está obsoleto desde la versión 1.3.0 de
        Material 3.</p>
      <p>Desde la versión 1.3.0, el componente <span class="negrita">SearchBar</span> incorpora un parámetro <span
          class="negrita">inputField</span> y su uso es el recomendado.</p>
      <p>En clase utilizamos Material3 v1.2.1 porque las versiones más nuevas contienen muchas características
        experimentales.</p>
      <p>Para este curso, utilizar <span class="negrita">SearchBar</span> como en el ejemplo anterior es suficiente.
      </p>
    </section>

    <section class="marco-b"></section>

  </section><!-- End section Componentes SearchBar-->

  <!--*********************************************************Componente AlertDialog***********************************************************-->
  <section class="apartado">
    <a name="sComponenteAlertDialog"></a>
    <h2>Componente AlertDialog</h2>

    <p>El componente <span class="r-word">AlertDialog</span> permite mostrar un mensaje en una ventana modal (pop-up).
    </p>

    <figure><img src="UD7/images/ud7-2023-10-24-14-23-45.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Los parámetros <span class="negrita">confirmButton</span>, <span class="negrita">dismissButton</span>,
      <span class="negrita">icon</span>, <span class="negrita">title</span> y <span class="negrita">text</span>
      son funciones <span class="negrita">@Composable</span>, por lo que puedes incluir cualquier componente dentro de
      ellos.
    </p>

    <p>También existe el componente <span class="negrita">Dialog</span>, pero no utiliza principios Material y debe
      configurarse por completo manualmente.</p>

    <p>Ejemplo:</p>

    <section>
      <pre><code class="language-kotlin">@Composable
fun ElementoComposable(){
  val ctx = LocalContext.current
    
  AlertDialog(
        onDismissRequest = {
            showToast(ctx, "Se ha cancelado")
        },
        confirmButton = {
            TextButton(onClick = {
                showToast(ctx, "Se ha aceptado")
            }) {
                Text(text = "Confirmar")
            }
        },
        dismissButton = {
            TextButton(onClick = {
                showToast(ctx, "Se ha cancelado")
            }) {
                Text(text = "Cancelar")
            }
        },
        icon = {
            Icon(
                imageVector = Icons.Default.Warning,
                contentDescription = "Advertencia"
            )
        },
        title = { Text(text = "Alert Dialog")},
        text = { Text(text = "Cuerpo del diálogo")}
    )
}

//Función para mostrar mensaje
fun showToast(ctx:Context, txt:String){
   Toast.makeText(ctx,txt,Toast.LENGTH_SHORT).show()
}
</code></pre>
    </section><br><br>

    <p>Con el código anterior, el <span class="r-word">AlertDialog</span> aparecerá siempre, lo cual no es muy útil.
    </p>
    <p>Lo normal es mostrarlo u ocultarlo cuando se produzca una acción del usuario, como pulsar un botón.</p>
    <p>Para <span class="negrita">controlar si se muestra u oculta</span>, necesitas una <span
        class="subrayado">variable almacenada en el estado</span>,
      de forma que cuando cambie, la pantalla se recomponga.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-14-39-36.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <div class="tarea">
      <p>Crea una pantalla de registro que contenga los siguientes elementos:</p>

      <ul>
        <li><span class="negrita">Cabecera</span>: contendrá el título de la pantalla de registro.
          <figure><img src="UD7/images/ud7-2023-11-05-21-12-46.png" /><br>
            <figcaption>Título</figcaption>
          </figure>
          <br>
        </li>

        <li><span class="negrita">Campo Email</span>:
          <ul>
            <li>Validarás que sea un email</li>
            <li>Un icono de sobre al final</li>
            <li>Etiqueta con: user@domain.com</li>
          </ul>
          <figure><img src="UD7/images/ud7-2023-11-05-21-59-59.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>
        </li>

        <li><span class="negrita">Campo nombre, primer apellido y segundo apellido</span>:
          <ul>
            <li>Máximo 15 caracteres, solo letras (mayúsculas, minúsculas, con o sin acentos), espacios para nombres
              compuestos</li>
            <li>Etiqueta explicando qué debe introducir el usuario</li>
          </ul>
          <figure><img src="UD7/images/ud7-2023-11-05-22-03-12.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>
        </li>

        <li><span class="negrita">Campo Teléfono</span>:
          <ul>
            <li>Debe validarse como teléfono</li>
            <li>El teclado solo permitirá números</li>
            <li>Icono de teléfono al final</li>
            <li>Etiqueta obligatoria</li>
          </ul>
        </li>

        <li><span class="negrita">Fecha de nacimiento</span>:
          <ul>
            <li>Será un DatePicker</li>
          </ul>
          <figure><img src="UD7/images/ud7-2023-11-05-22-08-10.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>
        </li>

        <li><span class="negrita">Campo Favoritos</span>:
          <ul>
            <li>Dos listas de FilterChips</li>
            <li>Al seleccionar, aparecerá un icono check</li>
          </ul>
          <figure><img src="UD7/images/ud7-2023-11-05-22-07-16.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>
        </li>

        <li><span class="negrita">Botón limpiar formulario</span>:
          <ul>
            <li>Deshabilitado mientras no haya datos</li>
            <li>Al pulsar, reinicia el formulario</li>
          </ul>
        </li>

        <li><span class="negrita">Botón registrar</span>:
          <ul>
            <li>Se habilita cuando todos los campos tienen datos</li>
            <li>Valida los datos:
              <ul>
                <li>Si todo es correcto, muestra un diálogo
                  <figure><img src="UD7/images/ud7-2023-11-05-22-13-50.png" /><br>
                    <figcaption></figcaption>
                  </figure>
                  <br>
                </li>
                <li>Si no, aparece un mensaje arriba
                  <figure><img src="UD7/images/ud7-2023-11-05-22-14-44.png" /><br>
                    <figcaption></figcaption>
                  </figure>
                  <br>
                </li>
              </ul>
            </li>

            <li><span class="negrita">Parte inferior fija</span>:
              <ul>
                <li>Permanecerá fija abajo; solo la parte del formulario hará scroll</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <p>Aquí tienes un ejemplo de funcionamiento:</p>

      <figure><img src="UD7/images/SignInDemo.gif" /><br>
        <figcaption></figcaption>
      </figure>
      <br>

      <p><a class="enlace" target="_blank"
          href="https://github.com/sdram58/EJEMPLOSPMDM2526/tree/master/UD7/SignUp">Aquí</a> puedes ver el código.</p>

    </div>

  </section><!-- End section Componente AlertDialog-->

  <!--*********************************************************Layout***********************************************************-->
  <section class="apartado">
    <a name="sLayout"></a>
    <h2>Layout</h2>

    <p><span class="negrita">Layout</span> hace referencia al diseño gráfico o distribución de los elementos.</p>

    <p>Es la forma en que colocas los elementos dentro de una interfaz.</p>

    <p>Jetpack Compose proporciona una amplia variedad de componentes para diseñar el layout de cada pantalla de la
      aplicación.</p>

    <p>Ya hemos usado algunos componentes de layout como <span class="cursiva">Surface</span>, <span
        class="cursiva">Column</span> y <span class="cursiva">Row</span>.</p>

    <p>Jetpack Compose ofrece muchos componentes de layout:</p>

    <table>
      <tr>
        <td>Surface</td>
        <td>ConstraintLayout</td>
      </tr>
      <tr>
        <td>Card</td>
        <td>Scaffold</td>
      </tr>
      <tr>
        <td>Box</td>
        <td>TopAppBar</td>
      </tr>
      <tr>
        <td>BoxWithConstraints</td>
        <td>BottomBar</td>
      </tr>
      <tr>
        <td>Column</td>
        <td>NavigationDrawer</td>
      </tr>
      <tr>
        <td>Row</td>
        <td>NavigationRail</td>
      </tr>
      <tr>
        <td>LazyRow y LazyColumn</td>
        <td>Layout</td>
      </tr>
      <tr>
        <td>LazyVerticalGrid y LazyHorizontalGrid</td>
        <td>DropDownMenu</td>
      </tr>
      <tr>
        <td>HorizontalPager y VerticalPager</td>
        <td>BottomSheets y SideSheets</td>
      </tr>
      <tr>
        <td>LazyVerticalStaggeredGrid y LazyHorizontalStaggeredGrid</td>
        <td>...</td>
      </tr>
    </table>

  </section><!-- End section Layout-->

  <!--*********************************************************Componente Surface***********************************************************-->
  <section class="apartado">
    <a name="sComponenteSurface"></a>
    <h2>Componente Surface</h2>

    <p><span class="negrita">Surface</span> es un contenedor con un estilo predefinido que sigue el tema por defecto
      de Material Design.</p>

    <p>El componente <span class="negrita">Surface</span> es el eje central sobre el que se basa la filosofía de
      <span class="negrita">Material Design</span>.
      De hecho, si revisas la documentación de <span class="negrita">Scaffold</span>, verás que internamente utiliza
      una Surface.
    </p>

    <a href="UD7/images/ud_7-2025-01-07-13-30-06.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-13-30-06.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Puedes modificar su estilo por defecto, ya que Surface dispone de parámetros para la forma (shape), elevación
      (elevation), borde (border) y colores para el contenido y el contenedor.</p>

    <p>Se recomienda utilizar Surface como elemento padre de toda la interfaz.</p>

    <p>El componente <span class="negrita">Surface</span> por sí mismo no sirve para organizar elementos de la
      interfaz.</p>

    <a href="UD7/images/ud_7-2025-01-07-13-32-24.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-13-32-24.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Puedes usar Surface tantas veces como necesites, siempre que requieras una superficie diferenciada del resto de
      la UI.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-20-26-32.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Surface por sí sola no organiza los elementos de la UI.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-20-31-58.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En la documentación aparecen todos sus parámetros.</p>

    <figure><img src="UD7/images/ud7-2023-10-24-20-34-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Dentro del contenido de <span class="negrita">Surface</span> debes usar otro componente de layout como
      <span class="cursiva">Row</span> o <span class="cursiva">Column</span>…
    </p>

  </section><!-- End section Componente Surface-->

  <!--*********************************************************Componente Card***********************************************************-->
  <section class="apartado">
    <a name="sComponenteCard"></a>
    <h2>Componente Card</h2>

    <p>El componente <span class="r-word">Card</span> es un <span class="cursiva">Surface</span> con un estilo
      predefinido
      (que puede modificarse mediante parámetros) para parecer una tarjeta, con <span class="negrita">bordes</span>,
      <span class="negrita">elevación</span> y <span class="negrita">sombras</span>.
    </p>

    <p>Hay tres tipos: <span class="negrita">Card</span>, <span class="negrita">ElevatedCard</span> y
      <span class="negrita">OutlinedCard</span>.
    </p>

    <p>Dentro de una Card, los elementos se organizan en una columna (<span class="negrita">ColumnScope</span>).</p>

    <figure><img src="UD7/images/ud7-2023-10-24-20-38-23.png" /><br>
      <figcaption>Ejemplos de Card</figcaption>
    </figure>
    <br>

  </section><!-- End section Componente Card-->

  <!--*********************************************************Componente Box***********************************************************-->
  <section class="apartado">
    <a name="sComponenteBox"></a>
    <h2>Componente Box</h2>

    <p>El componente <span class="r-word">Box</span> permite colocar varios elementos en el mismo lugar, uno encima de
      otro.</p>

    <p>Un posible caso de uso sería mostrar un contenido u otro cuando se pulsa un botón.</p>

    <a href="UD7/images/ud_7-2025-01-07-13-44-22.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-13-44-22.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <h3>Componente BoxWithConstraints</h3>

    <p>El componente <span class="r-word">BoxWithConstraints</span> es una versión especial de Box que proporciona las
      dimensiones del propio componente a su contenido para que puedas usarlas si lo necesitas.</p>

    <a href="UD7/images/ud_7-2025-01-07-13-45-38.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-13-45-38.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

  </section><!-- End section Componente Box-->

  <!--*********************************************************Componentes Column y Row***********************************************************-->
  <section class="apartado">
    <a name="sComponentesColumnyRow"></a>
    <h2>Componentes Column y Row</h2>

    <p>Los componentes <span class="r-word">Column</span> y <span class="r-word">Row</span> ya se han utilizado
      anteriormente.</p>

    <p>Para alinear contenido vertical u horizontalmente dentro de ellos, se usan:</p>
    <ul>
      <li><span class="negrita">Arrangement</span>: eje principal (columnas → vertical, filas → horizontal).</li>
      <li><span class="negrita">Alignment</span>: eje transversal (columnas → horizontal, filas → vertical).</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-24-20-51-08.png" /><br>
      <figcaption>Ejemplos de Column y Row</figcaption>
    </figure>
    <br>

    <h3>Arrangement</h3>

    <p>Tipos de Arrangement:</p>
    <ul>
      <li><span class="negrita">Center</span>: centrado.</li>
      <li><span class="negrita">SpaceEvenly</span>: mismo espacio entre todos los elementos y también en los extremos.
      </li>
      <li><span class="negrita">SpaceBetween</span>: mismo espacio entre elementos, pero sin espacio arriba ni abajo.
      </li>
      <li><span class="negrita">SpaceAround</span>: mismo espacio por encima y por debajo de cada elemento (entre
        elementos hay el doble).</li>
      <li><span class="negrita">spacedBy</span>: permite indicar el espacio entre elementos en dp.</li>
      <li><span class="negrita">Top</span>: alineado arriba → solo columnas.</li>
      <li><span class="negrita">Bottom</span>: alineado abajo → solo columnas.</li>
      <li><span class="negrita">End</span>: alineado al final según la dirección de lectura → solo filas.</li>
      <li><span class="negrita">Start</span>: alineado al inicio según la dirección de lectura → solo filas.</li>
    </ul>

    <figure><img src="UD7/images/ud7-2023-10-25-09-26-24.png" /><br>
      <figcaption>Ejemplo de Arrangement</figcaption>
    </figure>
    <br>

    <p>Si no especificas <span class="negrita">Arrangement</span>, puedes usar <span class="negrita">weight()</span>
      para indicar el espacio proporcional.</p>

    <figure><img src="UD7/images/ud7-2023-10-25-09-27-58.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Alignment</h3>

    <p><span class="negrita">Alignment</span> controla el eje transversal:</p>

    <ul>
      <li><span class="negrita">Start</span>: alineado al inicio de la línea → solo columnas.</li>
      <li><span class="negrita">End</span>: alineado al final de la línea → solo columnas.</li>
      <li><span class="negrita">CenterHorizontally</span>: centrado horizontalmente → solo columnas.</li>
      <li><span class="negrita">Top</span>: arriba → solo filas.</li>
      <li><span class="negrita">Bottom</span>: abajo → solo filas.</li>
      <li><span class="negrita">CenterVertically</span>: centrado verticalmente → solo filas.</li>
    </ul>

    <h3>Componentes Flow</h3>

    <p>Los componentes <span class="r-word">FlowColumn</span> y <span class="r-word">FlowRow</span> son similares a
      <span class="negrita">Column</span> y <span class="negrita">Row</span>, pero pasarán los elementos a una nueva
      columna o fila
      cuando ya no quepan en una sola.
    </p>

    <section>
      <pre><code class="language-kotlin">val textList = listOf("Precio Descendiente", "Precio Ascendente", "Puntuación 4+", "Ofertas", "Más vendidos")

FlowRow(
    horizontalArrangement = Arrangement.spacedBy(24.dp),
    modifier = Modifier.padding(8.dp),
    //maxItemsInEachRow = 2
) {
    textList.forEach{
        Text(
            text = it,
            modifier = Modifier
                .padding(4.dp)
                .background(Color.LightGray)
                .padding(4.dp)
        )
    }
}
</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-10-25-09-40-05.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componentes Column y Row-->


  <!--*********************************************************Scroll***********************************************************-->
  <section class="apartado">
    <a name="sScroll"></a>
    <h2>Scroll</h2>

    <p>Como se ha visto hasta ahora, cuando hay demasiados componentes en la pantalla, algunos pueden quedar fuera de
      la vista del usuario
      (más allá de la zona visible de la pantalla).</p>

    <p>Cuando hablamos del parámetro <span class="negrita">modifier</span>, mencionamos que si el contenido de un
      componente no cabe en la pantalla, puedes usar los modificadores <span class="negrita">verticalScroll</span> y
      <span class="negrita">horizontalScroll</span> para desplazarte y acceder a todo.
      Sin embargo, este enfoque no es ideal porque <span class="subrayado">carga todo el contenido del componente en
        la RAM, independientemente de si es visible</span>.
    </p>

    <p>Los componentes <span class="negrita">Lazy</span> descritos a continuación solucionan este problema.</p>

    <p>Los componentes <span class="negrita">Lazy</span> incluyen automáticamente un parámetro que, por defecto, crea
      un estado <span class="negrita">rememberSaveable</span>
      para gestionar el scroll automáticamente.</p>


    <h3>Componentes Lazy</h3>

    <p>Los componentes <span class="r-word">Lazy</span> te permiten mostrar elementos en una lista o en una
      cuadrícula, tanto horizontal como verticalmente.</p>

    <p>Los componentes <span class="negrita">Lazy</span> ofrecen dos ventajas principales:
    <ul>
      <li>Si el contenido no cabe en la pantalla, puedes hacer scroll sin configuraciones adicionales.</li>
      <li>Solo cargan los elementos visibles (más uno previo y otro siguiente), por lo que se usa la memoria de manera
        más eficiente.</li>
    </ul>
    </p>

    <p>Los componentes <span class="negrita">Lazy</span> disponibles son:
    <ul>
      <li><span class="negrita">LazyColumn y LazyRow.</span></li>
      <li><span class="negrita">LazyVerticalGrid y LazyHorizontalGrid.</span></li>
      <li><span class="negrita">LazyVerticalStaggeredGrid y LazyHorizontalStaggeredGrid.</span></li>
    </ul>
    </p>

    <p>Todos los componentes <span class="negrita">Lazy</span> tienen algunos parámetros comunes:
    <ul>
      <li><span class="negrita">reverseLayout</span>: booleano que indica si mostrar los elementos en orden inverso;
        por defecto es false.</li>
      <li><span class="negrita">userScrollEnabled</span>: booleano que indica si el scroll está habilitado; por
        defecto es true.</li>
    </ul>
    </p>

    <p>Los componentes Lazy Grid tienen parámetros adicionales:
    <ul>
      <li><span class="negrita">columns</span>: para una cuadrícula vertical, establece el número de columnas.</li>
      <li><span class="negrita">rows</span>: para una cuadrícula horizontal, establece el número de filas.</li>
    </ul>
    </p>

    <p>Para añadir contenido en elementos Lazy, puedes usar:
    <ul>
      <li><span class="negrita">item</span>: añade un único elemento al componente Lazy.</li>
      <li><span class="negrita">items</span>: recorre una lista, añadiendo cada elemento al componente Lazy.</li>
    </ul>
    </p>

    <p class="sub-section">Componente LazyColumn</p>
    <p>Ejemplo:</p>

    <section>
      <pre><code class="language-kotlin">val dragonBallCharacters = listOf(
    "Son Goku",
    "vegeta",
    "Piccolo",
    "Son Gohan",
    "Trunks",
    "Bulma",
    "Krillin",
    "Master Roshi",
    "Freezer",
    "Cell"
)

LazyColumn(
    modifier = Modifier.padding(5.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)){
    item {
        OutlinedCard(
            modifier = Modifier
                .background(Color.DarkGray)
                .padding(8.dp)
                .fillMaxWidth()
        ) {
            Text(text = "Personajes",
                  fontWeight = FontWeight.Bold,
                  modifier = Modifier.padding(8.dp)
            )
        }
    }
    items(dragonBallCharacters){character ->
        Card(modifier = Modifier
            .background(Color(0xFF666666))
            .padding(8.dp)
            .fillMaxWidth(),
              colors = CardDefaults.cardColors(
                  containerColor = Color(0xFFF67979)
              )
        ) {
            Text(
                text = character,
                color = Color.White,
                modifier = Modifier
                    .height(80.dp)
                    .padding(8.dp)
            )
        }
    }
}
</code></pre>
    </section><br><br>

    <p>Esto podría verse así:</p>
    <figure><img src="UD7/images/ud7-2023-10-25-10-17-38.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p class="sub-section">Componente LazyRow</p>

    <p>Ejemplo:</p>

    <figure><img src="UD7/images/ud7-2023-10-25-10-18-49.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p class="sub-section">StickyHeaders con LazyColumn y LazyRow</p>

    <p>Una característica común en <span class="negrita">LazyColumn</span> y <span class="negrita">LazyRow</span> son
      los encabezados “pegajosos” (<span class="r-word">StickyHeaders</span>), usados en la aplicación de Contactos.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-25-10-21-24.png" /><br>
      <figcaption>StickyHeaders</figcaption>
    </figure>
    <br>

    <p>Para utilizar estos encabezados, aplicas <span class="negrita">stickyHeader</span> y agrupas los elementos
      mostrados bajo algún criterio, como la primera letra.</p>

    <figure><img src="UD7/images/ud7-2023-10-25-10-22-09.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>De este modo tienes un Map para recorrer y rellenar el contenido de la lista.</p>

    <section>
      <pre><code class="language-kotlin">val dragonBallCharacters = listOf(
    "Son Goku",
    "vegeta",
    "Piccolo",
    "Son Gohan",
    "Trunks",
    "Bulma",
    "Krillin",
    "Master Roshi",
    "Freezer",
    "Cell"
)

LazyColumn(
    modifier = Modifier.padding(5.dp),
    verticalArrangement = Arrangement.spacedBy(8.dp)){
        val groupCharacters: Map&lt;Char, List&lt;String>> = dragonBallCharacters.sorted().groupBy {
            it[0]
        }

        groupCharacters.forEach() { header, names ->
            stickyHeader {
                Text(
                    text = header.toString(),
                    fontSize = 30.sp,
                    color = Color.Blue,
                    textAlign = TextAlign.Center,
                    modifier = Modifier
                        .background(Color.LightGray)
                        .fillMaxWidth()
                )
                Divider(
                    color = Color.Black,
                    thickness = 1.dp
                )
            }
            items(names){name ->
                Text(
                    text = name,
                    modifier = Modifier
                        .padding(start= 40.dp,top= 4.dp, bottom = 4.dp)
                )
        }

    }
}
</code></pre>
    </section><br><br>

    <section class="marco-t warn oculto">
      <span class="icono warning"> </span> stickyHeader todavía está en modo experimental, así que debes añadir la
      anotación en el componente.
    </section>
    <section class="marco-b oculto">
      <section>
        <pre><code class="language-kotlin">@OptIn(ExperimentalFoundationApi::class)</code></pre>
      </section>
    </section>

    <p>El resultado se vería así:</p>
    <a href="UD7/images/ud7-2023-10-25-10-57-32.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-10-57-32.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <h3>Componentes LazyVerticalGrid y LazyHorizontalGrid</h3>

    <p>Usando <span class="r-word">LazyVerticalGrid</span> y <span class="r-word">LazyHorizontalGrid</span>, puedes
      organizar elementos en columnas o filas, respectivamente.</p>

    <p>Todos los <span class="negrita">elementos ocupan el mismo espacio</span>, concretamente <span class="negrita">el
        del elemento más grande</span>.</p>

    <p>
      Para definir el número de columnas en <span class="negrita">LazyVerticalGrid</span> se usa <span
        class="negrita">columns</span>.
      Para definir el número de filas en <span class="negrita">LazyHorizontalGrid</span> se usa <span
        class="negrita">rows</span>.
      Estas propiedades pueden ser:
    <ul>
      <li><span class="cursiva">GridCells.Fixed(number_of_columns/rows)</span></li>
      <li><span class="cursiva">GridCells.Adaptative(minimum_column/row_size.dp)</span></li>
    </ul>
    </p>

    <p class="sub-section">Componente LazyVerticalGrid</p>
    <p>Ejemplo:</p>

    <a href="UD7/images/ud7-2023-10-25-11-02-12.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-11-02-12.png" /><br>
        <figcaption>LazyVerticalGrid</figcaption>
      </figure>
    </a>
    <br>

    <p class="sub-section">Componente LazyHorizontalGrid</p>

    <a href="UD7/images/ud7-2023-10-25-11-03-39.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-11-03-39.png" /><br>
        <figcaption>LazyHorizontalGrid</figcaption>
      </figure>
    </a>
    <br>

    <h3>Componentes Staggered</h3>

    <p>Los componentes <span class="r-word">LazyVerticalStaggeredGrid</span> y <span
        class="r-word">LazyHorizontalStaggeredGrid</span>
      son similares a los anteriores, pero cada elemento ocupa únicamente el espacio que necesita su contenido.</p>

    <p>Parámetros principales de <span class="negrita">LazyVerticalStaggeredGrid</span>:
    <ul>
      <li><span class="negrita">columns</span>: número de columnas</li>
      <li><span class="negrita">verticalSpacing</span>: espacio vertical entre elementos</li>
      <li><span class="negrita">horizontalArrangment</span>: espacio horizontal entre elementos</li>
    </ul>
    </p>

    <p>Parámetros principales de <span class="negrita">LazyHorizontalStaggeredGrid</span>:
    <ul>
      <li><span class="negrita">rows</span>: número de filas</li>
      <li><span class="negrita">horizontalSpacing</span>: espacio horizontal entre elementos</li>
      <li><span class="negrita">verticalArrangment</span>: espacio vertical entre elementos</li>
    </ul>
    </p>

    <p>El número de filas o columnas se especifica con:
    <ul>
      <li><span class="cursiva">StaggeredGridCells.Fixed(number_of_columns/rows)</span></li>
      <li><span class="cursiva">StaggeredGridCells.Adaptative(minimum_column/row_size.dp)</span></li>
    </ul>
    </p>

    <p class="sub-section">Componente LazyVerticalStaggeredGrid</p>
    <p>Ejemplo:</p><a href="UD7/images/ud7-2023-10-25-11-07-28.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-11-07-28.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p class="sub-section">Componente LazyHorizontalStaggeredGrid</p>
    <p>Ejemplo:</p><a href="UD7/images/ud7-2023-10-25-11-08-30.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-11-08-30.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <h3>Gestión del estado en componentes Lazy</h3>

    <p>Como se vio en la definición de los componentes Lazy, Android gestiona automáticamente el estado del scroll:
    </p>

    <a href="UD7/images/ud7-2023-10-25-11-10-16.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-11-10-16.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Puede resultar útil crear tu propia variable para gestionar el estado, de modo que puedas comprobar, por
      ejemplo:
    <ul>
      <li>La dirección en la que hace scroll el usuario.</li>
      <li>La cantidad de scroll realizada.</li>
      <li>El índice del primer elemento visible.</li>
      <li>…</li>
    </ul>
    </p>

    <p>Aquí tienes un ejemplo:</p>

    <section>
      <pre><code class="language-kotlin">Column(
    modifier = Modifier.fillMaxSize()
) {
    val dragonBallCharacters = listOf(
        "Son Goku",
        "vegeta",
        "Piccolo",
        "Son Gohan",
        "Trunks",
        "Bulma",
        "Krillin",
        "Master Roshi",
        "Freezer",
        "Cell"
    )

    val scrollState = rememberLazyStaggeredGridState()

    val showEndTextGrid by remember {
        derivedStateOf {
            scrollState.firstVisibleItemIndex > 0
        }
    }

    val coroutineGridScope = rememberCoroutineScope()
    
    LazyVerticalStaggeredGrid(
        columns = StaggeredGridCells.Fixed(3),
        verticalItemSpacing = 8.dp,
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        state = scrollState,
        modifier = Modifier.weight(3f)

    ) {
        item {
            OutlinedCard(
                modifier = Modifier
                    .background(Color.DarkGray)
                    .padding(8.dp)
                    .fillMaxWidth()
            ) {
                Text(
                    text = "Personajes",
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(8.dp)
                )
            }
        }
        items(dragonBallCharacters) { character ->
            val randomHeight = ((2..30).random() * 15).dp
            Card(
                modifier = Modifier
                    .background(Color.LightGray)
                    .padding(8.dp)
                    .fillMaxWidth()
                    .height(randomHeight)
            ) {
                Text(
                    text = character,
                    modifier = Modifier
                        .height(80.dp)
                        .padding(8.dp)
                )
            }
        }


    }
    if (showEndTextGrid) {
        Button(
            modifier = Modifier
                .weight(0.5f)
                .fillMaxWidth(),
            onClick = {
                coroutineGridScope.launch {
                    scrollState.animateScrollToItem(0, 0)
                }
            }) {
            Text(text = "Volver arriba")
        }
    }
}
</code></pre>
    </section><br><br>

    <a href="UD7/images/EjemploLazyStaggerdState.gif" target="_BLANK">
      <figure><img src="UD7/images/EjemploLazyStaggerdState.gif" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>En el ejemplo, se crea un estado personalizado para gestionar el scroll de <span
        class="cursiva">LazyVerticalStaggeredGrid</span> y se asigna al componente.</p>

    <p>También creamos un estado para mostrar u ocultar un botón. Este estado depende del anterior, por lo que usamos
      <span class="negrita">derivedStateOf</span>.
    </p>

    <p>El estado del botón cambia cuando el primer elemento de la lista deja de ser completamente visible.</p>

    <p>Finalmente, el botón utiliza una <span class="cursiva">corrutina</span> (que se explicará más adelante) para
      desplazar el scroll hasta el primer elemento de la lista.</p>

  </section><!-- End section Scroll-->



  <!--*********************************************************Componente ListItem***********************************************************-->
  <section class="apartado">
    <a name="sComponenteListItem"></a>
    <h2>Componente ListItem</h2>

    <p>Aunque en una columna de cualquier tipo puedes añadir cualquier tipo de componente, Jetpack Compose ofrece el
      componente
      <span class="r-word">ListItem</span> para proporcionar un estilo uniforme a los elementos de una lista.
    </p>

    <p>Un <span class="negrita">ListItem</span> tiene cinco zonas. Normalmente, en la zona
      <span class="negrita">leadingContent</span> se coloca un icono o imagen. En
      <span class="negrita">trailingContent</span> también es frecuente colocar un icono o texto.
    </p>

    <p>Si hay contenido en la zona <span class="negrita">overLineContent</span>, el contenido de
      <span class="negrita">leadingContent</span> y <span class="negrita">trailingContent</span>
      se alineará en la parte superior; si no hay <span class="negrita">overLineContent</span>, se alinearán centrados
      verticalmente.
    </p>

    <p>Definición del componente:</p>
    <a href="UD7/images/ud7-2023-10-25-12-55-45.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-12-55-45.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Ejemplo:</p>
    <a href="UD7/images/ud7-2023-10-25-12-56-09.png" target="_BLANK">
      <figure><img src="UD7/images/ud7-2023-10-25-12-56-09.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <section class="marco-t warn">
      <span class="icono warning"> </span> ¡ATENCIÓN! Ahora todas las propiedades que antes terminaban en "Content"
      terminan en "Text".
    </section>
    <section class="marco-b">
      <a href="UD7/images/ud7-2023-11-29-12-44-54.png" target="_BLANK">
        <figure><img src="UD7/images/ud7-2023-11-29-12-44-54.png" /><br>
          <figcaption></figcaption>
        </figure>
      </a>
      <br>
    </section>

  </section><!-- End section Componente ListItem-->



  <!--*********************************************************Componente Scaffold***********************************************************-->
  <section class="apartado">
    <a name="sComponenteScaffold"></a>
    <h2>Componente Scaffold</h2>

    <p>El componente <span class="r-word">Scaffold</span> es una estructura por defecto que proporciona Jetpack
      Compose
      para crear interfaces complejas siguiendo los principios de Material.</p>

    <p>Incorpora varios componentes comunes como:
    <ul>
      <li><span class="negrita">topBar</span>: barra de navegación superior.</li>
      <li><span class="negrita">bottomBar</span>: barra de navegación inferior.</li>
      <li><span class="negrita">snackbarHost</span>: permite mostrar mensajes que reemplazan a los antiguos Toasts.
      </li>
      <li><span class="negrita">floatingActionButton</span>: un icono flotante generalmente ubicado en la parte
        inferior de la
        pantalla.</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-13-37.png" /><br>
      <figcaption>Definición de Scaffold</figcaption>
    </figure>
    <br>

    <p>El único parámetro obligatorio es <span class="negrita">content</span>, y al ser el último parámetro y una
      lambda,
      puede sacarse de los paréntesis.</p>

    <p>Como se vio anteriormente, un proyecto de Android Studio utiliza el componente <span
        class="negrita">Scaffold</span> por defecto.</p>

    <a href="UD7/images/ud_7-2025-01-07-14-19-10.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-14-19-10.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>Si decides usar Scaffold, debes elegir una de las siguientes opciones:
    <ul>
      <li>Hacer que el <span class="negrita">Scaffold</span> sea el <span class="subrayado">único hijo del
          <span class="negrita">Surface</span> principal</span> en el proyecto, y añadir el resto de componentes
        dentro del
        <span class="negrita">Scaffold</span>.
      </li>

      <li><span class="subrayado">Reemplazar el <span class="negrita">Surface</span> principal por un
          <span class="negrita">Scaffold</span></span> y añadir los demás componentes allí.</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-15-34.png" /><br>
      <figcaption>Estructura de Scaffold</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-30-17-16-19.png" /><br>
      <figcaption>Ejemplo de Scaffold</figcaption>
    </figure>
    <br>

    <p>Como puedes ver, los parámetros <span class="negrita">topBar</span>, <span class="negrita">bottomBar</span>,
      <span class="negrita">snackbarHost</span> y <span class="negrita">floatingActionButton</span> son de tipo
      <span class="r-word">@Composable</span>, por lo que puedes incluir cualquier componente de Jetpack Compose
      dentro de ellos.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-24-27.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Con esto, puedes personalizar <span class="r-word">Scaffold</span> como quieras.</p>

    <p>Jetpack Compose ofrece un conjunto de <span class="subrayado">componentes específicos</span> para esos
      parámetros,
      y es recomendable usarlos. También puedes configurar estos
      <span class="subrayado">parámetros</span> para personalizar la interfaz. Estos componentes pueden usarse sin un
      Scaffold.
    </p>


    <h3>Componente TopAppBar</h3>

    <p>El componente <span class="r-word">TopAppBar</span> permite crear una barra superior con un título e iconos
      para
      realizar acciones.</p>

    <p>El único parámetro obligatorio es <span class="negrita">title</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-27-25.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Existen tres versiones adicionales de topBar:
    <ul>
      <li><span class="negrita">CenterAlignedTopAppBar</span>: igual que TopAppBar pero con el título centrado.</li>
      <li><span class="negrita">MediumTopAppBar</span>: el título se sitúa una línea más abajo.</li>
      <li><span class="negrita">LargeTopAppBar</span>: similar a MediumTopAppBar pero con un título más grande.</li>
    </ul>
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-28-43.png" /><br>
      <figcaption>Definición de TopAppBar</figcaption>
    </figure>
    <br>

    <p>Aquí tienes un ejemplo de configuración:</p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-29-22.png" /><br>
      <figcaption>Ejemplo de TopAppBar</figcaption>
    </figure>
    <br>

    <p>El resultado sería algo así:</p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-30-27.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente DropDownMenu</h3>

    <p>Es común que un <span class="negrita">TopAppBar</span> tenga un icono que abra un menú desplegable,
      ya sea como <span class="negrita">navigationIcon</span> o entre los iconos de acciones.</p>

    <p>Creas este menú con los componentes <span class="r-word">DropdownMenu</span> y
      <span class="r-word">DropdownMenuItem</span>.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-32-02.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Podría tener un aspecto similar a este:</p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-33-15.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente FloatingActionButton</h3>

    <p>Los <span class="r-word">FloatingActionButton</span> (FAB) son botones que representan la acción más importante
      de
      una pantalla. Tienen un estilo predefinido y normalmente flotan sobre otros elementos.</p>

    <p>Se usan principalmente con el layout Scaffold, pero pueden utilizarse de forma independiente.</p>

    <p>Hay cuatro versiones del componente:
    <ul>
      <li><span class="negrita">FloatingActionButton</span>: solo contiene un icono.</li>
      <li><span class="negrita">SmallFloatingActionButton</span>: tiene un icono y es para pantallas pequeñas.</li>
      <li><span class="negrita">LargeFloatingActionButton</span>: tiene un icono y es para pantallas grandes.</li>
      <li><span class="negrita">ExtendedFloatingActionButton</span>: incluye icono y texto, usado cuando un FAB
        necesita más información.</li>
    </ul>
    </p>

    <p>En un <span class="negrita">Scaffold</span>, puedes añadir un <span class="r-word">FloatingActionButton</span>
      situado en la parte inferior del contenido.
      Puedes especificar si aparece centrado o al final (según la dirección de lectura del idioma configurado).</p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-36-47.png" /><br>
      <figcaption>Ejemplo de FloatingActionButton</figcaption>
    </figure>
    <br>

    <h3>Componente BottomBar</h3>

    <p>Una <span class="r-word">BottomBar</span> es una barra situada en la parte inferior que contiene iconos
      normalmente usados
      para <span class="negrita">cambiar el contenido del Scaffold</span>.</p>

    <p>Hay tres opciones para crear una BottomBar:
    <ul>
      <li><span class="negrita">BottomAppBar</span>: con iconos y/o texto.</li>
      <li><span class="negrita">BottomAppBar</span>: con iconos y FloatingActionButton.</li>
      <li><span class="negrita">NavigationBar</span>: barra con tres, cuatro o cinco iconos.</li>
    </ul>
    </p>

    <p>En una <span class="r-word">NavigationBar</span>, usas <span class="negrita">NavigationBarItem</span>
      para crear los elementos de navegación.</p>

    <p>Si lo deseas, puedes usar <span class="r-word">NavigationBarItem</span> dentro de una
      <span class="r-word">BottomAppBar</span> también.
    </p>

    <p class="sub-section">BottomAppBar</p>

    <p>Si usas <span class="r-word">BottomAppBar</span> con <span class="negrita">iconos</span> o
      <span class="negrita">texto</span>, estos se alinean a la izquierda. Si usas
      <span class="negrita">NavigationBarItem</span>, se centran en el espacio disponible.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-40-37.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-30-17-40-56.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="r-word">BottomAppBar</span> tiene un constructor con los parámetros <span
        class="negrita">actions</span>
      y <span class="negrita">floatingActionButton</span>.</p>

    <p>Si el <span class="negrita">Scaffold</span> está configurado con el parámetro
      <span class="negrita">floatingActionButton</span>, <span class="negrita">no debes usar una BottomBar
        con un floatingActionButton</span>.
    </p>

    <figure><img src="UD7/images/ud7-2023-10-30-17-42-35.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-30-17-42-59.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="negrita">NavigationBar</span> con elementos <span class="negrita">NavigationBarItem</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-07-44.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-31-14-08-14.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <h3>Componente SnackBar</h3>

    <p>Las <span class="r-word">Snackbars</span> son mensajes temporales que aparecen en la parte inferior de la
      pantalla.</p>

    <p>Para crear una <span class="r-word">Snackbar</span>, necesitas un estado:</p>

    <section>
      <pre><code class="language-kotlin">val snackBarHostState = remember {SnackBarHostState()}</code></pre>
    </section><br><br>

    <p>En el Scaffold, lo configuras en el parámetro <span class="negrita">snackbarHost</span>, donde puedes
      personalizar
      el estilo de la Snackbar:</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-11-56.png" /><br>
      <figcaption>SnackBar por defecto</figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-31-14-12-34.png" /><br>
      <figcaption>SnackBar personalizada</figcaption>
    </figure>
    <br>

    <p>Necesitas una corrutina para mostrar la <span class="negrita">Snackbar</span> (esto se explicará más adelante).
    </p>

    <section>
      <pre><code class="language-kotlin">val coroutineScope = rememberCoroutineScope()</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-10-31-14-14-47.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>En cualquier parte de la interfaz donde puedas ejecutar un bloque de instrucciones, la Snackbar puede lanzarse
      con cualquier mensaje que desees.</p>

  </section><!-- End section Componente Scaffold-->



  <!--*********************************************************Componente ConstraintLayout***********************************************************-->
  <section class="apartado">
    <a name="sComponenteConstraintLayout"></a>
    <h2>Componente ConstraintLayout</h2>

    <p>Todos los layouts estudiados hasta ahora gestionan automáticamente la posición de los elementos.</p>

    <p>El componente <span class="r-word">ConstraintLayout</span> te permite organizar elementos en la pantalla
      <span class="subrayado">especificando explícitamente</span> cómo están vinculados entre sí.
    </p>

    <p>De este modo, esas <span class="negrita">restricciones</span> permanecen intactas aunque cambie la orientación
      de la pantalla o el dispositivo tenga un tamaño diferente.</p>

    <p>Este layout es muy usado en <span class="negrita">vistas antiguas basadas en XML</span>, por lo que es
      importante conocerlo para posibles migraciones desde XML a Jetpack Compose.</p>

    <p>También es importante conocerlo porque ofrece mucha libertad al crear interfaces de usuario en Android.</p>

    <p>Para usar este componente, primero debes añadir una dependencia:
    <ul>
      <li>
        <span class="inline-file">libs.versions.toml</span>
        <ul>
          <li>Sección <span class="cursiva">[versions]</span>. <br><img style="vertical-align: baseline"
              src="UD7/images/ud_7-2025-01-07-14-35-34.png" /></li>
          <li>Sección <span class="cursiva">[libraries]</span>. <br><img style="vertical-align: baseline"
              src="UD7/images/ud_7-2025-01-07-14-35-54.png" /></li>
        </ul>
      </li>
      <li>
        <span class="inline-file">build.gradle.kts (Module: app)</span>
        <ul>
          <li>Sección dependencies: <br><img style="vertical-align: baseline"
              src="UD7/images/ud_7-2025-01-07-14-38-43.png" /></li>
        </ul>
      </li>
    </ul>
    </p>

    <p>Recuerda hacer <span class="d-word">sync gradle</span> y ya podrás usar <span
        class="negrita">ConstraintLayout</span>.</p>

    <p>Después de añadir la dependencia, puedes usar el componente <span class="r-word">ConstraintLayout</span>
      y añadir todos los componentes y sus restricciones dentro de él.</p>

    <p>Para que los componentes puedan vincularse entre sí, cada uno debe tener alguna referencia que puedas utilizar.
    </p>

    <p>Puedes crear referencias una a una o en grupo.</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-24-51.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Una vez creadas las referencias, puedes asignarlas a los componentes del <span
        class="negrita">ConstraintLayout</span>.</p>

    <p>Para asignar una referencia a un componente, usas el modificador <span class="r-word">constrainAs</span>.</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-26-32.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Una vez asignadas las referencias, puedes indicar cómo se enlazan los elementos entre sí dentro del layout.</p>

    <p>Los elementos pueden vincularse entre ellos o al contenedor, el propio <span
        class="negrita">ConstraintLayout</span>.
      La referencia del contenedor se llama <span class="negrita">parent</span>.</p>

    <p>Para crear estos enlaces, debes conocer los puntos a los que puedes vincularte.</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-28-43.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Los puntos <span class="negrita">start</span> y <span class="negrita">end</span> dependen de la dirección de
      lectura
      establecida para el idioma del dispositivo.</p>

    <p>Un ejemplo de escenario:</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-30-24.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <figure><img src="UD7/images/ud7-2023-10-31-14-31-10.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>El resultado podría ser así:</p>

    <figure><img src="UD7/images/ud7-2023-10-31-14-31-48.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Dentro de <span class="negrita">ConstraintLayout</span>, puedes crear guías para que otros componentes se
      anclen a ellas.</p>

    <p>Las guías pueden usar <span class="negrita">porcentajes</span> (float de 0 a 1) o valores en <span
        class="negrita">dp</span>.</p>

    <figure><img src="UD7/images/ud7-2023-11-04-21-21-28.png" /><br>
      <figcaption></figcaption>
    </figure>

    <br>

    <figure><img src="UD7/images/ud7-2023-11-04-21-22-01.png" /><br>
      <figcaption></figcaption>
    </figure>

    <br>

    <figure><img src="UD7/images/ud7-2023-11-04-21-22-20.png" /><br>
      <figcaption></figcaption>
    </figure>

    <br>

    <p>También puedes crear <span class="negrita">barreras</span> con dos o más componentes que sirven como guía para
      que otros componentes se anclen. <br>
      Ejemplo:</p>

    <section>
      <pre><code class="language-kotlin">ConstraintLayout(modifier = Modifier.fillMaxSize()){
    val (lightBox, darkBox, blackBox) = createRefs()
    val barrier = createEndBarrier(lightBox, darkBox)

    Box(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .constrainAs(lightBox){
                top.linkTo(parent.top, 20.dp)
            }
    )
    Box(
        modifier = Modifier
            .background(Color.DarkGray)
            .size(50.dp)
            .constrainAs(darkBox){
                top.linkTo(lightBox.bottom)
                start.linkTo(parent.start, 80.dp)
            }
    )
    Box(
        modifier = Modifier
            .background(Color.Black)
            .size(50.dp)
            .constrainAs(blackBox){
                top.linkTo(parent.top, 150.dp)
                start.linkTo(barrier)
            }
    )
}</code></pre>
    </section><br><br>

    <p>El resultado sería algo así:</p>

    <figure><img src="UD7/images/ud7-2023-11-05-19-08-46.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Si movemos la caja <span class="cursiva">darkGray</span> hacia la izquierda, quedaría así:</p>

    <section>
      <pre><code class="language-kotlin">Box(
    modifier = Modifier
        .background(Color.DarkGray)
        .size(50.dp)
        .constrainAs(darkBox){
            top.linkTo(lightBox.bottom)
            start.linkTo(parent.start, 10.dp)
        }
)</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-11-05-19-11-27.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <section class="marco-t inf">
      <span class="icono info"> </span> La barrera es imaginaria.
    </section>

    <section class="marco-b"></section>

  </section><!-- End section Componente ConstraintLayout-->


  <!--*********************************************************Componentes Modal***********************************************************-->
  <section class="apartado">
    <a name="sComponentesModal"></a>
    <h2>Componentes Modal</h2>

    <p>Los componentes <span class="r-word">Modal</span> son aquellos que aparecen por encima de la pantalla. Existen
      varios:
    <ul>
      <li>ModalNavigationDrawer</li>
      <li>ModalBottomSheet</li>
      <li>ModalSideSheet</li>
      <li>...</li>
    </ul>
    </p>

    <p>El más conocido es <span class="r-word">ModalNavigationDrawer</span>, también llamado
      <span class="negrita">menú hamburguesa</span>, el cual aparece como un menú lateral al tocarlo.
    </p>

    <a href="UD7/images/ud_7-2025-01-07-14-47-52.png" target="_BLANK">
      <figure><img src="UD7/images/ud_7-2025-01-07-14-47-52.png" /><br>
        <figcaption></figcaption>
      </figure>
    </a>
    <br>

    <p>En dispositivos con pantallas grandes, este menú debe ser reemplazado por otro que permanezca visible de forma
      permanente, como un <span class="negrita">NavigationDrawer</span> o un <span
        class="negrita">NavigationRail</span>.</p>

    <p>A continuación se muestra un ejemplo de cómo usarlo, para que puedas entender cómo funciona. Ten en cuenta que
      algunos conceptos (como corrutinas y navegación) se explicarán más adelante.</p>

    <section>
      <pre><code class="language-kotlin">sealed class Options(val title:String, val icon:ImageVector){
    object Option1 :Options("Inicio", Icons.Default.Home)
    object Option2 :Options("Editar", Icons.Default.Edit)
    object Option3 :Options("Configuración", Icons.Default.Settings)
    object Option4 :Options("Ayuda", Icons.Default.Help)
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun Content() {
    val options = listOf&lt;Options>(Options.Option1,Options.Option2, Options.Option3, Options.Option4)
    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
    var selectedOption by rememberSaveable {
        mutableStateOf(options[0].title)
    }
    val scope = rememberCoroutineScope()
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = selectedOption) },
                navigationIcon = {
                    IconButton(onClick = {
                        if(drawerState.isOpen) scope.launch { drawerState.close()}
                        else scope.launch { drawerState.open() }
                    }) {
                        Icon(imageVector = Icons.Default.Menu, contentDescription = "Menú" )
                    }
                },
                colors = TopAppBarDefaults.mediumTopAppBarColors(containerColor = Color.Cyan)
            )
        }
    ) {
        ModalNavigationDrawer(
          drawerState = drawerState,
          drawerContent = {
              ModalDrawerSheet {
                  Spacer(Modifier.height(12.dp))
                  options.forEach{ option ->
                      NavigationDrawerItem(
                          icon = {
                                 Icon(imageVector = option.icon, contentDescription = option.title)
                          },
                          label = { Text(option.title) },
                          selected = option.title == selectedOption,
                          onClick = {
                              scope.launch { drawerState.close() }
                              selectedOption = option.title
                          },
                          modifier = Modifier.padding(NavigationDrawerItemDefaults.ItemPadding))
                  }
              }
          },
          modifier = Modifier.padding(it), //Importante para visualizar correctamente
          content = {
              //Cargar contenido dependiendo de la opción seleccionada (selectedOption)
          })

    }
}</code></pre>
    </section><br><br>
    <figure><img src="UD7/images/DemoDrawer.gif" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componentes Modal-->


  <!--*********************************************************Componentes Pager***********************************************************-->
  <section class="apartado">
    <a name="sComponentesPager"></a>
    <h2>Componentes Pager</h2>

    <p>Usando <span class="r-word">HorizontalPager</span> y <span class="r-word">VerticalPager</span>, puedes crear
      diferentes pantallas y navegar entre ellas deslizando el dedo.</p>

    <section>
      <pre><code class="language-kotlin">@OptIn(ExperimentalFoundationApi::class)
@Composable
fun Content() {
    var colors = listOf(Color.LightGray, Color.Magenta, Color.Cyan, Color.Yellow, Color.White)
    val pagerState = rememberPagerState(0 /*Initial Page*/)
    HorizontalPager(
        pageCount = colors.size,
        state = pagerState
        ) {pageNum ->
        Text(text = "Página $pageNum",
             textAlign = TextAlign.Center,
             modifier = Modifier
                 .padding(16.dp)
                 .background(colors[pageNum])
                 .fillMaxSize())
    }
}</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-11-05-19-56-00.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p><span class="negrita">HorizontalPager</span> y <span class="negrita">VerticalPager</span> pueden combinarse con
      botones,
      o puedes deshabilitar los gestos y controlar las páginas solo mediante botones.</p>

    <section>
      <pre><code class="language-kotlin">@OptIn(ExperimentalFoundationApi::class)
@Composable
fun Content() {
    Column {
        val colors = listOf(Color.LightGray, Color.Magenta, Color.Cyan, Color.Yellow)
        val icons = listOf(Icons.Default.Home, Icons.Default.Mail, Icons.Default.Face, Icons.Default.Camera)
        val pagerState = rememberPagerState(0 /*Initial Page*/)
        val scope = rememberCoroutineScope()
        HorizontalPager(
            pageCount = colors.size,
            state = pagerState,
            modifier = Modifier.weight(0.9f)
        ) { pageNum ->
            Text(
                text = "Página $pageNum",
                textAlign = TextAlign.Center,
                modifier = Modifier
                    .padding(16.dp)
                    .background(colors[pageNum])
                    .fillMaxSize()
            )
        }
        NavigationBar(
            modifier = Modifier.weight(0.1f)
        ) {
            colors.forEachIndexed{index, color ->
                NavigationBarItem(
                    selected = index==pagerState.currentPage,
                    onClick = { 
                              scope.launch { 
                                  pagerState.animateScrollToPage(index)
                              }
                    },
                    label = {
                            Text(text = "Página $index")
                    },
                    icon = { Icon(
                        imageVector = icons[index],
                        contentDescription = icons[index].name
                    )}
                )
            }
        }
    }
}</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/DemoPagger.gif" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

  </section><!-- End section Componentes Pager-->


  <!--*********************************************************Componentes TooltipBox***********************************************************-->
  <section class="apartado">
    <a name="sComponentesTooltipBox"></a>
    <h2>Componentes TooltipBox</h2>

    <p>Los <span class="r-word">Tooltips</span> son pequeños mensajes que aparecen cuando se mantiene pulsado un
      elemento.</p>

    <p>Cualquier componente puede tener un Tooltip.</p>

    <p>Para usar estos componentes, es necesario actualizar ciertas versiones:</p>
    <ul>
      <li><span class="inline-file">build.gradle.kts (Project):</span>
        <ul>
          <li>Kotlin -> 1.8.21</li>
        </ul>
      </li>
      <li><span class="inline-file">build.gradle.kts (Module):</span>
        <ul>
          <li>kotlinCompilerExtensionVersion -> 1.4.7</li>
          <li>compose-bom -> 2023.05.01</li>
          <li>core-ktx -> 1.10.1</li>
        </ul>
      </li>
    </ul>

    <section class="marco-t warn">
      <span class="icono warning"></span> Recuerda sincronizar el proyecto tras realizar cambios en los archivos <span
        class="negrita">gradle</span>.
    </section>
    <section class="marco-b"></section>

    <p>Para añadir un <span class="negrita">Tooltip</span> a un componente, debes envolver dicho componente con
      <span class="r-word">PlainTooltipBox</span> o <span class="r-word">RichTooltipBox</span>, y añadir el
      modificador
      <span class="negrita">tooltipAnchor</span> al componente interno.
    </p>

    <section>
      <pre><code class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun Content() {
    PlainTooltipBox(
        tooltip = {
            Text(text = "Añadir a contactos" )
        }
    ){
        Button(onClick = { /*TODO*/ },
               modifier = Modifier.tooltipAnchor()) {
            Icon(
                imageVector = Icons.Default.AddToPhotos,
                contentDescription = "Añadir a contactos"
            )
        }
    }
}</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-11-05-20-22-28.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p class="sub-section">RichTooltipBox</p>

    <p>El componente <span class="r-word">RichTooltipBox</span> permite mostrar más información e incluso algunas
      acciones.
      Necesita un estado para permanecer abierto, y una corrutina para cerrarse.</p>

    <section>
      <pre><code class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MComp() {
    val tooltipState by remember {
        mutableStateOf(RichTooltipState())
    }
    val scope = rememberCoroutineScope()

    RichTooltipBox(
        title = {Text(text = "Añadir a contactos" )},
        action = {
            TextButton(onClick = {
                scope.launch { tooltipState.dismiss() }
            }) {
                Text(text = "Leer más")
            }
        },
        text = { Text(text = "Añade amigos desde...")},
        tooltipState = tooltipState
    ){
        Button(onClick = { /*TODO*/ },
               modifier = Modifier.tooltipAnchor()) {
            Icon(
                imageVector = Icons.Default.AddToPhotos,
                contentDescription = "Añadir a contactos"
            )
        }
    }
}</code></pre>
    </section><br><br>

    <figure><img src="UD7/images/ud7-2023-11-05-20-22-05.png" /><br>
      <figcaption></figcaption>
    </figure>
    <br>

    <p>Teniendo el estado, puedes disparar el <span class="r-word">RichTooltipBox</span> cuando quieras, por ejemplo,
      al pulsar un botón para mostrar información la primera vez que se use.</p>

    <section>
      <pre><code class="language-kotlin">scope.launch { tooltipState.show() }</code></pre>
    </section><br>

  </section><!-- End section Componentes TooltipBox-->


  <!--*********************************************************PRACTICA***********************************************************-->
  <section class="apartado">
    <a id="sP5" name="sP5"></a>
    <h2>P5 Práctica Master/Detail</h2>

    <div class="tarea">
      <p>En esta práctica crearás una aplicación Master/Detail. Para que sea más visible, forzaremos la aplicación a
        estar en orientación horizontal.
        Las aplicaciones Master-Detail suelen tener una lista de elementos en un lado y una vista detallada del
        elemento seleccionado en el otro (la parte principal).</p>

      <p>A continuación, un ejemplo de cómo se verá la aplicación.</p>
      <figure><img src="UD7/images/P2_example.gif" /><br>
        <figcaption></figcaption>
      </figure>
      <br>

      <p>
        Comentemos algunas partes de la aplicación:
      <ul>
        <li>
          El layout principal será un Scaffold o un Surface con un Scaffold dentro.
        </li>

        <li>
          El Scaffold tendrá un TopAppBar que implementarás en un archivo separado. Se verá similar a esto:
          <figure><img src="UD7/images/ud7-2023-11-13-11-00-34.png" /><br>
            <figcaption>TopAppBar</figcaption>
          </figure>
          <br>

          <ul>
            <li>Puedes obtener la imagen del título <a class="enlace" target="_blank"
                href="UD7/p5/dragonball.webp">aquí</a>.</li>
            <li>Puedes obtener la imagen de la bola <a class="enlace" target="_blank"
                href="UD7/p5/fourstarball.webp">aquí</a>.</li>
          </ul>
        </li>

        <li>
          Inicialmente, cuando no se haya seleccionado ningún ítem de la lista, se mostrará un mensaje indicando que
          debe seleccionarse un personaje.<br>
          <figure><img src="UD7/images/ud7-2023-11-13-11-06-37.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>

          Además, el mensaje tendrá estas características:
          <ul>
            <li>
              Será una Card con la forma:
              <section>
                <pre><code class="language-kotlin">shape = CutCornerShape(16.dp)</code></pre>
              </section><br>
              Y con un borde degradado:
              <section>
                <pre><code class="language-kotlin">border = BorderStroke(width = 4.dp, brush = Brush.linearGradient(listOf(Color(0xFFFDD835), Color(0xFFFB8C00), Color(0xFFE53935)))),</code></pre>
              </section><br><br>
            </li>
          </ul>
        </li>

        <li>
          La lista situada a la izquierda tendrá un StickyHeader con la inicial del grupo:
          <figure><img src="UD7/images/ud7-2023-11-13-11-13-15.png" /><br>
            <figcaption></figcaption>
          </figure>
          <br>
          El elemento seleccionado se resaltará como se muestra en la imagen (los colores y el icono pueden
          variar).<br>
          La lista está hecha en un archivo aparte, y el contenido será el campo “spanishName” de la lista de
          personajes.
        </li>

        <li>
          El detalle del elemento seleccionado:
          <ul>
            <li>Puede tener scroll.</li>
            <li>Se mostrará similar a esta imagen:</li>
            <figure><img src="UD7/images/ud7-2023-11-13-11-16-11.png" /><br>
              <figcaption>Detail</figcaption>
            </figure>
            <br>
          </ul>
        </li>

        <li>
          El contenido tanto de la lista como del detalle provendrá del archivo <a class="enlace" target="_blank"
            href="UD7/p5/Character.kt">Character</a>, que debes colocar en el paquete “model”:
          <figure><img src="UD7/images/ud7-2023-11-13-11-20-45.png" /><br>
            <figcaption>Estructura de archivos</figcaption>
          </figure>
          <br>
          Este archivo contiene una data class Character con la información de cada personaje, además de un Companion
          Object
          (similar a atributos y métodos estáticos en Java) que contiene la lista de todos los personajes y funciones
          auxiliares.
        </li>

        <li>
          FloatingActionButton: al pulsarlo se mostrará tu nombre y una foto tuya. Pulsar sobre el texto o en
          cualquier parte de la pantalla hará que desaparezca.

          <figure><img src="UD7/images/ud7-2023-11-13-11-24-55.png" /><br>
            <figcaption>FloatingActionButton</figcaption>
          </figure>
          <br>

          La información se verá algo similar a esta imagen. Observa la transparencia:
          <figure><img src="UD7/images/ud7-2023-11-13-11-26-02.png" /><br>
            <figcaption>Información de usuario</figcaption>
          </figure>
          <br>
        </li>
      </ul>
      </p>

      <p>Entrega la práctica <a class="enlace" target="_blank"
          href="https://aules.edu.gva.es/semipresencial/mod/assign/view.php?id=3028968">aquí</a> en un archivo ZIP
        comprimido con todo el contenido de la carpeta.<br>
        Recuerda comentar tu código, estructurarlo adecuadamente y ejecutar build -> Clean Project antes de
        entregarlo.</p>

    </div>
  </section><!-- End section PRACTICA-->



  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>


</html>