<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/prism.css">
    <link rel="stylesheet" href="../styles/styles.css">
    <script src="../script/script.js"></script>
</head>
<body>
    <h1>Firebase</h1>

    <div class="main-menu">
        <div class="fila">
            <a href="#sIntroduction">Introduction</a><a
        href="#sLogin">Authentication</a><a
        href="#sPush">Push Notifications</a>
        </div>
        <div class="fila">
            <a href="#sCrashlytics">Crashlytics</a><a            
        href="#sRemoteConfig">Firebase Remote Config</a><a            
           href="#sDataBase">Database</a>
        </div>
        <div class="fila">
            <a href="#sWebgraphy">Webgraphy</a>
            <a href="" class="relleno"></a><a href="" class="relleno"></a>
        </div>
        
    </div>

    <!--*********************************************************Introduction***********************************************************-->
    <section class="apartado">
    <a name="sIntroduction"></a>
    <h2>Introduction</h2>
    <p>Firebase will help us to enhance the development of our Android, IOS, web, Unity games applications.
    It appeared in 2014 and is owned by Google, since then it has been improving and adding new features.</p>
    

    <p>Its official page is <a class="enlace" target="_blank" href="https://firebase.google.com/">https://firebase.google.com/</a> </p>
        
    <p>This platform will provide us with different services, such as authentication (Google, Twitter, Apple, own users), analytics services, cloud storage, hosting, databases, etc.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-00-47-46.png" /><br><figcaption>Google firebase services</figcaption></figure>
    <br>

    <p>One of the main features of firebase is that initially everything is free, that is, we can use its services for free up to a certain limit.
    This limit in general is quite high, and by the time we pass it, the application will surely start to do well and give us some benefit.
    You can get more information about their prices <a class="enlace" target="_blank" href="https://firebase.google.com/pricing">here</a>  </p>
    
    
    <figure><img src="UD11/images/ud11-2022-01-24-00-50-23.png" /><br><figcaption>Pricing</figcaption></figure>
    <br>
    <p>For example, we can see that in Authentication we can log 10,000 users per month. At the time we spend we will pay for use.</p>
      

    <p>On the other hand, in the documentation section (<a class="enlace" target="_blank" href="https://firebase.google.com/docs/guides">https://firebase.google.com/docs/guides</a> ), 
        which is very good, it gives us information on how to integrate it into the various platforms.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-00-58-20.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p class="sub-section">Accessing firebase</p>

    <p>To access firebase, we will have to log in with our <span class="negrita">Google</span>  account and press go to console.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-01-12.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>We can also access directly from <a class="enlace" target="_blank" href="https://console.firebase.google.com/">https://console.firebase.google.com/</a> </p>
    

    <p>Once we are in the console we will create a new project and follow each of the instructions.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-02-55.png" /><br><figcaption>Add project</figcaption></figure>
    <br>
    <p>We give it a name to identify the project, if it already exists it will create another name for us. We press continue.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-01-04-08.png" /><br><figcaption>Project Name</figcaption></figure>
    <br>
    
    <p>On the next screen it tells us if we want to leave the analytics enabled, in this case we say yes and press continue.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-06-24.png" /><br><figcaption>Enable Google Analytics</figcaption></figure>
    <br>
    <p>On the next screen we create a new account for analytics. And we fill in the location data and accept the terms and conditions. Click on create project.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-08-56.png" /><br><figcaption></figcaption></figure>
    <br>

    <figure><img src="UD11/images/ud11-2022-01-24-01-10-59.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>We wait a few seconds for our project to be created.</p>    
    <figure><img src="UD11/images/ud11-2022-01-24-01-11-15.png" /><br><figcaption>Creating Project</figcaption></figure>
    <br>
    
    <p>We press continue and we already have our console ready.
    On the left, the main services that we will have to integrate one by one and on the central screen, our project.</p>
    <figure><img src="UD11/images/ud11-2022-01-24-01-13-03.png" /><br><figcaption></figcaption></figure>
    <br>
    
    
    <h3>Integrating Firebase to our App</h3>
    <p>Once our App is created in Android Studio, we go to the Firebase console and add an app to get started. In our case it will be an Android App.</p>
    <figure><img src="UD11/images/ud11-2022-01-24-01-26-54.png" /><br><figcaption>Adding App to Firebase</figcaption></figure>
    <br>
    
    <p>As we did with the maps, it asks us for the name of the package, and the <span class="negrita">SHA-1</span>. 
        Remember that you can get the SHA-1 using the <span class="negrita">signingReport</span>  gradle command</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-29-59.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>We fill in the data and press to register the App.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-01-31-01.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>This will generate a JSON file called <span class="inline-file">google-services.json</span> that we must save inside the <span class="inline-folder">apps</span>
         folder of our project, as indicated in the instructions.
    To make it better switch Android Studio to Project view. Once saved, click next.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-01-32-40.png" /><br><figcaption>google-services.json</figcaption></figure>
    <br>

    <p>The next step is to add the firebase dependencies. For this we follow the instructions.
    First in the project gradle we check that we have the <span class="negrita">Google()</span>  repository and add the dependency to google services.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-01-37-09.png" /><br><figcaption>Build.gradle Project</figcaption></figure>
    <br>
    <p>Now it's the turn of the App module's <span class="inline-file">gradle:app</span> file.
    We must add the google services plugin and the dependencies that it indicates</p>
    

    <section><pre><code class="language-kotlin">plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'com.google.gms.google-services'
}

.....

dependencies {
    ........ 


  // Import the Firebase BoM
  implementation platform('com.google.firebase:firebase-bom:29.0.4')


  // Add the dependency for the Firebase SDK for Google Analytics
  // When using the BoM, don't specify versions in Firebase dependencies
  implementation 'com.google.firebase:firebase-analytics-ktx'


  // Add the dependencies for any other desired Firebase products
  // https://firebase.google.com/docs/android/setup#available-libraries
}</code></pre>
    </section><br><br>

    <section class="marco-t warn">
        <span class="icono warning"> </span> Remember to hit sync.
        </section>
    <section class="marco-b">
            
    </section>
    

    <p>Returning to the firebase console, we press next and it shows us links with examples and documentation and the button to return to the console.</p>    

    <p>According to the documentation, for the integration to be carried out, it is better to uninstall the app if we had it installed and reinstall it again.</p>
        
    <p>Once we have the integration done, it should appear in our console. And if we go to the Analytics dashboard we will see the information that appears, 
        number of users, where they do it from, platform, etc...</p>
    

    <p>We can also launch custom events for parts of our application, for example we are going to make it send us an event every time the Main activity is created.</p>
    

<section><pre><code class="language-kotlin">//If we want to launch our own events to Google Analytics we can do it as follows
//According to Firebase, it can take up to 24 hours from integration for the first events to start appearing.
val analytics: FirebaseAnalytics = FirebaseAnalytics.getInstance(this)
val bundle=Bundle().apply {
    putString("message", "Firebase integration completed")
}
analytics.logEvent("InitScreen",bundle)</code></pre>
</section><br><br>


<p>Then, within Analytics in the events section we can see these events in detail.</p>

    

    
    </section><!-- End section -->

    <!--*********************************************************Authentication***********************************************************-->
    <section class="apartado">
    <a name="sLogin"></a>
    <h2>Authentication</h2>

    <p>Within the authentication service we can see that we have different options to do it, such as username and password, Google, Facebook, etc...</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-02-06-41.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>If we click on the Users tab, we will see the users that we have authenticated, in this case it is empty.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-02-11-08.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>For reasons of time, we will only see two of them:
        <ul>
            <li>Email and password</li>
            <li>Google</li>
        </ul></p>
    

    <h3>Email and Password</h3>
    <p>The first thing we will do is enable the email and password provider.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-02-13-08.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>We enable it. We see that we also have the option to enable email without a password. We press save and we already have the creator provider.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-02-15-25.png" /><br><figcaption>Email/Password provider</figcaption></figure>
    <br>
    <p>So far everything we have to do in the firebase console. Let's go back to Android Studio.</p>
    

    <p>We add the dependency in <span class="inline-file">Gradle:app</span> if we haven't already done so.</p>
    

    <section><pre><code class="language-kotlin">//Firebase Authentication
implementation 'com.google.firebase:firebase-auth'</code></pre>
    </section><br><br>

    <p class="sub-section">Sign up</p>
    <p>To register we first get the FirebaseAuth instance with the FirebaseAuth.getInstance() method
    Later with the instance we can call the method <span class="negrita cursiva">createUserWithEmailAndPassword(email:String, password:String)</span>  to which, as you can see, the email and password are passed.</p>
    
    <section><pre><code class="language-kotlin">FirebaseAuth.getInstance().createUserWithEmailAndPassword(
        "carlos@gmail.com",
        "123456"  //Note that password needs at least 6 characters
    )</code></pre>
    </section><br><br>

    <p>In addition we can add some listener like for example addOnCompletListener, which will fire when the registration is finished.
    It will return a <span class="r-word">Task<AuthResult!></span> . This has the <span class="r-word">isSuccessful</span> property that informs us in a <span class="negrita">Boolean</span> 
     if the registration has gone well.
    The registry code would be as follows.</p>
    

    <section><pre><code class="language-kotlin">FirebaseAuth.getInstance().createUserWithEmailAndPassword(
        "carlos@gmail.com",
        "123456"  //Note that password needs at least 6 characters
).addOnCompleteListener{
    if(it.isSuccessful){ // Register completed ok
        //do something
        //we can't get the user and his email
        Log.d(TAG, it.result?.user?.email ?: "")
    }else{ //Something was wrong
        //showError()
    }
}</code></pre>
    </section><br><br>

    <p>Once registered, we can see the access from the firebase console.</p>
     
    <figure><img src="UD11/images/ud11-2022-01-24-11-16-43.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>As you can see we can also add users from the firebase console.</p>
    
    

    <p class="sub-section">Sign in</p>
    <p>To access with an existing user, the procedure is very similar.
    Now you just have to call the <span class="negrita cursiva">signInWithEmailAndPassword()</span>  method from the instance, which also receives two text strings, email and password.</p>
    

    <section><pre><code class="language-kotlin">FirebaseAuth.getInstance().signInWithEmailAndPassword(
        "carlos@gmail.com",
        "123456"  //Note that password needs at least 6 characters
).addOnCompleteListener{
    if(it.isSuccessful){ // Register completed ok
        //do something
        //we can't get the user and his email
        Log.d(TAG, it.result?.user?.email ?: "")
    }else{ //Something was wrong
        //showError()
    }
}</code></pre>
    </section><br><br>


    <h3>Using Google Account</h3>  
    <p>To add access with Google, we must add a new <span class="d-word">Authentication Provider</span>. Remember for this provider we require the <span class="negrita">SHA-1</span>  in until now it was optional.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-11-42-03.png" /><br><figcaption>/figcaption></figure>
    <br>
    

    <p>Click on Google and give it to enable and save. Additionally we can add a support email.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-03-11-48.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>So far everything we have to do in the firebase console. Let's go back to Android Studio.</p>
    


    <p>This process is a bit more complicated than the previous one, but basically the steps to follow are:</p>
    
    <p>First add the dependency in <span class="inline-file">gradle:app</span></p>
    
    <section><pre><code class="language-kotlin">//Firebase google
implementation 'com.google.android.gms:play-services-auth:20.0.1'</code></pre>
    </section><br><br>

    <p>Already in the code, we must create the <span class="negrita">Google</span> configuration with the data we need from the Google user.
    In this case, we must pass the client ID of our server to the <span class="r-word">requestIdToken</span>  method of the <span class="inline-file">google-services.json</span> file and ask for the email.</p>
     

    <section><pre><code class="language-kotlin">val googleConf = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
    .requestIdToken(getString(R.string.default_web_client_id))
    .requestEmail()
    .build()</code></pre>
</section><br><br>

    <p>Obtain our Google client to log in to which we pass the previous configuration and context.</p>
    
    <section><pre><code class="language-kotlin">val googleClient = GoogleSignIn.getClient(this, googleConf)</code></pre>
    </section><br><br>

    <p>We launch the activity to indicate with which account we want to access or create a new one. 
        This activity is already created, we simply get the intent from the Google Client and launch it.</p>
    

    <section><pre><code class="language-kotlin">val signInIntent = googleClient.signInIntent
launcher.launch(signInIntent)</code></pre>
    </section><br><br>

    <p>We launch it with <span class="negrita">registerForActivityResult</span> , since it remembers that it is precated. And we get the <span class="negrita">Google Account Activity</span>  result.</p>
    
    <section><pre><code class="language-kotlin">private val launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()){ result ->
        if (result.resultCode == Activity.RESULT_OK) {
                //If the result was OK we have to sign in with those credentials

    }</code></pre>
    </section><br><br>

    <p>If the result has gone well, first we get the intent of the Google login activity.</p>
    
    <section><pre><code class="language-kotlin">val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)</code></pre>
    </section><br><br>
    
    <p>We get the account. Eye This operation can throw an ApiException, we must catch it in a <span class="negrita">try catch</span>  block</p>
    

    <section><pre><code class="language-kotlin">try{

    val account = task.getResult(ApiException::class.java)
    if(account!=null){
        //Here we have a valid Google Account

    }
}catch (apiException:ApiException){
    //showError
}</code></pre>
    </section><br><br>

    <p>With the account we obtain your credentials.</p>
    
    <section><pre><code class="language-kotlin">val credential = GoogleAuthProvider.getCredential(account.idToken, null)</code></pre>
    </section><br><br>

    <p>And with firebase and these credentials we call the signInWithCredential(credential) method to sign in.
    The rest is the same as validation via email/password. It would stay like this.</p>
     
    <section><pre><code class="language-kotlin">private val launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()){ result ->
    if (result.resultCode == Activity.RESULT_OK) {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            try{

                val account = task.getResult(ApiException::class.java)
                if(account!=null){
                    val credential = GoogleAuthProvider.getCredential(account.idToken, null)
                    FirebaseAuth.getInstance().signInWithCredential(credential).addOnCompleteListener{
                        if(it.isSuccessful){
                            //Here we have access with that account and we can't get some data such us email.
                            Log.d(TAG, account.email ?: "")
                        }else{
                            showError()
                        }
                    }

                }
            }catch (apiException:ApiException){
                //showError()
            }
        }

}</code></pre>
    </section><br><br>


<p>Now we can access with a Google account.</p>


<figure><img src="UD11/images/UD11_google_login.gif" /><br><figcaption></figcaption></figure>
<br>

<p>We check that we have accessed with that account in the firebase console.</p>


    <figure><img src="UD11/images/ud11-2022-01-24-11-17-23.png" /><br><figcaption></figcaption></figure>
    <br>
    


    
    <div class="tarea">
        Exercise: Add some more authentication method, with Github or Facebook. In their respective pages you have more information about the authentication API.
    </div>

    
    </section><!-- End section -->

    <!--*************************************************** ***********Push Notifications***************************************** **********************-->
    <section class="apartado">
        <a name="sPush"></a>
        <h2>Push Notifications</h2>

        <p class="sub-section">Configure the App for notifications</p>
    
    <p>First, in the <span class="inline-file">gradle:app</span> file we add the corresponding dependency</p>
    <section><pre><code class="language-kotlin">//Cloud Messaging
implementation 'com.google.firebase:firebase-messaging'</code></pre>
    </section><br><br>

    <p>We add in the <span class="inline-file">AndroidManifest.xml</span> the one in charge of attending the notifications when we do not have the App in the foreground.</p>
    
    <section><pre><code class="language-xml">&lt;service
    android:name=".MyFirebaseMessagingService"
    android:exported="false">
    &lt;intent-filter>
        &lt;action android:name="com.google.firebase.MESSAGING_EVENT" />
    &lt;/intent-filter>
&lt;/service></code></pre>
    </section><br><br>
    

    <p>We create the class <span class="r-word">MyFirebaseMessagingService</span> that will extend from <span class="r-word">FirebaseMessagingService</span> </p>
    <section><pre><code class="language-kotlin">class MyFirebaseMessagingService: FirebaseMessagingService() {
}</code></pre>
    </section><br><br>

    <p class="sub-section">Sending notifications from the firebase console</p>
    
        
        <p>First we access the firebase console and access the notification service called <span class="negrita">Cloud Messaging</span> .</p>
        

        <figure><img src="UD11/images/ud11-2022-01-24-12-32-30.png" /><br><figcaption>Cloud Messaging</figcaption></figure>
        <br>
        
        <p>Click on send the first message.</p>        

        <figure><img src="UD11/images/ud11-2022-01-24-12-46-25.png" /><br><figcaption>Send your first message</figcaption></figure>
        <br>

        <p>We fill in the fields of the notification. We press next.</p>
        

        <figure><img src="UD11/images/ud11-2022-01-24-12-48-42.png" /><br><figcaption></figcaption></figure>
        <br>
        
        <p>In point two we select the recipients. We select all android devices that have the application.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-12-51-07.png" /><br><figcaption></figcaption></figure>
        <br>

        <p>The next point is to indicate when we want to send it, we choose now, but we could program a date and time.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-12-52-16.png" /><br><figcaption></figcaption></figure>
        <br>

        <p>We leave conversion events and other options blank as these are more advanced settings. Finally we can save or review it. <br>
        We click on review. <br>
        And click on Publish.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-12-53-56.png" /><br><figcaption></figcaption></figure><br>

        <p>And we see that the notification arrives on our device. If we click on it, it automatically opens our App.</p>
         
        <figure><img src="UD11/images/ud11-2022-01-24-12-55-17.png" /><br><figcaption></figcaption></figure>
        <br>
        
        <p>We can also change the notification icon for it in the <span class="inline-file">AndroidManifest.xml</span> we add the following lines. This is optional.</p>
        
        <section><pre><code class="language-xml">&lt;!-- Set custom default icon. This is used when no icon is set for incoming notification messages.
     See README(https://goo.gl/l4GJaQ) for more. -->
&lt;meta-data
    android:name="com.google.firebase.messaging.default_notification_icon"
    android:resource="@drawable/ic_stat_ic_notification" />
&lt;!-- Set color used with incoming notification messages. This is used when no color is set for the incoming
     notification message. See README(https://goo.gl/6BKBk7) for more. -->
&lt;meta-data
    android:name="com.google.firebase.messaging.default_notification_color"
    android:resource="@color/colorAccent" /></code></pre>
        </section><br><br>
    
    <p class="sub-section">Sending Unicast Notifications</p>
    <p>If we want to send a notification to a single device, what we must do is the following.</p>
    
    <p>First we must obtain the user token (unique for each device) to send.</p>
        

        <section><pre><code class="language-kotlin">FirebaseMessaging.getInstance().token.addOnCompleteListener(OnCompleteListener { task ->
    if (!task.isSuccessful) {
        Log.w(TAG, "Fetching FCM registration token failed", task.exception)
        return@OnCompleteListener
    }

    // Get new FCM registration token
    val token = task.result

    // Log and toast
    val msg = "${getString(R.string.msg_token_fmt)} $token"
    Log.d(TAG, msg)
    //Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()
})</code></pre>
        </section><br><br>

    <p>We can copy it from the one we have sent to the console.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-15-10-11.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>With this token we can send the notification to this device. We could, for example, save the Token in a database and relate it to the user and each time we want to send a notification, retrieve the Token.
<br><br>
    We are now going to send a new notification from the firebase console. We select new notification.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-15-16-12.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>We follow the same steps as before but at point 1 we choose to send test messages.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-15-19-24.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>And in the Token field we add the Token that we have previously obtained. And click on Test.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-15-21-29.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>We already have the exclusive notification for this user (device).</p>
    
    <figure><img src="UD11/images/ud11-2022-01-24-15-31-31.png" /><br><figcaption></figcaption></figure>
    <br>
    
    
    

    <p class="sub-section">Sending Multicast</p>
        
        <p>If instead of wanting to send to all devices or to just one, we use the topics (Topics).
        To subscribe a device to a topic is very simple, we just have to execute the following command.</p>
        
        <section><pre><code class="language-kotlin">FirebaseMessaging.getInstance().subscribeToTopic("DAM2122")</code></pre>
        </section><br><br>

        <p>And to send them is very simple. We first start up two devices that subscribe to the same topic.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-16-16-05.png" /><br><figcaption></figcaption></figure>
        <br>
                
        <p>We go to the Firebase console and send the same message, but in step 2 (Target) we select the Topic.
        We see that it already recognizes it for us because when launching the application we have registered it.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-16-18-27.png" /><br><figcaption></figcaption></figure>
        <br>
        
        <p>We review the message.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-16-18-59.png" /><br><figcaption></figcaption></figure>
        <br>
        
        <p>We launched it and it reaches us on both devices.</p>
        
        <figure><img src="UD11/images/ud11-2022-01-24-16-28-42.png" /><br><figcaption></figcaption></figure>
        <br>
        

        <p class="sub-section">Foreground Notifications</p>
        
        <p>The notifications only arrive if it is in the background, to handle these notifications we will do it from the service that we created in the first point.
        We must override the <span class="r-word">onMessageReceived()</span>  operation on our <span class="inline-file">MyFirebaseMessagingService</span> class .</p>
        

        <p>For example we will launch a Toast with the title of the message.</p>
        
<section><pre><code class="language-kotlin">override fun onMessageReceived(remoteMessage: RemoteMessage) {
    super.onMessageReceived(remoteMessage)

    CoroutineScope(Dispatchers.Default).launch {
        sendMessage(remoteMessage.notification?.title?:"No message")
    }
}

private suspend fun sendMessage(text:String) = withContext(Dispatchers.Main){
    Toast.makeText(baseContext, text,Toast.LENGTH_SHORT).show()
}</code></pre>
</section><br><br>

<p>Notice that we launch it from a coroutine with <span class="negrita">Dispatcher.Main</span> .</p>


    <figure><img src="UD11/images/ud11-2022-01-24-17-04-23.png" /><br><figcaption></figcaption></figure>
        <br>
        
    <p class="sub-section">Send information in the notification</p>
    
    <p>To do this, we launch the notification as we have done so far, but we stop at the last option, Additional options.
        We see that we can write a key-value pair, we put for example the url of the notes.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-17-11-52.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>Now we retrieve it from the notification.</p>
    
    <section><pre><code class="language-kotlin">//Receive info from notification
val url = intent.getStringExtra("url")
url?.let{
    println("We've received this url $it in the notification")
}</code></pre>
</section><br><br>


    <p>We get the notification</p>
    <figure><img src="UD11/images/ud11-2022-01-24-17-15-28.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>And by clicking on it we retrieve the information.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-24-17-17-08.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>So far what we will see regarding notifications, but remember that the normal thing is to send notifications from a server or through firebase functions.
    There is documentation on the firebase website to integrate notifications into our server, as well as the use of firebase functions.</p>
    
            
        </section><!-- End section -->

    <!--***************************************************************Crashlytics***************************************************************-->
    <section class="apartado">
        <a name="sCrashlytics"></a>
        <h2>Google Crashlytics</h2>

       <p>It will allow us to obtain information and statistics of our errors or bugs to be able to solve them.</p>
       

       <p>To activate it, go to the Release & Monitor section and select <span class="r-word">Crashlytics</span> .</p>
       

    <figure><img src="UD11/images/ud11-2022-01-24-23-56-46.png" /><br><figcaption></figcaption></figure>
    <br>
    
   <p>Once this is done, we must follow the steps of integrating crashlytics in our application.</p>
   
    
    <p>We open the <span class="inline-file">build.gradle:app</span> of our project and add the dependency.</p>
    
    <section><pre><code class="language-kotlin">implementation 'com.google.firebase:firebase-crashlytics'</code></pre>
    </section><br><br>
    <span class="inline-file">We also add the plugin</span>
    <section><pre><code class="language-kotlin">id 'com.google.firebase.crashlytics'</code></pre>
    </section><br><br>

    <p>In this case we also open the <span class="inline-file">build.gradle:project</span> and add the corresponding plugin to Crashlytics. We press sync now</p>
    

    <section><pre><code class="language-kotlin">classpath 'com.google.firebase:firebase-crashlytics-gradle:2.8.1'</code></pre>
    </section><br><br>

    <p>We run our app and check in the console that the integration has been successful.
    Here we can select the operating system of the App in our Android case, and start seeing the information it provides us.
    We can filter by the type of errors of our App, by default it shows those of the blocking type, which are the worst errors they can give us, since the user experience is impaired.
    They are unexpected closures when executing certain code. It will help us to detect errors in users who have downloaded and installed our App and that we have not been able to detect when doing it.</p>
    

    <p>We have a failure statistic.</p>
     

    <p>At the bottom we will see the list of errors. Let's force a bug to test crashlytics. To do this, we will first create a forced error button.
    By pressing this button we launch an uncontrolled exception that will make the App stop.</p>
    

    <section><pre><code class="language-kotlin">binding.btnForceError.setOnClickListener {
            //Error forcing
            throw RuntimeException("Forcing Error")
        }</code></pre>
    </section><br><br>

    <p>If we launch the application and force the error, it stops.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-01-05-43.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>Crashlytics nos indica hasta que fichero y línea ha fallado.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-01-03-47.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>We can add information about the user who was logged in when the error occurred, as well as some extra information, in this case the provider the user was using.</p>
    
    <section><pre><code class="language-kotlin">//we send the user that is getting the error.
FirebaseCrashlytics.getInstance().setUserId(email)

//We can set customs key. In this case we can know which is the user provider when the app crashes
FirebaseCrashlytics.getInstance().setCustomKey(PROVIDER,provider)</code></pre>
    </section><br><br>

    <figure><img src="UD11/images/ud11-2022-01-25-01-06-42.png" /><br><figcaption></figcaption></figure>
    <br>
    
    
    <p>We can use the user's information to notify you that the App is already operational, apologize for the inconvenience, etc.</p>
    <figure><img src="UD11/images/ud11-2022-01-25-01-01-56.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>We can also use crashlytics as a log, to send information about what caused the error.</p>
    
    <section><pre><code class="language-kotlin">FirebaseCrashlytics.getInstance().log("ForceError Button has been pressed")</code></pre>
    </section><br><br>


    
        
        </section><!-- End section -->

    
    <!--*********************************************************Firebase Remote Config***********************************************************-->
    <section class="apartado">
    <a name="sRemoteConfig"></a>
    <h2>Firebase Remote Config</h2>
    <p>Many times making changes to our apps forces us to deploy a new version in the store.
    We are going to see how to save different configuration parameters in the cloud on a remote server in a very simple and, above all, free way.
    This service that will allow us to save and update different values ​​of different parameters in the cloud, being able to consult those values ​​
    from our app without having to upload a new update to the app store</p>
    

    <p>We are going to activate it from Remote Config in the side menu of the firebase console.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-01-16-40.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>With the remote configuration, we are going to do, for example, change the text of the force error button, decide if we want it to be shown or not.
    We could also define urls or even save json files, etc.</p>
    
    
    <p>Let's go to the console to define these configurations, which will be key-value</p>
    

    <figure><img src="UD11/images/ud11-2022-01-25-01-28-58.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>The other parameter will be the button text. Finally we give you to publish changes.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-01-32-00.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Once the remote configuration is created, we are going to use it in our App.
    To do this, the first thing we will do is add the dependency in <span class="inline-file">build.gradle:app</span>.</p>
    

    <section><pre><code class="language-kotlin">//Remote config
implementation 'com.google.firebase:firebase-config'</code></pre>
    </section><br><br>

    <p>Now in the main activity (<span class="negrita">AuthActivity</span>) we will create the configuration, this will be a default configuration, in case our App is not able to connect to the Internet.
    We can also set how often we want to refresh this configuration. By default they are every 12 hours.</p>
    

    <section><pre><code class="language-kotlin">//Remote config
val fireRemoteConfig = FirebaseRemoteConfig.getInstance()
val configSettings = FirebaseRemoteConfigSettings.Builder()
    .setMinimumFetchIntervalInSeconds(60)
    .build()

fireRemoteConfig.setConfigSettingsAsync(configSettings)

//We're setting our defaults settings with the same key that firebase console.
fireRemoteConfig.setDefaultsAsync(mapOf("show_error_button" to false, "error_button_text" to "Force Error"))</code></pre>
    </section><br><br>

    <p>We already have the default configuration, now we are going to recover the remote values. We will do this in our (<span class="negrita">HomeActivity</span>) .</p>
    
<section><pre><code class="language-kotlin">//Remote config
binding.btnForceError.visibility = View.GONE

FirebaseRemoteConfig.getInstance().fetchAndActivate().addOnCompleteListener { task ->
    if(task.isSuccessful){
        val showErrorButton:Boolean = FirebaseRemoteConfig.getInstance().getBoolean("show_error_button")
        val errorButtonText:String = FirebaseRemoteConfig.getInstance().getString("error_button_text")

        if(showErrorButton){
            binding.btnForceError.visibility = View.VISIBLE
        }
        binding.btnForceError.text = errorButtonText

    }
}</code></pre>
</section><br><br>

    <p>If we launch our App, the default setting make that the button is hidden.</p>
    
<figure><img src="UD11/images/ud11-2022-01-25-01-57-02.png" /><br><figcaption></figcaption></figure>
<br>

    <p>Now we change our settings to display. Remember to publish changes.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-01-56-37.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>We launch the application again and it is already shown to us with the new text.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-25-01-57-51.png" /><br><figcaption></figcaption></figure>
    <br>
    
    
    


    </section><!-- End section -->

    <!--*********************************************************Database***********************************************************-->
    <section class="apartado">
    <a name="sDataBase"></a>
    <h2>Database</h2>
    <p>We have two databases, the modern <span class="r-word">Firestore Database</span>, 
    more optimized and the classic <span class="r-word">Realtime Database</span>, 
    not because it is older means that it does not work well.
    Which one to choose between the two? 
    From the firebase page itself they give us the keys to choose one or the other, including a small 
    <a class="enlace" target="_blank" href="https://firebase.google.com/docs/database/rtdb-vs-firestore?authuser=0">survey</a> to help us decide.</p>
    
    

    <h3>Cloud Firestore Database</h3>
    <p>We create our database.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-02-26-48.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>We choose the default access rule that we will use, 
        in this case the test mode that gives us 30 days to do what we want. 
        I recommend you to review the rules documentation.</p>
    
    <a class="enlace" target="_blank" href="https://firebase.google.com/docs/firestore/security/get-started?authuser=0">https://firebase.google.com/docs/firestore/security/get-started?authuser=0</a> 
    <figure><img src="UD11/images/ud11-2022-01-25-02-27-45.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>We choose where our database will be physically located and press enable.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-02-29-11.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>From here we could create the collection and the documents but we will do it from code in our App.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-02-30-36.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>As our App we are using users we are going to create a database that stores users. 
        We could add and modify them directly from the firebase console.</p>
    

    <p>First we will add the address and phone fields in our <span class="inline-file">activity_home.xml</span>
         and also three buttons that will allow us to save, retrieve and delete users.</p>
    

    <p>Now we add the dependency in <span class="inline-file">build.gradle:app.</span></p>
    
    <section><pre><code class="language-kotlin">implementation 'com.google.firebase:firebase-firestore-ktx'</code></pre>
    </section><br><br>

    <p>We get the reference to the <span class="negrita">Database</span>  as a property of the 
        <span class="inline-file">HomeActivity.kt</span> class.</p>
    
    <section><pre><code class="language-kotlin">val db = Firebase.firestore</code></pre>
    </section><br><br>

    <p>We add the save button handler. We can see that we get from the "<span class="negrita">users</span>" 
        collection the email "<span class="cursiva">primary key</span>" document, 
        if it doesn't exist it creates it, otherwise it updates it.</p>
    
    <section><pre><code class="language-kotlin">binding.btnSave.setOnClickListener {
    //Collection name is "users" and add or update a document with email as primary key
    db.collection("users").document(email).set(
        hashMapOf(
            "provider" to provider,
            "address" to binding.etAddress.text.toString(),
            "phone" to binding.etPhone.text.toString()
        )
    )
}</code></pre>
    </section><br><br>

    <p>We try to save and see how the database is updated creating the document.</p>
     
    <figure><img src="./UD11/images/UD11_save_firestore.gif" /><br><figcaption></figcaption></figure>
    <br>

    <p>If we save again on the same user, the document is updated.</p>
    

    <figure><img src="./UD11/images/UD11_save_firestore_2.gif" /><br><figcaption></figcaption></figure>

    <p>Now it's time to retrieve the document associated with the email. 
        In this case we launch the <span class="r-word">addOnSuccessListener</span>  listener, which will return the data returned in the query.
    We simply add them to the <span class="d-word">EditText</span> </p>
    
<section><pre><code class="language-kotlin">binding.btnGet.setOnClickListener {
    db.collection("users").document(email).get().addOnSuccessListener {
        binding.etAddress.setText(it.get("address") as String?)
        binding.etPhone.setText(it.get("phone") as String?)
    }
}</code></pre>
</section><br><br>

<p>If we launch the App and hit get, we load the data into the <span class="d-word">EditText</span> .</p>

<figure><img src="./UD11/images/UD11_get_firestore.gif" /><br><figcaption></figcaption></figure>

<p>And finally, we delete the data associated with email.</p>

<section><pre><code class="language-kotlin">binding.btnDelete.setOnClickListener {
    db.collection("users").document(email).delete()
}</code></pre>
</section><br><br>
<figure><img src="./UD11/images/UD11_delete_firestore.gif" /><br><figcaption></figcaption></figure>

    <h3>Realtime Database</h3>
    
    <p>Now we are going to use RealTime database. To do this from the <span class="negrita">firebase</span>  console we create a new database.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-25-11-35-52.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>As in Firestore, we indicate the location of the database.</p>
    
    <figure><img src="UD11/images/ud11-2022-01-25-11-36-45.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>And the security rules on this database. 
        As always I recommend you to read the documentation.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-25-12-12-41.png" /><br><figcaption></figcaption></figure>
    <br>

    <p>In this case we are going to import a json file to populate our database with fictitious users.</p>
     

    <figure><img src="UD11/images/UD11_import_realtime.gif" /><br><figcaption></figcaption></figure>
    <br>
    
    <p class="sub-section">Configuring the App</p>
    
    <p>As always we add the necessary dependency in the build.gradle:app . Remember to sync.</p>
    
    <section><pre><code class="language-kotlin">// Declare the dependency for the Realtime Database library
// When using the BoM, you don't specify versions in Firebase library dependencies
implementation 'com.google.firebase:firebase-database-ktx'</code></pre>
    </section><br><br>

    <p>We create the reference to our Real Time database.</p>
    
    <section><pre><code class="language-kotlin">val dbRealTime = Firebase.database</code></pre>
    </section><br><br>

    <p>If we are in a different zone than the one configured, it is better to put the full path to our database, 
        we can get it from the firebase console itself.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-26-16-06-05.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>So the previous code would look like this.</p>
    
    <section><pre><code class="language-kotlin">val dbRealTime = Firebase.database(" https://dam2example-default-rtdb.europe-west1.firebasedatabase.app")</code></pre>
    </section><br><br>

    <p>The next step is to get a reference to our collection.</p>
    

    <p>At this point, it is worth noting that firebase databases are <span class="negrita">noSQL</span>, 
        that is, they are not the classic relational ones, but are made up of collections and documents.
    All in json format</p>
    

    <section><pre><code class="language-kotlin">//Reference to our data
val myRef = dbRealTime.getReference("users")</code></pre>
    </section><br><br>

    <p>As you can see, we reference the users collection, which matches the one we put in the database.</p>
    

    <figure><img src="UD11/images/ud11-2022-01-26-16-08-57.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <p>To fetch all the data for the first time, we can add an <span class="r-word">addValueEventListener</span> listener, 
        which would return the entire collection.
    And inside this we override the <span class="r-word">onDataChange</span> and <span class="r-word">onCancelled</span> functions.</p>
    
    <section><pre><code class="language-kotlin">myRef.addValueEventListener(object : ValueEventListener {
    override fun onDataChange(dataSnapshot: DataSnapshot) {
        // This method is called once with the initial value and again
        // whenever data at this location is updated.
        val usersListType: GenericTypeIndicator&lt;MutableList&lt;Users>> =
            object : GenericTypeIndicator&lt;MutableList&lt;Users>>() {}
         val userList = dataSnapshot.getValue(usersListType)

         //Here we have the list of users in memory and we can do with it what ever we want

    }</code></pre>
</section><br><br>

    <p>Note the use of <span class="negrita">GenericTypeIndicator</span>  to indicate what type of data we are going to receive.</p>
    

    <p>This will be executed only once at the beginning, if what we want is to be permanently listening 
        to the database we must add another listener, <span class="r-word">addChildEventListener</span> and implement its corresponding methods.</p>
    

    <section><pre><code class="language-kotlin">myRef.addChildEventListener(object : ChildEventListener{
    override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {
        val user = snapshot.getValue(Users::class.java)
        //here we have a new user. Note that it is also called for the first time, so it gets the Users that were in database before.
    }

    override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {
        val user = snapshot.getValue(Users::class.java)
    }

    override fun onChildRemoved(snapshot: DataSnapshot) {
        val user = snapshot.getValue(Users::class.java)
    }

    override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {
        TODO("Not yet implemented")
    }

    override fun onCancelled(error: DatabaseError) {
        TODO("Not yet implemented")
    }

})</code></pre>
    </section><br><br>
    
    <p>The names of the methods are quite descriptive and do not need many comments on what each of them does. Let's look at some examples.</p>
    

    <p>We delete user #2 from the database.</p>
    
    <figure><img src="./UD11/images/UD11_deleting_realtime.gif" /><br><figcaption></figcaption></figure>
    <br>

    <p>Updating user data.</p>
    
    <figure><img src="./UD11/images/UD11_updating_realtime.gif" /><br><figcaption></figcaption></figure>
    <br>

    <p>Creating new User.</p>
    
    <figure><img src="./UD11/images/UD11_adding_realtime.gif" /><br><figcaption></figcaption></figure>
    <br>

    <p>At this point it should be noted that a recyclerview has been created to show the users with the realtime database.
    Also note that there is a <span class="negrita">FloatingActionButton</span>,
    which when launched creates a fixed user (that is, its data is fixed 
    and it is done as an example, normally it will take us to a user creation form)</p>
    

    <p class="sub-section">Adding elements</p>

    <p>To add elements we have two options: Generate a random key or put it ourselves.
    In the previous case, as you can see, the key that we put is id and corresponds to the following code.</p>
    
    
    <section><pre><code class="language-kotlin"> binding.fabAdd.setOnClickListener {
    val user = Users("id", "newuser@gmail.com","BASIC","Home of new User", "999 99 99 99")
    myRef.child("id").setValue(user) //We add our own path (key/name)
        .addOnSuccessListener(OnSuccessListener&lt;Void?> {
            //Writing ok
        })
        .addOnFailureListener(OnFailureListener {
            //Writing KO
        })
}</code></pre>
    </section><br><br>

    <p>If we want it to create a unique key that we can use as "primary key" we use the push method</p>

    <section><pre><code class="language-kotlin">binding.fabAdd.setOnClickListener {
    val user = Users("id", "newuser@gmail.com","BASIC","Home of new User", "999 99 99 99")
    myRef.push().setValue(user) //firebase creates the key
        .addOnSuccessListener(OnSuccessListener<Void?> {
            //Writing ok
        })
        .addOnFailureListener(OnFailureListener {
            //Writing KO
        })
}</code></pre>
    </section><br><br>

    <p>Then we can recover it with the key property of the <span class="negrita">snapshot</span> </p>
    
    <section><pre><code class="language-kotlin">val user = snapshot.getValue(Users::class.java)
                user?.id = snapshot.key?:"-1"</code></pre>
    </section><br><br>

    <figure><img src="UD11/images/ud11-2022-01-26-16-47-16.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p><a class="enlace" target="_blank" href="https://github.com/sdram58/PMDM2021/tree/master/FirebaseExample">Link Github's sample</a> </p>


    </section><!-- End section -->

    

    <!--*********************************************************Webgraphy***********************************************************-->
    <section class="apartado">
    <a name="sWebgraphy"></a>
    <h2>Webgraphy</h2>

    <ul>
        <li><a class="enlace" target="_blank" href="https://firebase.google.com/">https://firebase.google.com/</a> </li>
    </ul>
    
    
    
    </section><!-- End section -->
    

    <script src="../script/prism.js"></script>
</body>
</html>
