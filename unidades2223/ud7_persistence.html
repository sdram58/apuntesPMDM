<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data persistence</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/prism.css">
    <link rel="stylesheet" href="../styles/styles.css">
    <script src="../script/script.js"></script>
</head>
<body  class="line-numbers">
    <h1>Data persistence</h1>
    <div class="main-menu">
        <div class="fila">
            <a href="#sSaveState">Save State</a><a 
           href="#sFileSystem">File System</a><a 
           href="#sShared">Shared Preferences</a>
        </div>
        <div class="fila">
            <a
           href="#sRoom">Room</a><a
           href="#sWebgrafia">Webgraphy</a>
           <a href="" class="relleno"></a>
        </div>
        
    </div>

    <!--*********************************************************OnSaveState***********************************************************-->
    <section class="apartado">
    <a name="sSaveState"></a>
    <h2>Save State</h2>
    
    <p>In this section, we’ll be discussing the two vital methods for managing the state of the application, namely <span class="r-word">onSaveInstanceState</span> 
         and <span class="r-word">onRestoreInstanceState</span>.</p>
         
    <p>We’ll be developing a <span class="d-word">Counter</span>  Android Application in which we’ll handle the state of the application when the configuration changes.</p>
         
    <p>So, let's get started.</p>
    
    <h3>Creating the App</h3>

    <p>Create an App called <span class="d-word">SaveState</span> from <span class="negrita">empty activity</span> which contains only a <span class="negrita">TextView</span>  
        and a <span class="negrita">Button</span></p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

   &lt;TextView
        android:id="@+id/tvCounter"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="@color/purple_500"
        android:textSize="40sp"
        tools:text="0"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintVertical_bias="0.25" />

   &lt;Button
        android:id="@+id/btnInc"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Increase"
        android:textAllCaps="false"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@id/tvCounter"
        app:layout_constraintVertical_bias="0.50" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
            </section><br><br>
    </section>

    <p>Now we go with the code of the <span class="inline-file">MainActivity.kt</span>. It will simply have a <span class="subrayado">listener</span>  so that when the
         button is pressed, the counter increases by 1. For this we will have a global variable <span class="d-word">counter</span>  that we will initialize to <span class="negrita">0</span> 
          and that we will increase each time we press the button. It's an easy app but it serves us for that example.</p>

    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-kotlin">import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button
import android.widget.TextView

class MainActivity : AppCompatActivity() {
    private var counter=0

    private val tvCounter: TextView by lazy { findViewById(R.id.tvCounter) }
    private val btnInc: Button by lazy { findViewById(R.id.btnInc) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)



        btnInc.setOnClickListener {
            increaseCounter()
        }

        updateTvCounter()
    }

    private fun increaseCounter() {
        counter++

        updateTvCounter()
    }

    private fun updateTvCounter() {
        tvCounter.text=counter.toString()
    }
}</code></pre>
        </section>
    </section>
    
    <figure><img src="UD7/images/UD7-running_app_save_state.gif" /><br><figcaption>Running App</figcaption></figure>
    <br>
    
    <br>
    <p>The app works as expected. But what if we turn over the mobile phone to landscape position</p>


    <figure><img src="UD7/images/UD7-running_app_save_state_error.gif" /><br><figcaption>Running App</figcaption></figure>
    <br>
    <br>
    <p>As we can see, the counter value is set to 0 again. This is because when we turn the mobile, the activity is created again, starting the counter at 0.</p>
    <p>Let's add a Log to check that in the <span class="inline-file">MainActitity</span></p>

    <section><pre><code class="language-kotlin">private fun log(text:String){
    Log.d(TAG, text )
}</code></pre>
    </section><br><br>

    <p>And remember create the <span class="negrita">TAG</span> </p>

    <section><pre><code class="language-kotlin">import ......

const val TAG ="SAVE_STATE_TAG"

class MainActivity : AppCompatActivity() { .....</code></pre>
    </section><br><br>

    <p>Now every time we enter the onCreate we execute the log function</p>

    <section><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    log("onCreate Method")
    .............</code></pre>
    </section><br><br>

    <p>Launch the App and let's see</p>

    <figure><img src="UD7/images/UD7-running_app_save_state_log.gif" /><br><figcaption>onCreate is called two times</figcaption></figure>
    <br>
    <br>

    <h3>onSaveInstanceState and onRestorenIstanceState</h3>

    <p>
        <span class="r-word">onSaveInstanceState</span>  allows us to save data after the activity stops.
        <span class="r-word">onRestorenIstanceState</span>  allows us to retrieve previously stored data
    </p>
    <p>To see when each of these methods are executed we are going to override them and call our log function, in addition we will also include the 
        <span class="r-word">onResume</span>  function on the <span class="inline-file">MainActivity.kt</span></p>

    <section><pre><code class="language-kotlin">override fun onResume() {
    super.onResume()
    log("We are onResume")
}
override fun onSaveInstanceState(outState:Bundle){
    super.onSaveInstanceState(outState)
    log("We are onSaveInstanceState")
}

override fun onRestoreInstanceState(savedInstanceState: Bundle) {
    super.onRestoreInstanceState(savedInstanceState)
    log("We are onRestoreInstanceState")
}</code></pre>
        </section><br><br>
<p>
    If we launch the application and later turn the mobile, the result of the log will be as follows.</p>

    <section><pre><code class="language-kotlin">//App is recently launched
com.cartatar.savestate D/SAVE_STATE_TAG: onCreate Method
com.cartatar.savestate D/SAVE_STATE_TAG: We are onResume
//Here we rotate the mobile
com.cartatar.savestate D/SAVE_STATE_TAG: We are onSaveInstanceState
com.cartatar.savestate D/SAVE_STATE_TAG: onCreate Method
com.cartatar.savestate D/SAVE_STATE_TAG: We are onRestoreInstanceState
com.cartatar.savestate D/SAVE_STATE_TAG: We are onResume</code>
</pre></section>
<br><br>

<p class="sub-section">Saving and Restoring the State</p>

<p>Now, we are using the <span class="negrita">Bundle</span>  to save our data so we can retrieve it later.</p>

<p>We simply have to add our <span class="d-word">counter</span>  to the <span class="negrita">Bundle</span>  so that we can later retrieve it. 
    Remember to use the same Key to retrieve it, the best option is to create a constant.</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.TextView

const val TAG ="SAVE_STATE_TAG"

const val COUNTER_KEY="COUNTER_KEY"

class MainActivity : AppCompatActivity() {
    private var counter=0

    private val tvCounter: TextView by lazy { findViewById(R.id.tvCounter) }
    private val btnInc: Button by lazy { findViewById(R.id.btnInc) }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        log("onCreate Method")

        btnInc.setOnClickListener {
            increaseCounter()
        }


    }

    private fun increaseCounter() {
        counter++

        updateTvCounter()
    }

    private fun updateTvCounter() {
        tvCounter.text=counter.toString()
    }

    private fun log(text:String){
        Log.d(TAG, text )
    }

    override fun onResume() {
        super.onResume()
        log("We are onResume")
        updateTvCounter()
    }

    override fun onSaveInstanceState(outState:Bundle){
        super.onSaveInstanceState(outState)
        log("We are onSaveInstanceState")
        outState.putInt(COUNTER_KEY,counter)
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        log("We are onRestoreInstanceState")

        counter=savedInstanceState.getInt(COUNTER_KEY)
    }
}</code></pre>
        </section><br><br>
</section>


<p>Notice that we've moved the <span class="d-word">updateTvCounter()</span>  method from <span class="r-word">onCreate</span>  to <span class="r-word">onResume</span> </p>

<figure><img src="UD7/images/UD7-running_app_save_state_ok.gif" /><br><figcaption>Save State Working ok</figcaption></figure>
<br>

<section class="marco-t inf">
    <span class="icono info"> </span> <span class="negrita">EditText</span>  save its sate internally so you don't have to implement anything for them.
    <br><br>
    For more complex Apps, it is better to use ViewModel pattern.
    </section>
<section class="marco-b">
        
</section>
    

<p>You can see the complete project <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/CounterSaveState">here</a> </p>




    </section><!-- End section -->

    <!--*********************************************************File System***********************************************************-->
    <section class="apartado">
    <a name="sFileSystem"></a>
    <h2>File System</h2>

    <h3>Introduction</h3>
    
    
    <p>Android uses a file system which is imilar to disk-based file systems on other platforms. The system provides several options for you to save your app data:</p>
    <p>
    <ul>
        <li><span class="d-word"><span class="negrita">App-specific storage</span> </span>: Store files that are meant for your app's use only, either in dedicated directories within an 
            <span class="negrita"><span class="subrayado">internal storage</span></span> volume or different dedicated directories within <span class="negrita"><span class="subrayado">external storage</span></span>   . 
            <span class="subrayado">Use the directories within internal storage to save sensitive information that other apps shouldn't access.</span></li>
        <li><span class="d-word"><span class="negrita">Shared storage</span></span>: Store files that your app intends to share with other apps, including media, documents, and other files.</li>
        <li><span class="d-word"><span class="negrita">Preferences</span></span>: Store private, primitive data in key-value pairs.</li>
        <li><span class="d-word"><span class="negrita">Databases</span></span>: Store structured data in a private database using the Room persistence library.</li>
    </ul>
</p>    
<p>The characteristics of these options are summarized in the following table:</p>

    <figure><img src="UD7/images/ud7-2021-11-24-11-58-36.png" /><br><figcaption></figcaption></figure>
    <br>
    <br>

    <p>The solution you choose depends on your specific needs:</p>
    

<p><span class="negrita">How much space does your data require?</span> </p>

<p>Internal storage has limited space for app-specific data. Use other types of storage if you need to save a substantial amount of data.</p>
<br>
<p><span class="negrita">How reliable does data access need to be?</span> </p>

<p>If your app's basic functionality requires certain data, such as when your app is starting up, place the data within internal storage directory or a database. App-specific files that are stored in external storage aren't always accessible because some devices allow users to remove a physical device that corresponds to external storage.</p>
<br>
<p><span class="negrita">What kind of data do you need to store?</span> </p>


<p>If you have data that's only meaningful for your app, use app-specific storage. For shareable media content, use shared storage so that other apps can access the content. 
    For structured data, use either preferences (for key-value data) or a database (for data that contains more than 2 columns).</p>

<br>
<p><span class="negrita">Should the data be private to your app?</span> </p>

<p>When storing sensitive data—data that shouldn't be accessible from any other app—use internal storage, preferences, or a database. 
    Internal storage has the added benefit of the data being hidden from users.</p>


<h3>Access app-specific files</h3>

<p>In many cases, your app creates files that other apps don't need to access, or shouldn't access. The system provides the following locations for storing such app-specific files:</p>

<p>
    <ul>
        <li><span class="negrita">Internal storage directories</span>: These directories include both: a dedicated location for storing persistent files, 
            and another location for storing cache data. The system prevents other apps from accessing these locations, and on <span class="negrita">Android 10 (API level 29)</span> 
            and higher, these locations are encrypted. These characteristics make these locations a good place to store sensitive data that only your app itself can access.</li>
        <li>
            <span class="negrita">External storage directories</span> : These directories include both a dedicated location for storing persistent files, and another 
            location for storing cache data. Although it's possible for another app to access these directories if that app has the proper permissions, 
            the files stored in these directories are meant for use only by your app. If you specifically intend to create files that other apps should be able to access, 
            your app should store these files in the shared storage part of external storage instead.
        </li>
    </ul>
</p>
<p>When the user uninstalls your app, the files saved in app-specific storage are removed. Because of this behavior, you shouldn't use this storage to save anything that 
    the user expects to persist independently of your app. For example, if your app allows users to capture photos, the user would expect that they can access those 
    photos even after they uninstall your app. So you should instead use shared storage to save those types of files to the appropriate media collection.</p>


<h3>Access from internal storage</h3>
<p>For each app, the system provides directories within internal storage where an app can organize its files. One directory is designed for your app's persistent files, 
    and another contains your app's cached files. Your app doesn't require any system permissions to read and write to files in these directories.</p>

<p>Other apps cannot access files stored within internal storage. This makes internal storage a good place for app data that other apps shouldn't access.</p>
<p>Keep in mind, however, that these directories tend to be small. Before writing app-specific files to internal storage, your app should <span class="negrita">query the free space</span> 
    on the device.</p>
<br>
<p>This snippet allows us to know how much free space on the device</p>
<section><pre><code class="language-kotlin">// App needs 10 MB within internal storage.
const val NUM_BYTES_NEEDED_FOR_MY_APP=1024 * 1024 * 10L;

val storageManager=applicationContext.getSystemService&lt;StorageManager>()!!
val appSpecificInternalDirUuid: UUID=storageManager.getUuidForPath(filesDir)
val availableBytes: Long =
        storageManager.getAllocatableBytes(appSpecificInternalDirUuid)
if (availableBytes >= NUM_BYTES_NEEDED_FOR_MY_APP) {
    storageManager.allocateBytes(
        appSpecificInternalDirUuid, NUM_BYTES_NEEDED_FOR_MY_APP)
} else { //We don't have enough space we ask for removing something
    val storageIntent=Intent().apply {
        // To request that the user remove all app cache files instead, set
        // "action" to ACTION_CLEAR_APP_CACHE.
        action=ACTION_MANAGE_STORAGE
    }
}</code></pre>
</section><br><br>

<h3>Access persistent files</h3>

<p>Your app's ordinary, persistent files reside in a directory that you can access using the <span class="r-word">filesDir</span>  property of a <span class="negrita">context</span> 
     object. The framework provides several methods to help you access and store files in this directory.</p>

<p>You can use the <span class="r-word">File</span>  API to access and store files.</p>
<p>To help maintain your app's performance, <span class="subrayado">don't open and close the same file multiple times</span> .</p>
<p>The following code snippet demonstrates how to use the <span class="r-word">File</span>  API:</p>
<section><pre><code class="language-kotlin">val file=File(context.filesDir, filename)</code></pre>
</section><br><br>

<p class="sub-section">Store a file using a stream</p>
<p>As an alternative to using the <span class="r-word">File</span>  API, you can call <span class="r-word">openFileOutput()</span>  to get a 
<span class="r-word">FileOutputStream</span>  that writes to a file within the <span class="r-word">filesDir</span>  directory.</p>

<p>The following code snippet shows how to write some text to a file:</p>

<section><pre><code class="language-kotlin">val filename="myfile"
val fileContents="Hello world!"
context.openFileOutput(filename, Context.MODE_PRIVATE).use {
        it.write(fileContents.toByteArray())
}</code></pre>
</section><br>

<p>We can see the file created in the <span class="negrita">Android Studio Device File Explorer</span> </p>

<figure><img src="./UD7/images/ud7_file_manager.gif" /><br><figcaption>Android Studio Device File Explorer</figcaption></figure>
<br>


<section class="marco-t warn">
    <span class="icono warning"> </span> Caution: On devices that run Android 7.0 (API level 24) or higher, unless you pass the <span class="negrita">Context.MODE_PRIVATE</span> 
     file mode into <span class="negrita">openFileOutput()</span> , a <span class="subrayado">SecurityException will be thrown</span> .
    </section>
<section class="marco-b">
        
</section>

<section class="marco-t inf">
    <span class="icono info"> </span> To allow other apps to access files stored in this directory within internal storage, use a FileProvider 
    with the <span class="negrita">FLAG_GRANT_READ_URI_PERMISSION</span>  attribute.
    </section>
<section class="marco-b">
        
</section>
    
<p class="sub-section">Access a file using a stream</p>
<p>To read a file as a stream, use <span class="r-word">openFileInput()</span> :</p>

<section><pre><code class="language-kotlin">context.openFileInput(filename).bufferedReader().useLines { lines ->
    lines.fold("") { some, text ->
        "$some\n$text"
    }
}</code></pre>
</section><br><br>

<p class="sub-section">View list of files</p>
<p>You can get an array containing the names of all files within the <span class="r-word">filesDir</span>  directory by calling <span class="r-word">fileList()</span>, 
    as shown in the following code snippet:</p>
<section><pre><code class="language-kotlin">var files: Array&lt;String>=context.fileList()</code></pre>
</section><br><br>

<p class="sub-section">Create nested directories</p>
<p>You can also create nested directories, or open an inner directory, by calling <span class="r-word">getDir()</span>:
<section><pre><code class="language-kotlin">context.getDir(dirName, Context.MODE_PRIVATE)</code></pre>
</section><br><br>
<section class="marco-t inf">
    <span class="icono info"> </span> Note: filesDir is always an ancestor directory of this new directory.
    </section>
<section class="marco-b">
        
</section>



<p class="sub-section">Create cache files</p>
<p>If you need to store sensitive data only temporarily, you should use the app's designated cache directory within internal storage to save the data. 
    As is the case for all app-specific storage, the files stored in this directory are removed when the user uninstalls your app, although the files in this directory 
    might be removed sooner.</p>

<p>To create a cached file, call <span class="r-word">File.createTempFile()</span> :</p>

<section><pre><code class="language-kotlin">File.createTempFile(filename, null, context.cacheDir)</code></pre>
</section><br><br>

Your app accesses a file in this directory using the <span class="r-word">cacheDir</span>  property of a context object and the <span class="r-word">File</span>  API:
<section><pre><code class="language-kotlin">val cacheFile=File(context.cacheDir, filename)</code></pre>
</section><br><br>

<p class="sub-section">Remove cache files</p>

<p>Even though Android sometimes deletes cache files on its own, you shouldn't rely on the system to clean up these files for you. 
    You should always maintain your app's cache files within internal storage.</p>

<p>To remove a file from the cache directory within internal storage, use one of the following methods:</p>


<p>The <span class="r-word">delete()</span>  method on a <span class="r-word">File</span>  object that represents the file:</p>

<section><pre><code class="language-kotlin">cacheFile.delete()</code></pre>
</section><br><br>

<p>The <span class="r-word">deleteFile()</span> method of the app's context, passing in the name of the file:</p>
<section><pre><code class="language-kotlin">context.deleteFile(cacheFileName)</code></pre>
</section><br><br>


<h3>Access from external storage</h3>
<p>If internal storage doesn't provide enough space to store app-specific files, consider using external storage instead. 
    The system provides directories within external storage where an app can organize files that provide value to the user only within your app. 
    One directory is designed for your app's persistent files, and another contains your app's cached files</p>

<p>On <span class="subrayado">Android 4.4 (API level 19) or higher</span>, your app doesn't need to request any storage-related permissions to access app-specific 
    directories within external storage. The files stored in these directories <span class="negrita">are removed when your app is uninstalled</span>.</p>

<section class="marco-t warn">
    <span class="icono warning"> </span> <span class="negrita">Caution</span> : The files in these directories aren't guaranteed to be accessible, such as when a removable 
    SD card is taken out of the device. If your app's functionality depends on these files, you should instead store the files within internal storage.
    </section>
<section class="marco-b">
        
</section>


<p>On devices that run <span class="subrayado">Android 9 (API level 28) or lower</span> , your app can access the app-specific files that belong to other apps, 
    provided that your app has the appropriate storage permissions. To give users more control over their files and to limit file clutter, 
    apps that target <span class="subrayado">Android 10 (API level 29) and higher</span>  are given scoped access into external storage, or scoped storage, by default. 
    When scoped storage is enabled, apps cannot access the app-specific directories that belong to other apps.</p>


<p class="sub-section">Verify that storage is available</p>

<p>Because external storage resides on a physical volume that the <span class="subrayado">user might be able to remove</span>, verify that the volume is accessible before trying
     to read app-specific data from, or write app-specific data to, <span class="negrita">external storage</span> .</p>

<p>You can query the volume's state by calling <span class="negrita">Environment.getExternalStorageState()</span> . If the returned state is <span class="r-word">MEDIA_MOUNTED</span>, 
    then you can read and write app-specific files within external storage. If it's <span class="r-word">MEDIA_MOUNTED_READ_ONLY</span> , you can only read these files.</p>

<p>For example, the following methods are useful to determine the storage availability:</p>

<section><pre><code class="language-kotlin">// Checks if a volume containing external storage is available
// for read and write.
fun isExternalStorageWritable(): Boolean {
    return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
}

// Checks if a volume containing external storage is available to at least read.
fun isExternalStorageReadable(): Boolean {
     return Environment.getExternalStorageState() in
        setOf(Environment.MEDIA_MOUNTED, Environment.MEDIA_MOUNTED_READ_ONLY)
}</code></pre>
</section><br>

<p class="sub-section">Select a physical storage location</p>


<p>Sometimes, a device that allocates a partition of its internal memory as external storage also provides an SD card slot. This means that the device has multiple physical volumes
     that could contain external storage, so you need to select which one to use for your app-specific storage.</p>

<p>To access the different locations, call <span class="negrita">ContextCompat.getExternalFilesDirs()</span> . As shown in the code snippet, the first element 
    in the returned array is considered the primary external storage volume. Use this volume unless it's full or unavailable.</p>

<section><pre><code class="language-kotlin">val externalStorageVolumes: Array&lt;out File> =
        ContextCompat.getExternalFilesDirs(applicationContext, null)
val primaryExternalStorage=externalStorageVolumes[0]</code></pre>
</section><br>

<p>if we print the path, it would be</p>

<section><pre><code class="language-kotlin">println(primaryExternalStorage.absolutePath)</code></pre>
</section><br>

<section><pre><code class="language-kotlin">/storage/emulated/0/Android/data/com.catata.filesexample/files</code></pre>
</section><br>

<p>If our device has a memory card and also HD, <span class="negrita">externalStorageVolumes[1]</span> probably be the SD card and its path woul be something like this</p>

<section><pre><code class="language-kotlin">val secondaryExternalStorage=externalStorageVolumes[1] //be careful because the card may have been removed and throw a NullPointerException
println(secondaryExternalStorage.absolutePath)

...
//OUTPUT
/storage/11EA-1213/Android/data/com.catata.filesexample/files</code></pre>
</section><br>

<p class="sub-section">Access persistent files</p>

<p>To access app-specific files from external storage, call <span class="r-word">getExternalFilesDir()</span>.</p>

<p>To help maintain your app's performance, don't open and close the same file multiple times.</p>

<p>The following code snippet demonstrates how to call <span class="negrita">getExternalFilesDir()</span>:</p>

<section><pre><code class="language-kotlin">val appSpecificExternalDir=File(context.getExternalFilesDir(null), filename)

//PATH
/storage/emulated/0/Android/data/com.catata.filesexample/files/my_file
</code></pre>
</section><br>

<section class="marco-t inf">
    <span class="icono info"> </span> On Android 11 (API level 30) and higher, apps cannot create their own app-specific directory on external storage.
    </section>
<section class="marco-b">
        
</section>
    
<p class="sub-section">Create cache files</p>
<p>To add an app-specific file to the cache within external storage, get a reference to the <span class="r-word">externalCacheDir</span>:</p>

<section><pre><code class="language-kotlin">val externalCacheFile=File(context.externalCacheDir, filename)</code></pre>
</section><br><br>

<p class="sub-section">Remove cache files</p>

<p>To remove a file from the external cache directory, use the <span class="r-word">delete()</span>  method on a <span class="r-word">File</span>  object that represents the file</p>

<section><pre><code class="language-kotlin">externalCacheFile.delete()</code></pre>
</section><br><br>

<p class="sub-section">Media content</p>
<p>If your app works with media files that provide value to the user only within your app, it's best to store them in app-specific directories within external storage, 
    as demonstrated in the following code snippet:</p>

    <section><pre><code class="language-kotlin">fun getAppSpecificAlbumStorageDir(context: Context, albumName: String): File? {
    // Get the pictures directory that's inside the app-specific directory on
    // external storage.
    val file=File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName)
    if (!file?.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created")
    }
    return file
}</code></pre>
    </section><br><br>

 <p>It's important that you use directory names provided by API constants like <span class="r-word">DIRECTORY_PICTURES</span>. These directory names ensure that the files 
    are treated properly by the system. If none of the pre-defined sub-directory names suit your files, you can instead pass <span class="negrita">null</span> 
     into <span class="negrita">getExternalFilesDir()</span> . This returns the root app-specific directory within external storage.</p>
    



    <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/DirectoriesFiles">Example of usage with directories and files on Github</a> 


    </section><!-- End section -->


    <!--*********************************************************Shared Preferences***********************************************************-->
    <section class="apartado">
    <a name="sShared"></a>
    <h2>Shared Preferences</h2>
    <p>Shared are intended to store small amounts of information through <span class="negrita">key-value</span>. 
        It must be uncommitted information since Android will generate an XML file where it will store all this information <span class="negrita">unencrypted</span>. 
    These files can be shared or private.</p>

    <p>In this project we are going to create a very simple application in which if there is no name saved, it will ask us to put it, 
        if on the contrary we already have one, it will appear on the screen together with a delete button. Another important part is that we will 
        make a <span class="negrita">design pattern</span> , the <span class="d-word">Singleton</span> .</p>
    
    <p>The first thing we will do is create a <span class="negrita">new project</span>  and we will make a very simple layout of the layout</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

   &lt;TextView
        android:id="@+id/tvName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

   &lt;EditText
        android:id="@+id/etName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:hint="Write your name"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

   &lt;Button
        android:id="@+id/btnDeleteValue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Delete"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent" />

   &lt;Button
        android:id="@+id/btnSaveValue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Save"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
            </section>
    </section>
    
    <p>You will see that there are components that are overlapping on each other, this is because in this way we're going to show the possible cases that a view can have.</p>
        
    <p>The next thing we will do is create a class where we will define everything necessary to work with shared, we will call it <span class="d-word">Prefs</span>.
        This class will receive a <span class="negrita">context</span> , in this case that of the application, to be able to instantiate it only once when starting
        the application and have a <span class="negrita">pref object</span> .</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">Prefs.kt</span>
        </section>
    <section class="marco-b">
<section><pre><code class="language-kotlin">class Prefs (context: Context) {
    val prefs: SharedPreferences =context.getSharedPreferences (PREFS_NAME, Context.MODE_PRIVATE)
    var name: String
        get ()=prefs.getString(SHARED_NAME, "") ?: ""
        set (value)=prefs.edit().putString (SHARED_NAME, value).apply ()

    companion object {
        const val PREFS_NAME="com.catata.sharedpreferencesexample"
        const val SHARED_NAME="shared_name"
    }
}</code></pre>
            </section>
    </section>

    <p>The first thing we have done has been to define two constants, <span class="d-word">PREFS_NAME</span>  and <span class="d-word">SHARED_NAME</span>, 
        the first will be the key of the <span class="negrita">pref object</span>  that we will create later and the second the key of the name that we will store. 
        Remember that shared preferences are stored with key-value, which means that to request the value of "<span class="negrita">yam</span>" we need to request it through the SHARED_NAME key.</p>
    
    <p>Also note that we have defined a <span class="d-word">yam</span>  variable that will be where we store the name as I said before, 
        but that we have <span class="subrayado">overridden the get and set method</span>, so when we ask for the value of name, it will access the prefs object 
        and request that value corresponding to the <span class="d-word">SHARED_NAME</span>  key. The same with the set, that through <span class="d-word">prefs.edit(). 
        PutString (SHARED_NAME, value).apply()</span> store the value we tell it. Obviously if it were another type of variable, for example an <span class="negrita">Int</span>, 
        we would change the <span class="negrita">putString()</span>  for a putInt() and so on with each type of variable.</p>
    
    <p>Now we are going to create a somewhat different class. This class will extend <span class="r-word">Application ()</span> and that means that it will 
        <span class="negrita">be the first thing to run</span> when the application is opened.</p>

        <p>Remember that to extend this class in Kotlin it is very simple, we simply have to create a class as usual and after the name after a colon, 
            we will put the class in question.</p>
        

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">SharedApp.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">class SharedApp: Application () {
    companion object {
        lateinit var prefs: Prefs
    }
    override fun onCreate () {
        super.onCreate ()
        prefs=Prefs (applicationContext)
    }
}</code></pre>
            </section>
    </section>
    
    <p>Although the class is quite small, we are going to comment on some things. To begin, we have declared a <span class="negrita">companion object</span>  that will be the 
        object of our <span class="d-word">Prefs</span>  class that we will use throughout the project, so for you to understand the companion object is a way 
        to have an object available throughout the project (a static object for those who know java). And in front of it there is a <span class="r-word">lateinit</span> 
         that means that it will be instantiated later, in this example in the <span class="r-word">onCreate()</span>  method of this class.</p>
    
    <p>Remember that for this class to be launched when opening the app we must go to <span class="inline-file">AndroidManifest.xml</span> and add 
        <section><pre><code class="language-xml">android: name=".SharedApp"</code></pre>
        </section><br><br> inside the&lt;Application> open tag</p>

    <p>Now we will go to our <span class="d-word">MainActivity</span>  to develop some logic.</p>
        
    <p>The idea is to create <span class="subrayado">two methods</span> , one will show a view for guests and the other the view of the profile, the difference between them will be that if you are 
        invited it will show you an EditText and a save button and on the contrary if there is already a name saved in data persistence as it will greet user and will 
        have a button to delete that field from memory.</p>
    
        <section><pre><code class="language-kotlin">fun showProfile() {
    binding.tvName.visibility=View.VISIBLE
    binding.tvName.text="Hello ${SharedApp.prefs.name}"
    binding.btnDeleteValue.visibility=View.VISIBLE
    binding.etName.visibility=View.INVISIBLE
    binding.btnSaveValue.visibility=View.INVISIBLE
}
fun showGuest () {
    binding.tvName.visibility=View.INVISIBLE
    binding.btnDeleteValue.visibility=View.INVISIBLE
    binding.etName.visibility=View.VISIBLE
    binding.btnSaveValue.visibility=View.VISIBLE
}</code></pre>
        </section>

    <p>As you already know, a component can be in three visibility states:</p>
    <ul>
        <li><span class="negrita">Visible</span>: The component is seen on the screen, this option is activated by default.</li>
        <li><span class="negrita">Invisible</span>: The component is not visible but it is still on the screen, so you can continue working with it, 
            for example putting something to the right of an invisible component.</li>
        <li><span class="negrita">Gone</span> : The component is NOT on the screen so there is no interaction possible.</li>
    </ul>

    <p>Notice that the <span class="d-word">showProfile</span> method assigns a value to <span class="d-word">tvName</span>, which means that it is accessing
         the <span class="negrita">shared preferences</span>. To do this we simply call the <span class="d-word">SharedApp</span>  class (the one that contains 
         the companion object), the object we are talking about and the name attribute that, as we saw before, we have modified so that when we do a get 
         (remove the information it stores) it asks for our shared preference the value of <span class="d-word">SHARED_NAME</span> .</p>
    
    <p>Now we need a method that checks if there is information in name and thus check if the user has saved his name.</p>
    
    <section><pre><code class="language-kotlin">fun configView () {
    if (isSavedName()) showProfile() else showGuest()
}

fun isSavedName (): Boolean {
    val myName=SharedApp.prefs.name
    return myName!=EMPTY_VALUE
}</code></pre>
    </section>

        <p>The whole class would look like this.</p>
        <section class="marco-t file-">
            <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
            </section>
        <section class="marco-b">
                       
<section><pre><code class="language-kotlin">import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import com.cartatar.sharedpreferencesexample.databinding.ActivityMainBinding

class MainActivity: AppCompatActivity () {
    private lateinit var binding: ActivityMainBinding

    val EMPTY_VALUE=""

    override fun onCreate (savedInstanceState: Bundle?) {
        super.onCreate (savedInstanceState)
        setContentView (ActivityMainBinding.inflate (layoutInflater) .also {binding=it} .root)

        binding.btnSaveValue.setOnClickListener {
            SharedApp.prefs.name=binding.etName.text.toString ()
            configView ()
        }
        
        binding.btnDeleteValue.setOnClickListener {
            SharedApp.prefs.name=EMPTY_VALUE
            configView ()
        }
    }


    fun showProfile () {
        binding.tvName.visibility=View.VISIBLE
        binding.tvName.text="Hello ${SharedApp.prefs.name}"
        binding.btnDeleteValue.visibility=View.VISIBLE
        binding.etName.visibility=View.INVISIBLE
        binding.btnSaveValue.visibility=View.INVISIBLE
    }

    fun showGuest () {
        binding.tvName.visibility=View.INVISIBLE
        binding.btnDeleteValue.visibility=View.INVISIBLE
        binding.etName.visibility=View.VISIBLE
        binding.btnSaveValue.visibility=View.VISIBLE
    }

    fun configView () {
        if (isSavedName ()) showProfile () else showGuest ()
    }

    fun isSavedName (): Boolean {
        val myName=SharedApp.prefs.name
        return myName!=EMPTY_VALUE
    }
}</code></pre>
</section>
</section>
<section class="marco-t warn">
    <span class="icono warning"> </span> Remember to enable view binding
    </section>
<section class="marco-b">
        
</section>

    
<figure><img src="./UD7/images/UD7-shared_example.gif" /><br><figcaption>App running</figcaption></figure>
<br>


<p>Here is where the shared preference is saved in xml file. Note the name of the file (<span class="negrita">com.catata.sharedpreferencesexample.xml</span>)
     and the name of the SharedPreference (<span class="negrita">shared_name</span>)</p>

<figure><img src="./UD7/images/ud7_shared_preferences_path.gif" /><br><figcaption>Shared Preferences</figcaption></figure>
<br>



<p>Here's a <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/SharedPreferences"> link </a> to Github with another example of using <span class="negrita">Shared Preferences</span>.
    Notice that we have two methods to access the SharedPreferences. On the one hand we have <span class="r-word">getPreferences</span> , which obtains the normal and global 
    preferences and on the other hand we have, <span class="r-word">getSharedPreferences</span>  method to which we give a name of the preferences file, in case we want to have several files and separate the information</p>


<br><br>
<p>Here is another <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/DirectoriesFilesSharedDao"> link </a> to Github with an example 
    where we implement the <span class="negrita">DAO pattern</span> and also with <span class="negrita">ViewModel pattern</span> to access the saved data by means of a file through SharedPreferences.</p>


    <h3>Settings Screen</h3>

    <p>In this section we will see how to implement a settings screen using SharedPreferences</p>

    <p>To start we are going to create a project from <span class="negrita">empty activity</span> template and name the App as <span class="d-word">SharedSettings</span> </p>

    <p>The first thing we will do is add the dependencies, remember to also enable the <span class="negrita">viewBinding</span> .</p>
    
    <section><pre><code class="language-kotlin">def nav_version="2.5.3"
implementation ("androidx.navigation:navigation-fragment-ktx:$nav_version")
implementation ("androidx.navigation:navigation-ui-ktx:$nav_version")

// Preferences
def preference_version="1.2.0"
implementation ("androidx.preference:preference-ktx:$preference_version")</code></pre>
    </section><br><br>

    <p>We are going to create a menu with a couple of options, one of them will not do anything, it is simply as an example to show the usefulness of the <span class="r-word">orderInCategory</span> property.</p>
    
    <p>So, we create the menu <span class="inline-file">my_menu.xml</span> inside the <span class="inline-folder">res/menu</span> directory</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">my_menu.xml</span>
        </section>
    <section class="marco-b">
         <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools" tools:context=". MainActivity">
   &lt;item
        android:id="@+id/action_settings"
        android:title="@string/action_settings"
        android:orderInCategory="100"
        app:showAsAction="never" />
   &lt;item
        android:id="@+id/action"
        android:title="@string/action"
        android:orderInCategory="10"
        app:showAsAction="never" />
&lt;/menu></code></pre>
         </section><br><br>   
    </section>
    
    <p>Now we are going to create the layout of the <span class="d-word">MainActivity</span> , in this case it will only contain a fragment container.</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
         <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=". MainActivity">

   &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/container_main"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="com.cartatar.sharedsettings.MainFragment"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
         </section><br><br>   
    </section>
    
    <p>As you can see, it is going to contain the <span class="d-word">MainFragment</span>  fragment, so you create a new blank fragment with this name.  <br>
        In the layout, <span class="inline-file">fragment_main.xml</span> we are going to add a TextView </p>
    

    <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainFragment">

   &lt;TextView
        android:id="@+id/tvInfo"
        android:text="Shared Preferences\nin Settings Screen"
        android:layout_gravity="center"
        android:textSize="25sp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

&lt;/FrameLayout></code></pre>
    </section><br><br>

    <p>Now it is the turn of the MainActivity, we are going to link the menu created previously so that it is loaded in the activity, and we are also going to add a method 
        so that it responds to the actions of the menu created.
    <br>For this we are going to override two methods in the <span class="inline-file">MainActivity.kt</span>.</p>
    <section><pre><code class="language-kotlin">override fun onCreateOptionsMenu (menu: Menu?): Boolean {
    menuInflater.inflate (R.menu.my_menu, menu)
    return true
}

override fun onOptionsItemSelected(item: MenuItem): Boolean {

    when (item.itemId) {
        R.id.action_settings -> {
            startActivity (Intent(this, SettingsActivity::class.java))
        }
    }
    return super.onOptionsItemSelected(item)
}</code></pre>
    </section><br><br>

    <p>The first, <span class="r-word">onCreateOptionsMenu</span> , is the one that loads or inflates the menu and the second is the one that is executed 
        when we select an item from our menu. <br>As you can see, we give you which item has been selected and based on its ID we do one thing or another, 
        in our case we only respond to the item whose id is action_settings and what we do is open the activity that contains the settings screen.</p>

    <p>So MainActivity would look like this</p>
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">class MainActivity:AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    override fun onCreate (savedInstanceState:Bundle?) {
        super.onCreate (savedInstanceState)
        setContentView (ActivityMainBinding.inflate(layoutInflater).also{binding=it}.root)


    }


    override fun onCreateOptionsMenu (menu: Menu?): Boolean {
        menuInflater.inflate (R.menu.my_menu, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {

        when(item.itemId) {
            R.id.action_settings -> {
                startActivity (Intent(this, SettingsActivity::class.java))
            }
        }
        return super.onOptionsItemSelected (item)
    }


}</code></pre>
            </section>
    </section>

    <p>Notice we haven't created the <span class="negrita">SettingsActivity</span> yet</p>
    
    
    <p>Now what we will do is add in <span class="d-word">MainFragment</span>  a listener of the <span class="r-word">SharedPreferences</span> 
         so that it reacts when they are modified, in our case the only thing we will do is show it in a TextView. So <span class="inline-file">MainFragment</span> would look like this</p>
    
    <section><pre><code class="language-kotlin">class MainFragment:Fragment() {

    private lateinit var binding: FragmentMainBinding

    //listener is listening for every change on the SharedPreferences
    private lateinit var listener: SharedPreferences.OnSharedPreferenceChangeListener

    override fun onCreateView (
        inflater: LayoutInflater, container: ViewGroup ?,
        savedInstanceState: Bundle ?,
    ): View? {
        // Inflate the layout for this fragment
        return FragmentMainBinding.inflate (
            inflater,
            container,
            false
        ) .also {binding=it} .root
    }

    override fun onViewCreated (view: View, savedInstanceState: Bundle?) {
        super.onViewCreated (view, savedInstanceState)

        /* Obtaining SharedPreferences */
        val sharedPreferences: SharedPreferences =
            PreferenceManager.getDefaultSharedPreferences(requireContext()/* Activity context */)

        //Making the callback of the listener
        listener=SharedPreferences.OnSharedPreferenceChangeListener {prefs, key ->
            //Array with all the preferences
            val preferences=prefs.all
            
            //The key contains the name of the changed preference
            val s=preferences [key] .toString ()
            //Write the changed shared into TextView
            binding.tvInfo.text=s
        }

        //we register the listener
        sharedPreferences.registerOnSharedPreferenceChangeListener (listener)

    }

}</code></pre>
    </section>

    <p class="sub-section">Creating the settings screen.</p>
    <p>First we create <span class="d-word">SettingsActivity</span>  from an empty activity template</p>
    <p>The <span class="inline-file">activity_settings.xml</span> layout will simply have a fragment container.</p>

    <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".SettingsActivity">
   &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/container_settings"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:name="com.cartatar.sharedsettings.SettingsFragment"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
    </section><br><br>

    <p>As you can see, the container is waiting for <span class="d-word">SettingsFragment</span> , but in this case it is a special fragment since it extends
         <span class="r-word">PreferenceFragmentCompat</span> . This class contains the <span class="r-word">onCreatePreferences</span>  method, which is the one that will 
         load the xml with the definition of the settings. SettingsFragment won't have layout file</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">SettingsFragment.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">class SettingsFragment:PreferenceFragmentCompat() {

    override fun onCreatePreferences (savedInstanceState: Bundle ?, rootKey: String?) {
        setPreferencesFromResource(R.xml.my_settings, rootKey)
        preferenceFragmentCompat=this
    }

    companion object {
        var preferenceFragmentCompat:PreferenceFragmentCompat?=null
    }
}</code></pre>
            </section>
    </section>
    
    <p>We create a companion object in case we want to access any of its preferences, we would do it with this code:</p>
    

    <section><pre><code class="language-kotlin">val preference=preferenceManager.preferenceScreen.findPreference&lt;Preference>("preference_key")</code></pre>
    </section><br><br>
    <p>In addition, the <span class="r-word">setPreferencesFromResource</span>  method passes as a parameter the <span class="inline-file">my_settings.xml</span> 
        file that is inside the <span class="inline-folder">res/xml</span> directory. Well, let's make it.</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">res/xml/my_settings.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.preference.PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

   &lt;PreferenceCategory
        android:key="category1"
        android:title="First Category">

       &lt;SwitchPreferenceCompat
            app:key="Notifications"
            app:title="Activate Notifications" />

       &lt;Preference
            app:key="feedback"
            app:title="Send feedback"
            app:enabled="false"
            app:summary="Report technical issues or suggest new features" />
   &lt;/PreferenceCategory>
   &lt;PreferenceCategory
        android:key="Category2"
        android:title="Second Category">


       &lt;ListPreference
            android:defaultValue="1"
            android:entries="@array/country"
            android:entryValues="@array/cod_country"
            android:key="list_preference_1"
            android:title="List preference" />

       &lt;EditTextPreference
            android:defaultValue="Default value"
            android:key="edit_text_preference_1"
            android:selectAllOnFocus="true"
            android:singleLine="true"
            android:title="Edit text preference" />

       &lt;Preference
            app:key="activity"
            app:title="Go activity 2">
           &lt;intent
                android:targetPackage="com.cartatar.sharedsettings"
                android:targetClass="com.cartatar.sharedsettings.MainActivity2" />
       &lt;/Preference>
   &lt;/PreferenceCategory>

&lt;/androidx.preference.PreferenceScreen></code></pre>
            </section>
    </section>
    
    <br><br>
    <p>
        As you can see we have put a small selection of elements that you can implement. For example, a switch, a list, an EditText or even a preference so that 
        clicking on it will take us to another activity.
    </p>
    <p>Let's highlight, for example, ListPreference, we see that it has some entries that is an array, this is the texts that will be displayed and an entriesValues, 
        another array with the real values ​​that will have the preference whose key is <span class="negrita">list_preference_1</span> </p>

    <p>As it refers to some arrays, let's create them inside the <span class="inline-folder">res / values</span> ​​folder, inside a file called, for example, <span class="inline-file">cod_countries.xml</span>. And whose content will be:</p>
    
    <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;resources>
   &lt;string-array name="country">
       &lt;item>Spain&lt;/item>
       &lt;item>France&lt;/item>
       &lt;item>Germany&lt;/item>
   &lt;/string-array>
   &lt;string-array name="cod_country">
       &lt;item>SPA&lt;/item>
       &lt;item>FRA&lt;/item>
       &lt;item>GER&lt;/item>
   &lt;/string-array>
&lt;/resources></code></pre>
    </section><br><br>

    
<a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/SettingScreen">Here</a>  you can see the whole code of the example.
 <br><br>

<div class="tarea">
    <span class="negrita">Activity</span>. <br>
    Make an App with just one Activity and one menu option, this option launches the settings screen that contains a ListPreference with 3 or 4 colors for the background of the application, another ListPreference with 3 or 4 colors for the color 
    of the text and an EditTextPreference to change the title of the application
</div>

<br><br>
<div><a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/ChangeColorsSettings">Here</a>  you have a possible solution. 
    Please, try to do it by yourself before</div>


    </section><!-- End section -->

    <!--*********************************************************Room***********************************************************-->
    <section class="apartado">
    <a name="sRoom"></a>
    <h2>Room</h2>
    

    <p>Once we have seen some local persistence methods, we are going to see the handling of databases, in this case with
    
    <a class="enlace" target="_blank" href="https://developer.android.com/training/data-storage/sqlite">SQLite</a>. 
    But as noted on the SQLite lite page, on this one, they highly recommend using the 
    <a class="enlace" target="_blank" href="https://developer.android.com/training/data-storage/room"> Room </a> persistence library.
    
</p>

    <section class="marco-t warn">
        <span class="icono warning"> </span> <span class="negrita">Caution</span>: Although these APIs are powerful, they are characterized by being quite specific and their use requires
         a lot of time and effort.
        <li>There is no compile-time verification of raw SQL queries. As your data graph changes, you must manually update the affected SQL queries.
        This process can be time consuming and cause errors.</li>
        <li>You must use a lot of standard code to convert between SQL queries and data objects.</li>
        For these reasons, <span class="negrita">we highly recommend</span>  using the <span class="r-word">Room Persistence Library</span>  as an abstraction layer to access information from your app's SQLite databases.
        </section>
    <section class="marco-b">
            
    </section>
    

    <p>To learn how to use <span class="r-word">Room</span>  we will create an application to <span class="subrayado">manage our tasks</span>. 
        We will add a task in the corresponding field, we will have a <span class="cursiva">CheckBox</span>  to see if the task is done or not, 
        we can change its status by checking and unchecking the <span class="cursiva">Check box</span>  and finally if we click on a task it will be eliminated.</p>
    

    <p>It is already beginning to be an App of a certain level. For the realization of this App we will need applications knowledge about:</p>
    <ul>
        <li><span class="negrita">RecyclerView</span> : The tasks will be shown as elements of the list.</li>
        <li><span class="negrita">Room</span> : Database creation and access.</li>
        <li><span class="negrita">ViewModel</span> : To separate the business logic from the views.</li>
        <li><span class="negrita">DAO pattern</span> : To make persistence mode independent of logic.</li>
        <li><span class="negrita">Corroutines</span> : To launch the DAO functions in a different thread from the main one.</li>

    </ul>
    <br><br>

    <p>The application will look something like this:</p>
    

    <figure><img src="./UD7/images/UD7-Room_running_app.gif" /><figcaption>Running app</figcaption></figure>
    <br>
    
    <p>The first thing we will do is create a new application from the <span class="negrita">Empty Activity</span>  template.</p>
    

    <h3>Adding dependencies</h3>

    <p>Once loaded in Android Studio we will add the necessary dependencies:</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">Gradle Module App</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">//RecycleView
def recycler_version="1.2.1"
implementation "androidx.recyclerview:recyclerview:$recycler_version"

//Room
def room_version="2.4.3"
implementation "androidx.room:room-runtime:$room_version"
kapt "androidx.room:room-compiler:$room_version"
implementation "androidx.room:room-ktx:$room_version"

// Lifecycle libraries
def lifecycle_version="2.5.1"
implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"
implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"</code></pre>
            </section>
    </section>
    

    <p>We also add the activation of <span class="negrita">viewBinding</span> in the same file</p>
    

    <section><pre><code class="language-kotlin">buildFeatures{
        viewBinding true
    }</code></pre>
    </section><br><br>
    
    <p>As we can see we are going to make use of the Kapt method, in order to use it we will have to apply the plugin. 
        To do this in the same <span class="inline-file">Gradle Module App</span> file, in the plugins section we add it.</p>
    
    <section><pre><code class="language-kotlin">plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlin-kapt' 
}</code></pre>
    </section><br><br>

    <p>Finally, as we have used variables for the versions, we can define them as always, making use of "<span class="negrita">def</span>" or if we want it to be of 
        global use we go to the <span class="inline-file">gradle file of the project</span> and add an <span class="negrita">ext</span>  object with the definition and value of the variables.</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">Gradle Project</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">buildscript {
    ext {
        room_version = '2.4.3'
        recycler_version = '1.2.1'
        lifecycle_version = '2.5.1'
    }
}

plugins {
    .......
}</code></pre>
            </section>
    </section>

    <h3>Directory structure</h3>
    
    <p>Next we are going to create some files, so as keep an eye on of where we are and to be more organized we are going to create the necessary packages.</p>
    

    <figure><img src="UD7/images/ud7-2021-12-02-15-28-31.png" /><br><figcaption>Dir structure</figcaption></figure>
    <br>
    
    <p>Note that <span class="d-word">MainActivity</span>  we have included it within a package called <span class="negrita">ui</span> , since it takes care of the view.
    We also have a package with everything related to data. We have the entities package, where we will define our model.
    We also have created two interfaces to implement the <span class="negrita">DAO</span>  and <span class="d-word">TaskDatabase</span>  pattern with the 
    creation and definition of the <span class="negrita">Room Database</span> .
    We have an adapters package where we will have the <span class="negrita">RecyclerView</span>  adapter and finally the viewmodel package where we will have our <span class="negrita">ViewModel</span> .</p>
    

    <h3>Starting to create files</h3>

    <p>Let's start, the first thing we will do is create our model or in <span class="negrita">Room</span> terminology the entity.</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">TaskEntity.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "task_entity")
data class TaskEntity (
    @PrimaryKey(autoGenerate = true)
    var id:Int = 0,
    var name:String = "",
    var isDone:Boolean = false
)</code></pre>
            </section>
    </section>

    <p>As we can see we use the <span class="negrita">Entity decorator</span> , which allows us to assign the name of the table that will contain our tasks entity.
    We can also see that we have defined an id attribute that will be the primary key and will also be generated by itself.
    Finally, <span class="d-word">TaskEntity</span>  has a task name and a <span class="cursiva">Boolean</span>  <span class="negrita">isDone</span>  attribute, which tells us if the task has been completed or not.</p>
    


    <p class="sub-section">Dao Pattern (Data Access Object)</p>
    
    <p>Now we are going to create the Dao pattern. Room defines its own <span class="negrita">Dao pattern</span> <span class="subrayado"> through decorators</span>, 
        but we will create a more generic interface in case we want to use another type of persistence such us Files. In this interface we will define the methods that we can use.</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MyDao.kt</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-kotlin">import com.catata.tasknotesroom.database.entities.TaskEntity

interface MyDao {
    fun getAllTasks(): MutableList&lt;TaskEntity>

    fun addTask(taskEntity : TaskEntity):Long //Id of the new  task

    fun getTaskById(id: Long): TaskEntity

    fun updateTask(taskEntity: TaskEntity):Int //Number of affected rows

    fun deleteTask(taskEntity: TaskEntity):Int //Number of affected rows
}</code></pre>
        </section>
    </section>


    <p>As we can see, we have a method to recover all the tasks, another to recover a task given its ID, another to update a task and finally another to delete it.
    The last two methods return the number of rows affected in the operation.</p>
      
    
    <h3>RecyclerView</h3>

    <p>To continue we are going to implement the <span class="negrita">recyclerview</span>  part. The first thing is to add it to the layout of the main activity.
    We will also add a small form to add new tasks.</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/background_light"
    tools:context="com.catata.tasknotesroom.ui.MainActivity">
    &lt;androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvTask"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@+id/rlAddTask"/>
    &lt;RelativeLayout
        android:id="@+id/rlAddTask"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:elevation="10dp"
        android:layout_margin="10dp"
        android:background="@android:color/white">
        &lt;EditText
            android:id="@+id/etTask"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:hint="Add a Task"
            android:layout_alignParentLeft="true"
            android:layout_toLeftOf="@+id/btnAddTask"
            />
        &lt;Button
            android:id="@+id/btnAddTask"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentRight="true"
            android:textAllCaps="false"
            android:backgroundTint="#FFAAAAAA"
            android:text="Add"/>
    &lt;/RelativeLayout>
&lt;/RelativeLayout></code></pre>
            </section>
    </section>
    

    <p>It is done with <span class="r-word">RelativeLayout</span>  but it could be done with any other Layout that we consider more comfortable.</p>
    

    <p>Next we are going to create the view adapter with its corresponding <span class="r-word">ViewHolder</span> .</p>
    

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">adapters/TaskAdapter.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.catata.tasknotesroom.R
import com.catata.tasknotesroom.database.entities.TaskEntity

class TasksAdapter(
    val tasks: List&lt;TaskEntity>,
    val checkTask: (TaskEntity) -> Unit,
    val deleteTask: (TaskEntity) -> Unit) : RecyclerView.Adapter&lt;TasksAdapter.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val layoutInflater = LayoutInflater.from(parent.context)
        return ViewHolder(layoutInflater.inflate(R.layout.item_task, parent, false))
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val item = tasks[position]
        holder.bind(item, checkTask, deleteTask)
    }


    override fun getItemCount() = tasks.size


    class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {

        val tvTask = view.findViewById&lt;TextView>(R.id.tvTask)
        val cbIsDone = view.findViewById&lt;CheckBox>(R.id.cbIsDone)

        fun bind(task: TaskEntity, checkTask: (TaskEntity) -> Unit, deleteTask: (TaskEntity) -> Unit) {
            tvTask.text = task.name
            cbIsDone.isChecked = task.isDone
            cbIsDone.setOnClickListener{checkTask(task)}
            itemView.setOnClickListener { deleteTask(task) }
        }
    }
}</code></pre>
            </section>
    </section>
    
    <p>As we can see in the constructor, we pass it a <span class="negrita">list of tasks</span>  and <span class="negrita">two callbacks</span> , one for when we click on the
         <span class="cursiva">Check box</span>  for the task performed and another for when we click on the entire element,
    in which case we would delete said task. In this case we create within the <span class="r-word">ViewHolder</span>  the bind function that does all this task.</p>


    <p>As you know, now we have to make tha layout for every item in the RecyclerView <span class="inline-file">item_task.xml</span> in the <span class="inline-folder">layout</span> dir, this layout could looks like this</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">item_task.xml</span>
        </section>
    <section class="marco-b">
               
    <section><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="horizontal"
    android:layout_margin="10dp">

    &lt;CheckBox
        android:id="@+id/cbIsDone"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginRight="10dp"
        android:layout_marginEnd="10dp" />

    &lt;TextView
        android:id="@+id/tvTask"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textStyle="bold"
        android:textSize="18sp"
        tools:text="Test"/>

&lt;/LinearLayout></code></pre>
    </section>
    </section>
    

    <p>Before seeing how the MainActivity implementation would be, let's see how to implement the Database with Room.</p>


    <h3>Room</h3>
    
    <p>The <span class="negrita">Room library</span>  is an access layer to <span class="negrita">SQLite</span>  databases in Android applications. 
        Provides an easy way to create and access the database. <span class="subrayado">It uses object-relational mapping</span> , which consists of each row in a database 
        table corresponding to an object. It is also designed to easily integrate with the MVVM architecture.</p>
    

<p>To use the <span class="negrita">Room library</span>  you have to define 3 components:</p>

<ul>
    <li><span class="negrita">Database</span> : contains the reference to the database.</li>
    <li><span class="negrita">Entity</span>: represents a database table.</li>
    <li><span class="negrita">Dao</span>: It contains the methods with the queries to access the database. Will implement our dao MyDao</li>
</ul>

<p class="sub-section">TaskDao</p>
<p><span class="d-word">TaskDao</span>  will be the interface that will contain the queries to the database, we will implement our <span class="d-word">MyDao</span>  in it. 
    Here we will distinguish four kind of queries.</p>

<ul>
<li><span class="negrita">@Query:</span> Queries are made directly to the database, we will use SQL to do them. In this example we will do two very simple ones, but impressive things can be done.</li>
<li><span class="negrita">@Insert:</span> It will be used to insert entities into the database, unlike <span class="negrita">@Query</span> , you do not have to do any kind of query, but rather pass the object to insert.</li>
<li><span class="negrita">@Update:</span> They update an already inserted entity. We will only have to pass that modified object and it already takes care of updating it. 
    How do you know which object to modify? Well, because of our id (remember that it is the PrimaryKey).</li>
<li><span class="negrita">@Delete:</span>  As its name indicates, it deletes an object that we pass to it from the table.</li>
</ul>


<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">TaskDao.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">import androidx.room.*
import com.catata.tasknotesroom.database.entities.TaskEntity

@Dao
interface TaskDao:MyDao {
    @Query("SELECT * FROM task_entity")
    override fun getAllTasks(): MutableList&lt;TaskEntity>

    @Insert
    override fun addTask(taskEntity : TaskEntity):Long

    @Query("SELECT * FROM task_entity WHERE id LIKE :id")
    override fun getTaskById(id: Long): TaskEntity

    @Update
    override fun updateTask(taskEntity: TaskEntity):Int

    @Delete
    override fun deleteTask(taskEntity: TaskEntity):Int
}</code></pre>
        </section>
</section>


<p class="sub-section">Database</p>

<p>To create the database, a class must be created that must:</p>

<ul>
    <li>Be abstract</li>
    <li>Extend <span class="negrita">RoomDatabase</span> </li>
    <li>Be annotated with <span class="negrita">@Database</span> </li>
    <li>Include the list of entities within the <span class="negrita">@Database</span>  annotation</li>
    <li>Contain an abstract method that returns the class annotated with <span class="negrita">@Dao</span> </li>
</ul>

<p>Inside the class, the static method <span class="r-word">Room.databaseBuilder ()</span>  is called <span class="subrayado">to obtain the reference to the database</span>.</p>


<p>It is convenient to use the <span class="negrita">singleton pattern</span> , which ensures that there will only be a single instance of the database.</p>


<p>Create the TaskDatabase.kt class:</p>


<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">TaskDatabase.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import com.catata.tasknotesroom.database.entities.TaskEntity

@Database(entities = arrayOf(TaskEntity::class), version = 1)
abstract class TasksDatabase : RoomDatabase() {
    abstract fun taskDao(): TaskDao

    companion object{ //Singleton Pattern
        private var instance:TaskDao? = null

        fun getInstance(context: Context):TaskDao{
            return instance ?: Room.databaseBuilder(context, TasksDatabase::class.java, "tasks-db").build().taskDao().also { instance = it }
        }
    }
}</code></pre>
        </section>
</section>


<p>The first thing to look at is the <span class="negrita">@Database</span>  annotation, which specifies that the entity will be a list of <span class="d-word">TaskEntity</span> 
     (entity that we have already created) and that the <span class="negrita">version</span>  is 1.
Versions are used for possible data migration when updating the App.
Let's imagine that we release a second version of the app and instead of 3 parameters we store 4, we cannot change our entity at once because there would be problems.
For that, the version is used, together with a migration file that tells the program what it will have to do to go from version 1 to version 2, 3 or whatever.</p>


<p>We must also make sure that our class extends from <span class="r-word">RoomDatabase()</span>  which is a class that we have thanks to importing the <span class="negrita">Room</span> 
    dependency in our gradle.
Finally, it has a single function that refers to the <span class="negrita">DAO</span>  that we have created previously, if we had more Dao's then we would have to 
implement them there as well.</p>


<p>The database instance will need three parameters, the <span class="negrita">context</span>  (<span class="d-word">this</span> ), <span class="negrita">the class</span> 
     of our database (<span class="d-word">TasksDatabase</span> ) and the <span class="negrita">database name</span>  that we will give it, in this case we have called it "<span class="d-word">trasks-db</span>".</p>



<h3>ViewModel</h3>

<p>It is time to implement our <span class="r-word">ViewModel</span> , in this case we have chosen to create a <span class="r-word">LiveData</span> 
     for each of the methods implemented in the database.
These methods will give responses to the requests of the View (MainActivity + RecyclerView)</p>


<section><pre><code class="language-kotlin">val taskListLD:MutableLiveData&lt;MutableList&lt;TaskEntity>> = MutableLiveData()
val updateTaskLD:MutableLiveData&lt;TaskEntity?> = MutableLiveData()
val deleteTaskLD:MutableLiveData&lt;Int> = MutableLiveData()
val insertTaskLD:MutableLiveData&lt;TaskEntity> = MutableLiveData()</code></pre>
</section><br>

<p>We have also added a <span class="d-word">myDao</span>  variable which is what we will use to implement the <span class="negrita">Dao pattern</span>. 
    In this case, we initialize it directly to the <span class="d-word">TaskDao</span>  of our <span class="d-word">TaskDatabase</span> .</p>


<section><pre><code class="language-kotlin">var myDao:MyDao = TasksDatabase.getInstance(context)</code></pre>
</section><br><br>

<p>Finally, we implement the 4 methods that we will need. These methods call the corresponding <span class="d-word">MyDao</span>  method within a <span class="negrita">Corroutine</span> 
     so as not to get in the way of the main thread.</p>


<section><pre><code class="language-kotlin">fun getAllTasks(){
        viewModelScope.launch(Dispatchers.IO) {
            taskListLD.postValue(myDao.getAllTasks())
        }

    }
    fun add(task:String) {
        viewModelScope.launch(Dispatchers.IO) {
            val id = myDao.addTask(TaskEntity(name = task))
            val recoveryTask = myDao.getTaskById(id)
            insertTaskLD.postValue(recoveryTask)
        }
    }

    fun delete(task:TaskEntity){
        viewModelScope.launch(Dispatchers.IO) {

            val res = myDao.deleteTask(task)
            if(res>0)
                deleteTaskLD.postValue(task.id)
            else{
                deleteTaskLD.postValue(-1)
            }


        }
    }

    fun update(task:TaskEntity){
        viewModelScope.launch(Dispatchers.IO) {
            task.isDone = !task.isDone
            val res = myDao.updateTask(task)
            if(res>0)
                updateTaskLD.postValue(task)
            else
                updateTaskLD.postValue(null)
        }
    }</code></pre>
</section><br>

<p>Note that the scope of the coroutine is viewModelScope since we are inside the viewmodel, so the coroutine will live, at most, as long as the viewmodel is alive.</p>

<p>The TaskViewModel class would look like this:</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">TaskViewModel.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.MutableLiveData
import com.catata.tasknotesroom.database.MyDao
import com.catata.tasknotesroom.database.TasksDatabase
import com.catata.tasknotesroom.database.entities.TaskEntity
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class TaskViewModel(application: Application): AndroidViewModel(application) {
    val context = application

    var myDao:MyDao = TasksDatabase.getInstance(context)

    val taskListLD:MutableLiveData&lt;MutableList&lt;TaskEntity>> = MutableLiveData()
    val updateTaskLD:MutableLiveData&lt;TaskEntity?> = MutableLiveData()
    val deleteTaskLD:MutableLiveData&lt;Int> = MutableLiveData()
    val insertTaskLD:MutableLiveData&lt;TaskEntity> = MutableLiveData()


    fun getAllTasks(){
        viewModelScope.launch(Dispatchers.IO) {
            taskListLD.postValue(myDao.getAllTasks())
        }

    }
    fun add(task:String) {
        viewModelScope.launch(Dispatchers.IO) {
            val id = myDao.addTask(TaskEntity(name = task))
            val recoveryTask = myDao.getTaskById(id)
            insertTaskLD.postValue(recoveryTask)
        }
    }

    fun delete(task:TaskEntity){
        viewModelScope.launch(Dispatchers.IO) {

            val res = myDao.deleteTask(task)
            if(res>0)
                deleteTaskLD.postValue(task.id)
            else{
                deleteTaskLD.postValue(-1)
            }


        }
    }

    fun update(task:TaskEntity){
        viewModelScope.launch(Dispatchers.IO) {
            task.isDone = !task.isDone
            val res = myDao.updateTask(task)
            if(res>0)
                updateTaskLD.postValue(task)
            else
                updateTaskLD.postValue(null)
        }
    }
}</code></pre>
        </section><br><br>
</section>

<h3>MainActivity</h3>

<p>Now we only have to implement the View, the <span class="r-word">MainActivity</span>  code. Basically we will do the following:</p>


<ul>
    <li>Get an instance of our ViewModel.
        <section><pre><code class="language-kotlin">taskViewModel = ViewModelProvider(this)[TaskViewModel::class.java]</code></pre>
        </section><br><br>
    </li>
    <li>Initially retrieve all saved tasks.
        <section><pre><code class="language-kotlin">taskViewModel.getAllTasks()</code></pre>
        </section><br><br>
    </li>
    <li>Create a listener for the add button.
        <section><pre><code class="language-kotlin">binding.btnAddTask.setOnClickListener {
            addTask()
        }</code></pre>
        </section><br><br>
    </li>
    <li>Observe all LiveData of the ViewModel.
        <section><pre><code class="language-kotlin">taskViewModel.taskListLD.observe(this){
    tasks.clear()
    tasks.addAll(it)
    recyclerView.adapter?.notifyDataSetChanged()
}
taskViewModel.updateTaskLD.observe(this){ taskUpdated ->
    if(taskUpdated == null){
        showMessage("Error updating task")
    }
}

taskViewModel.deleteTaskLD.observe(this){ id ->
    if(id != -1){
        val task = tasks.filter {
            it.id == id
        }[0]
        val pos = tasks.indexOf(task)
        tasks.removeAt(pos)
        recyclerView.adapter?.notifyItemRemoved(pos)
    }else{
        showMessage("Error deleting task")
    }
}

taskViewModel.insertTaskLD.observe(this){
    tasks.add(it)
    recyclerView.adapter?.notifyItemInserted(tasks.size)

}</code></pre>
</section><br><br>

<p>Notice that after modifying the task list we call the <span class="negrita">notifyItemInserted</span> , <span class="negrita">notifyItemRemoved</span> 
     or <span class="negrita">notifyDataSetChanged</span>  methods from adapter.</p>

    </li>
    <li>Configure our RecyclerView.
        <section><pre><code class="language-kotlin">fun setUpRecyclerView() {
    adapter = TasksAdapter(tasks, { taskEntity ->  updateTask(taskEntity) }, { taskEntity -> deleteTask(taskEntity) })
    recyclerView = binding.rvTask
    recyclerView.setHasFixedSize(true)
    recyclerView.layoutManager = LinearLayoutManager(this)
    recyclerView.adapter = adapter
}</code></pre>
        </section><br><br>

    </li>
    <li>Add some extra function to hide Keyboard
        <section><pre><code class="language-kotlin">private fun clearFocus(){
    binding.etTask.setText("")
}

private fun Context.hideKeyboard() {
    val inputMethodManager = getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager
    inputMethodManager.hideSoftInputFromWindow(currentFocus?.windowToken, 0)
}</code></pre>
    </section><br><br>
    </li>
</ul>

<p>All the code would look like this.</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">import android.app.Activity
import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.inputmethod.InputMethodManager
import android.widget.Toast
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.catata.tasknotesroom.adapters.TasksAdapter
import com.catata.tasknotesroom.database.entities.TaskEntity
import com.catata.tasknotesroom.databinding.ActivityMainBinding
import com.catata.tasknotesroom.viewmodel.TaskViewModel

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    lateinit var recyclerView: RecyclerView
    var tasks: MutableList&lt;TaskEntity> = mutableListOf()

    private lateinit var taskViewModel:TaskViewModel

    lateinit var adapter: TasksAdapter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(ActivityMainBinding.inflate(layoutInflater).also {
            binding = it
        }.root)



        taskViewModel = ViewModelProvider(this)[TaskViewModel::class.java]

        taskViewModel.getAllTasks()

        taskViewModel.taskListLD.observe(this){
            tasks.clear()
            tasks.addAll(it)
            recyclerView.adapter?.notifyDataSetChanged()
        }
        taskViewModel.updateTaskLD.observe(this){ taskUpdated ->
            if(taskUpdated == null){
                showMessage("Error updating task")
            }
        }

        taskViewModel.deleteTaskLD.observe(this){ id ->
            if(id != -1){
                val task = tasks.filter {
                    it.id == id
                }[0]
                val pos = tasks.indexOf(task)
                tasks.removeAt(pos)
                recyclerView.adapter?.notifyItemRemoved(pos)
            }else{
                showMessage("Error deleting task")
            }
        }

        taskViewModel.insertTaskLD.observe(this){
            tasks.add(it)
            recyclerView.adapter?.notifyItemInserted(tasks.size)

        }

        binding.btnAddTask.setOnClickListener {
            addTask()
        }

        setUpRecyclerView()
    }

    private fun showMessage(s: String) {
        Toast.makeText(this, s, Toast.LENGTH_SHORT).show()
    }


    private fun addTask() {
        taskViewModel.add(binding.etTask.text.toString())
        clearFocus()
        hideKeyboard()

    }

    fun setUpRecyclerView() {
        adapter = TasksAdapter(tasks, { taskEntity ->  updateTask(taskEntity) }, { taskEntity -> deleteTask(taskEntity) })
        recyclerView = binding.rvTask
        recyclerView.setHasFixedSize(true)
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.adapter = adapter
    }

    private fun updateTask(taskEntity: TaskEntity) {
       taskViewModel.update(taskEntity)
    }

    private fun deleteTask(taskEntity: TaskEntity) {
        taskViewModel.delete(taskEntity)

    }

    private fun clearFocus(){
        binding.etTask.setText("")
    }

    private fun Context.hideKeyboard() {
        val inputMethodManager = getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager
        inputMethodManager.hideSoftInputFromWindow(currentFocus?.windowToken, 0)
    }
}</code></pre>
        </section>
</section>

<br><br>

You can get all the code in the following <a class="link" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD7/RoomExample"> Github </a> link  

<br><br>

<div class="oculto tarea">
    <span class="negrita">PRACTICE:</span> <br>
    
You have to implement a shopping list as indicated in the following <a class="enlace" target="_blank" href="./UD7/Practise5_ShoppingList.pdf">document</a> . Remember that you have to use the Room library to save the elements, in addition to using the Dao and MVVM patterns

</div>
    </section><!-- End section -->

    <!--*********************************************************Webgraphy***********************************************************-->
    <section class="apartado">
    <a name="sWebgrafia"></a>
    <h2>Webgraphy</h2>
    
    <ul>
        <li>
            <a class="enlace" target="_blank" href="https://developer.android.com/training/data-storage">Data Storage</a> 
        </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/training/data-storage/shared-preferences">Shared Preferences</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/reference/androidx/preference/PreferenceFragmentCompat">https://developer.android.com/reference/androidx/preference/PreferenceFragmentCompat</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/guide/topics/ui/settings">https://developer.android.com/guide/topics/ui/settings</a> </li>
        <li><a class="enlace" target="_blank" href="https://cursokotlin.com/capitulo-17-persistencia-de-datos-con-room/">Room example</a> </li>
        <li><a class="enlace" target="_blank" href="https://gerardfp.github.io/room/">Room example</a> </li>
    </ul>
    
    </section><!-- End section -->



    <script src="../script/prism.js"></script>
</body>
</html>
