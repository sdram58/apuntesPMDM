<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVVM - Live Data - Flows</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/prism.css">
    <link rel="stylesheet" href="../styles/styles.css">
    <script src="../script/script.js"></script>
</head>
<body class="line-numbers">
    <h1>UD6.- MVVM - Live Data - Flows</h1>
    <div class="main-menu">
        <div class="fila">
            <a href="#sMVVM">MVVM</a><a 
            href="#sLiveData">Live Data</a><a 
            href="#sFlows">Flows</a>
        </div>
        <div class="fila">
            <a href="#sWebGraphy">WebGraphy</a>
            <a class="relleno"></a>
            <a class="relleno"></a>
        </div>
    </div>

    


    <!--*********************************************************MODEL - VIEW - VIEWMODEL (MVVM)***********************************************************-->
    <section class="apartado">
    <a name="sMVVM"></a>
    <h2>MODEL - VIEW - VIEWMODEL (MVVM)</h2>
    
    <p>This practice is the first start or contact with the <span class="r-word">Model-View-ViewModel</span>  architecture, recommended for developing apps.</p>

    <p>We will explore the benefits this architecture provides, and the problems it solves.</p>
    
    <p>We will use the <span class="r-word">ViewModel</span>  and <span class="r-word">LiveData</span> classes.</p>
    
    <p>We will develop an app that consists of a <span class="d-word">Body Mass Index Calculator</span> </p>

    <figure><img src="UD6/mvvm/images/ud6_running_app_calculator.gif" /><br><figcaption>Running App</figcaption></figure>
    <br>

    <h3>Creating the project</h3>
    
 <ul>
     <li>Select <span class="negrita">Empty Activity</span>  as the template.</li>
     <li><span class="subrayado">Add dependencies</span>  for ViewModel and LiveData support; also for Navigation and Coroutines.
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita"> build.gradle (Module: app)</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">def viewModelVersion ="2.5.1"
def navVersion = "2.5.3"
implementation "androidx.navigation:navigation-fragment-ktx:$navVersion"
implementation "androidx.navigation:navigation-ui-ktx:$navVersion"


implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$viewModelVersion"
implementation "androidx.lifecycle:lifecycle-livedata-ktx:$viewModelVersion"

implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4"</code></pre>
            </section>
    </section>
    </li>

    <li>Enable ViewBinding

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita"> build.gradle (Module: app)</span>
        </section>
    <section class="marco-b">
          <section><pre><code class="language-kotlin">android {
    // ...

    buildFeatures {
        viewBinding true
    }
}</code></pre>
          </section>
    </section>
    </li>

    <li>Create the Navigation Graph <span class="inline-file">res/navigation/nav_graph.xml</span>
    <br><br>Add <span class="r-word">NavHostFragment</span>  to the <span class="r-word">MainActivity</span> layout:

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">res/layout/activity_main.xml</span>
        </section>
    <section class="marco-b">
          <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;androidx.fragment.app.FragmentContainerView
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:id="@+id/nav_host_fragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
          </section>
    </section>
    </li>

    <li>Create a destination on the <span class="inline-file">nav_graph.xml</span> called <span class="d-word">BMIFragment</span>
    
    <br><br>Configure <span class="r-word">ViewBinding</span> :
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">BMIFragment.kt</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-kotlin">class BMIFragment : Fragment() {
    
        private lateinit var binding: FragmentBMIBinding
    
    
        override fun onCreateView(
            inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?
        ): View? {
            // Inflate the layout for this fragment
            return FragmentBMIBinding
                .inflate(inflater, container, false)
                    .also { binding = it }.root
    
        }
    
        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
        }
    }</code></pre>
        </section>
        
    </section>
</li>
    <li>Add the following Views to the Layout
        <section class="marco-t file-">
            <span class="icono file"> </span> <span class="negrita">res/layout/fragment_b_m_i.xml</span>
            </section>
        <section class="marco-b">
             <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:padding="20dp">

        &lt;EditText
            android:id="@+id/etWeight"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Weight in Kg" />

        &lt;EditText
            android:id="@+id/etHeight"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Height in cm" />

        &lt;Button
            android:id="@+id/btnCalculate"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="calculate body mass index" />

        &lt;TextView
            android:id="@+id/tvBMI"
            android:textSize="26sp"
            android:textColor="@color/purple_500"
            android:gravity="center"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
        &lt;ScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent">
            &lt;TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris finibus nibh a pretium mattis. Nulla facilisi. Aliquam volutpat tincidunt orci ac volutpat. Donec sit amet aliquam nisl, sed sollicitudin nibh. Suspendisse potenti. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Maecenas velit nunc, tempus vitae lectus ut, pellentesque dapibus libero. Etiam laoreet quam sem, sit amet pharetra elit rhoncus quis. Sed hendrerit ac enim vel eleifend. Suspendisse potenti. Nullam eleifend, augue id condimentum bibendum, enim nibh accumsan diam, eu gravida odio turpis rutrum mi. Integer ullamcorper enim diam, vitae pharetra ex ultricies vel. Vivamus lacinia non mauris id blandit. Donec varius rhoncus mauris, vel luctus nibh volutpat at. Morbi turpis dolor, scelerisque vel quam sit amet, ultricies mattis eros. Etiam nisl risus, imperdiet vitae vestibulum faucibus, vehicula eu mauris. Vestibulum bibendum luctus ipsum at rhoncus. Nam sodales metus at turpis porttitor efficitur. Sed dui nisl, viverra in massa vitae, vestibulum bibendum tellus. Phasellus suscipit risus est, vitae hendrerit nunc rhoncus ut. Aenean commodo venenatis lacinia. Nunc fermentum felis ligula, ut placerat metus vulputate ullamcorper. Donec metus diam, aliquet vitae nulla nec, blandit placerat sem. Cras tempus tincidunt velit in pulvinar. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Praesent nec risus eget augue viverra sollicitudin. Maecenas volutpat nunc vel orci rutrum, ac mollis elit sollicitudin. Nulla eget tempor turpis. Curabitur bibendum dapibus metus, sit amet viverra justo imperdiet ac. Duis facilisis sem libero, ut rutrum ipsum pellentesque laoreet." />
        &lt;/ScrollView>
    &lt;/LinearLayout>

    &lt;ProgressBar
        android:id="@+id/progress_circular"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:visibility="gone"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
             </section><br><br>   
        </section>

        <figure><img src="UD6/mvvm/images/ud6_2021-11-08-12-51-20.png" /><br><figcaption></figcaption></figure>
        
    </li>

 </ul>

    <h3>BMI Calculator</h3>
    <p>The app that we are going to develop consists of the user entering a weight in kg and a height in cm. The app will determine what your body mass index is.</p>
    
    <p>This funcionality is implemented by <span class="d-word">BMICalculator</span>  class</p>
    
    <p>The <span class="d-word">BMICalculator</span>  class contains the calculate method that receives as a parameter a 
        <span class="d-word">Request</span>  object with the requested <span class="d-word">weight</span>  and <span class="d-word">height</span>
        fields, and calculates the <span class="negrita">bmi (Body Mass Index)</span>. Weight/Height<sup>2</sup></p>
    <p>A pause (<span class="r-word">sleep ()</span> ) has been added to simulate obtaining the imc through a long operation, such as accessing a database, a server, etc.</p>
    
    <p>Create this class:</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">BMICalculator.kt</span>
        </section>
    <section class="marco-b">
       <section><pre><code class="language-kotlin">class BMICalculator{

    data class Request(
        val weight:Double,
        val height:Double
    )

    private fun calcMBI(weight: Double, height: Double):Double = weight/ (height/100).pow(2)

    fun calculate(request:Request):Double{

        Thread.sleep(5000)
        println(Thread.currentThread().name)

        return calcMBI(request.weight, request.height)
        
    }
}</code></pre>
    </section></section>


    <h3>Crashes, Data Loss, and Memory Leaks</h3>

<p>When developing an Android app, a common mistake is writing all the code in an Activity or Fragment.</p>

<p>For example, in this method of the <span class="inline-file">BMIFragment</span> class we might be tempted to do the following:</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMIFragment.kt</span>
    </section>
<section class="marco-b">
       <section><pre><code class="language-kotlin"> override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    binding.btnCalculate.setOnClickListener {


        binding.progressCircular.visibility = View.VISIBLE

        val bmiCalculator = BMICalculator()
        val mHeight = binding.etHeight.text.toString().toDouble()
        val mWeight = binding.etWeight.text.toString().toDouble()

        val bmi = bmiCalculator.calculate(BMICalculator.Request(mWeight, mHeight))
        val dec = DecimalFormat("#,###.00")

        binding.tvBMI.text = dec.format(bmi).toString()

        binding.progressCircular.visibility = View.GONE
    }
}</code></pre>
    </section>
</section>

<p>In code above we can see that when we push the button <span class="d-word">btnCalculate</span> we obtain the <span class="negrita">weight</span> 
    and the <span class="negrita">height</span> introduced by the user. Then calls <span class="d-word">calculate</span> method from <span class="d-word">BMICalculator</span>  and then set de bmi on the 
<span class="r-word">textView</span>  </p>

<p class="sub-section">Blocking</p>

<p>If you run the app, it may appear to be working properly. However there are several problems.</p>

<p>The first is that the User Interface (View) has been blocked for as long as the <span class="d-word"> calculate()</span> method has been executing.</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-21-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>Due to the UI crash, we would not have been able to show, for example, a progress bar, or scroll our scroll view, or perhaps give the user the option to 
    cancel the operation... What's more, if the operation takes more than 5 seconds and the user tries After interacting with the User Interface in the meantime, 
    the Android system will show you the infamous "<span class="cursiva">
        <a class="enlace" target="_blank" href="https://developer.android.com/training/articles/perf-anr">application is not responding</a></span>" dialog.</p>

<section class="marco-t err">
    <span class="icono error"> </span> Long-lived operations should not be performed on the UI thread.
    </section>
<section class="marco-b">
        
</section>

<p>One solution that was widely used for some time was the use of the <span class="r-word">AsyncTask</span> java class, to run long-running tasks in the background.
    It used to be something like this:</p>

<section><pre><code class="language-kotlin"> private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long> {
     protected Long doInBackground(URL... urls) {
         int count = urls.length;
         long totalSize = 0;
         for (int i = 0; i &lt; count; i++) {
             totalSize += Downloader.downloadFile(urls[i]);
             publishProgress((int) ((i / (float) count) * 100));
             // Escape early if cancel() is called
             if (isCancelled()) break;
         }
         return totalSize;
     }

     protected void onProgressUpdate(Integer... progress) {
         setProgressPercent(progress[0]);
     }

     protected void onPostExecute(Long result) {
         showDialog("Downloaded " + result + " bytes");
     }
 }</code></pre>
</section>

<p>Once created, a task is executed very simply:</p>

<section><pre><code class="language-kotlin"> new DownloadFilesTask().execute(url1, url2, url3);</code></pre>
</section>

<p><a class="enlace" target="_blank" href="https://developer.android.com/reference/android/os/AsyncTask">More Info about AsyncTask</a></p>
 
<p>The intention of using <span class="r-word">AsyncTask</span>  is to run the <span class="d-word">calculate()</span>  method on a background task, and update the <span class="r-word">TextView</span>  with the quota obtained when the task ends.</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-32-25.png" /><br><figcaption></figcaption></figure>
<br>

<p>This prevents blocking of the user interface. If you run the app now, you'll see that the UI is still responding even when the long-running
     <span class="d-word">calculate()</span>  task is running.</p>
<p>But this solution doesn't solve all problems either.</p>

<p class="sub-section">Data loss</p>

<p>A characteristic behavior of <span class="negrita">Android</span> is that when the user rotates the mobile screen, <span class="subrayado">the system destroys the running <span class="r-word">Activity</span> </span>,
    and creates a new one with the new screen configuration. With this, all added views (<span class="r-word">Fragments</span> , widgets, etc.) and all variables of the destroyed <span class="r-word">Activity</span>  
    instance are also lost. Furthermore, the layout of the <span class="r-word">Activity</span>  returns to the starting point, as defined in the xml.</p>

<p>So because of this, neither of the above two solutions solves the data loss problem.</p>

<ul>
    <li>
        
<span class="subrayado"><span class="negrita">Without AsyncTask</span></span>  : although the app has survived the crash and the quota has been shown in the <span class="negrita">&lt;TextView></span>,
 if the user then rotates the mobile, the <span class="d-word">bmi</span>  disappears from the <span class="negrita">&lt;TextView></span>, when Android destroys the <span class="r-word">Activity</span>  and creates a new one.

 <figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-39-45.png" /><br><figcaption></figcaption></figure>
 <br>
 
    </li>

    <li>
        <span class="subrayado"><span class="negrita">With AsyncTask</span></span>: even if the app has not crashed during the calculation, 
        the data is still lost if the user rotates the screen.

        <figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-40-53.png" /><br><figcaption></figcaption></figure>
        <br>
        
    </li>
</ul>

<section class="marco-t warn">
    <span class="icono warning"> </span> You must consider that the <span class="negrita">User Interface does not belong to you</span>  and that the android system can do with it whatever it deems appropriate.
    </section>
<section class="marco-b">
        
</section>

<p class="sub-section">Memory Leaks</p>
<p>We now go to the case that the user rotates the screen just when the calculation is being carried out.</p>

<p>With the program without <span class="r-word">AsyncTask</span>, the behavior of the app will be erratic, since <span class="r-word">Android</span>  cannot destroy the <span class="r-word">Activity</span> 
     or create a new one until the <span class="d-word">calculate()</span>  task has finished.</p>

     <figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-50-03.png" /><br><figcaption></figcaption></figure>
     <br>
     
<p>With the program with <span class="r-word">AsyncTask</span> , the following happens: when the screen is rotated in the middle of executing the <span class="r-word">AsyncTask</span>, 
    <span class="negrita">Android</span>  will try to destroy the running <span class="d-word">MainActivity</span> (keep in mind that the <span class="d-word">BMIFragment</span>
    fragment is inside the <span class="d-word">MainActivity</span>). However, it will not be able to do so since the <span class="r-word">AsyncTask</span> 
     maintains a reference to the variable <span class="d-word">binding.tvBMI</span>  that belongs to the <span class="d-word">MainActivity</span>. So <span class="negrita">Android</span> 
      will create a new <span class="d-word">MainActivity</span>  without being able to destroy the previous one, which will unnecessarily occupy the system's ram memory. 
      This is a <span class="negrita">Memory Leak</span>.</p>

<p>In addition, when the <span class="d-word">AsyncTask</span> finishes, it will put the resulting <span class="d-word">BMI</span>  in the TextView of the 
     that should have been destroyed and that has been lost in memory, and therefore, it will never be shown in the <span class="r-word">TextView</span>  of the new 
     <span class="d-word">MainActivity</span>  in execution.</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-13-55-39.png" /><br><figcaption></figcaption></figure>
<br>

<section class="marco-t warn">
    <span class="icono warning"> </span> We have not keep references to UI elements in background tasks.
    </section>
<section class="marco-b">
        
</section>

<p>To alleviate these problems, different procedures have been constantly appearing that involved static <span class="r-word">AsyncTasks</span> , <span class="r-word">WeakReferences</span>,
    overrides of life cycle methods, etc, all of them with their advantages and disadvantages. Currently, it seems that the most accepted solution is to implement the 
    <span class="negrita">MVVM architecture</span>  that we will see below.</p>

<h3>MVVM architecture</h3>

<p>The <span class="r-word">Model-View-ViewModel</span> architecture is based on the Separation of Interests principle, dividing the app code into three categories:</p>

<ul>
    <li><span class="r-word">View</span> : It is in charge of the interaction with the user.</li>
    <li><span class="r-word">Model</span> : It is in charge of carrying out the actions on the data.</li>
    <li><span class="r-word">ViewModel</span> : Acts as a link between the Model and the View.</li>
</ul>

<p>When the View has to perform any action on the data (calculation, query, modification, etc ...) it does not do so directly on the <span class="r-word">Model</span> , but uses the <span class="r-word">ViewModel</span>
    as an intermediary. The <span class="r-word">ViewModel</span> transfers the action to the <span class="r-word">Model</span>. The <span class="r-word">Model</span> 
    responds to the <span class="r-word">ViewModel</span>  with the result of the action (data or errors), and the <span class="r-word">ViewModel</span> passes it back to the View. 
    In Android apps we will implement the <span class="r-word">ViewModel</span>  using the <span class="r-word">AndroidViewModel</span> class.</p>

<p>The key point for decoupling the View from the rest of the app's components, and avoiding so the problems seen in the previous point, 
    is that the <span class="r-word">ViewModel</span> does not directly transfer the result of the actions to the View, but rather the View is the who observes the result. 
    The watch mechanism implies that the ViewModel reports the result to the View, <span class="negrita">only if the View is running</span>. 
    To implement the observation we will use the <span class="r-word">LiveData</span>  class.</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-14-25-58.png" /><br><figcaption></figcaption></figure>
<br>

<p>Thus, the communication between these components is usually like this:</p>

<ul>
    <li>The <span class="negrita">View</span>  calls methods of the <span class="negrita">ViewModel</span> to perform actions on the data, and watches the 
        <span class="negrita">LiveData</span> to obtain the result.</li>
    
    <li>The <span class="negrita">ViewModel</span>  transfers the actions to the <span class="negrita">Model</span> through method calls (usually in the background), 
        and saves the resulting data in the <span class="negrita">LiveData</span> .</li>

    <li>The <span class="negrita">Model</span> performs the actions on the data and returns the result to the <span class="negrita">ViewModel</span> (with return or through callbacks).</li>
</ul>

<p>Another key aspect is that the <span class="r-word">ViewModel</span> survives screen rotation, so the data stored in the <span class="r-word">ViewModel</span> is not lost when
    <span class="negrita">Android</span>  destroys the View and recreates it.</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-14-29-35.png" /><br><figcaption></figcaption></figure>
<br>

<h3>MVVM implementation</h3>

<p>To implement a <span class="negrita">ViewModel</span>  in Android you have to create a class and make it extend from the <span class="r-word">AndroidViewModel</span> class.</p>

<p>In this app we will call this class <span class="d-word">BMICalculatorViewModel</span> . In it we do the following:</p>

<ul>
    <li>We declare the variable <span class="d-word">bmi</span>  of type Double wrapped in the <span class="d-word">MutableLiveData</span> class (Mutable allows changing the value of the variable).</li>
    <li>In the class constructor we initialize the Model (<span class="r-word">BMICalculator.kt</span>).</li>
    <li>We define the <span class="d-word">calculate()</span>  method that will be called by the View, and which, in turn, calls the Model's <span class="d-word">calculate()</span> 
        method in the background.</li>
</ul>
<br>

<p>This method receives the data from the View (weight and height), and transforms it into a <span class="d-word">BMICalculator.Request</span>  object to send to the 
    <span class="d-word">Model</span>.</p>

<p>The <span class="d-word">calculate()</span> method of the <span class="negrita">Model</span> is called in the background, and the result 
    bmi is saved in the variable <span class="d-word">bmi</span>  (to change the value of a <span class="r-word">MutableLiveData</span>  within a background task, use the 
    <span class="negrita">postValue()</span>  method).</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMICalculatorViewModel.kt</span>
    </section>
<section class="marco-b">
        
</section>

<section><pre><code class="language-kotlin">class BMICalculatorViewModel: ViewModel() {

    private val bmiCalculator: BMICalculator = BMICalculator()


    val bmi : MutableLiveData&lt;Double> = MutableLiveData()



    private fun calculate(weight: Double, height: Double) {
        //Using coroutine
        CoroutineScope(Dispatchers.IO).launch { //This run in background coroutine
            val bmiResult = bmiCalculator.calculateWithFunctions(BMICalculator.Request(weight, height))

            bmi.postValue(bmiResult)

        }
    }
}</code></pre>
</section><br><br>

<p>The View (BMIFragment) for its part does the following:</p>

<ul>
    <li>Gets an instance of the <span class="d-word">BMICalculatorViewModel</span>. To obtain an instance of a <span class="r-word">ViewModel</span> , 
        use the <span class="r-word">ViewModelProvider</span> , passing it the class .class of the <span class="r-word">ViewModel</span>  that you want to obtain.</li>
    <li>When the user clicks the button, the data entered is obtained and the <span class="r-word">ViewModel</span>  is called to execute the <span class="d-word">calculate()</span>
         action with that data.</li>
    <li>The variable <span class="d-word">bmi</span>  (the <span class="negrita">LiveData</span> ) of the <span class="negrita">ViewModel</span>  is observed. 
        When the value of the quota variable changes (that is, the result is set), the <span class="r-word">LiveData</span>  will call the <span class="r-word">onChanged()</span> 
         method, reporting the value of the variable in the <span class="d-word">newBMI</span>  parameter. The only thing that is done is to set this value in the &lt;TextView>.</li>
</ul>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMIFragment.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">class BMIFragment : Fragment() {

    private lateinit var binding: FragmentBMIBinding


    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return FragmentBMIBinding
            .inflate(inflater, container, false)
                .also { binding = it }.root

    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        //Obtaining a reference to our ViewModel
        val bmiCalculatorViewModel:BMICalculatorViewModel = ViewModelProvider(this)[BMICalculatorViewModel::class.java]

        binding.btnCalculate.setOnClickListener {

            closeKeyBoard(it) //closing soft keyboard


            var mHeight = 0.0
            var mWeight = 0.0

            mHeight = binding.etHeight.text.toString().toDouble()
            mWeight = binding.etWeight.text.toString().toDouble()

            bmiCalculatorViewModel.calculateBMI(mWeight,mHeight)          

        }

        //keep observing change on bmi from viewModel
        bmiCalculatorViewModel.bmi.observe(viewLifecycleOwner){ newBMI ->
            val dec = DecimalFormat("#,###.00")

            binding.tvBMI.text = dec.format(newBMI).toString()

        }
    }

    private fun closeKeyBoard(view:View){
            (activity?.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager).apply {
                hideSoftInputFromWindow(view.windowToken, 0)
            }
    }

}</code></pre>
</section></section>

<p>The following diagram illustrates the communication between the 3 components of the app:</p>

<figure><img src="UD6/mvvm/images/ud6-2021-11-08-15-34-40.png" /><br><figcaption></figcaption></figure>
<br>


<p>The key to why the <span class="r-word">ViewModel</span>  solves the screen rotation problem is in the <span class="r-word">ViewLifecycleOwner</span> parameter passed 
    to the <span class="r-word">observe</span>  method, which ensures that the notification of the result (through the call to <span class="negrita">onChanged()</span> , lambda), will only be made if the View ( the fragment) 
    is still running when the result is obtained.</p>

<p>Suppose that the user presses the calculate button with the mobile vertically, and while the calculation is being carried out rotates the mobile. 
    The fragment that originally performed the <span class="d-word">calculate()</span>  action and <span class="negrita">observed</span> the result will no longer be 
    running and will not be notified of the result. However, the <span class="subrayado">new fragment that has been created</span> and that also <span class="negrita">observes</span> 
     the result will be notified.</p>
<figure><img src="UD6/mvvm/images/ud6-2021-11-08-15-28-37.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Callbacks</p>

<p>The callback mechanism consists in that when a method is called, it is passed an object in which the methods that it has to call to return the result are defined. 
    In the methods of that object you define what to do with the result.</p>


<p>Communication between the <span class="r-word">ViewModel</span>  and the <span class="r-word">Model</span>  is done through calls and <span class="negrita">callbacks</span>.
    On return calls, the result is reported as well as progress and errors. The <span class="r-word">ViewModel</span>  notifies the <span class="r-word">View</span>  via <span class="r-word">LiveData</span> 
     variables.</p>


<p>In this case we're going to the same using callbacks, functions or sealed class. Notice that callbacks introduce more boling code</p>

<p>Change the <span class="d-word">BMICalculator</span>  class so that it communicates the result through a callback, functions and sealed class:</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMICalculator.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">package com.cartatar.body_mass_index.model


import java.lang.Exception
import kotlin.math.pow


typealias OnWrongHeight = (error:String)->Unit
typealias OnWrongWeight = (error:String)->Unit
typealias onError = (error:String)->Unit
typealias OnSuccess = (bmi:Double)->Unit
typealias OnLoading = (loading:Boolean)->Unit


class BMICalculator{

    data class Request(
        val weight:Double,
        val height:Double
    )

    private fun calcMBI(weight: Double, height: Double):Double = weight/ (height/100).pow(2)

    /***************WITH FUNCTIONS***********************************/
    //Long calculating function
    fun calculateWithFunctions(request:Request,onSuccess: OnSuccess, onError: onError, onLoading: OnLoading, onWrongWeight: OnWrongWeight?, onWrongHeight: OnWrongHeight?){

        onLoading(true)
        val minHeight= 50
        val minWeight = 10

        var error = false

        Thread.sleep(5000)
        println(Thread.currentThread().name)

        //If height is lower than minHeight call ourCallback
        if(minHeight > request.height){
            onWrongHeight?.let {
                it.invoke("Height should be bigger")
                error = true
            }
        }
        if(minWeight > request.weight){
            onWrongHeight?.let {
                it.invoke("Weight should be bigger")
                error = true
            }
        }

        if(!error){
            //All works fine
            try{
                val bmi = calcMBI(request.weight, request.height)
                onSuccess(bmi)
            }catch (e:Exception){
                onError(e.toString())
            }
        }
            onLoading(false)



    }


    /***************WITH SEALED CLASS***********************************/

    sealed class Response{
        class OKResult(val result:Double):Response()
        class WrongWeight(val error:String):Response()
        class WrongHeight(val error:String):Response()
    }


    //Long calculating function with Sealed class
    fun calculateWithSealed(request:Request,onLoading: OnLoading?):Response{
        onLoading?.invoke(true)
        val minHeight= 50
        val minWeight = 10

        if(minWeight > request.weight) return ( Response.WrongWeight("Weight should be bigger"))
        if(minHeight > request.height) return ( Response.WrongHeight("Height should be bigger"))




        Thread.sleep(5000)
        println("${Thread.currentThread().name}")

        //All works fine
        onLoading?.invoke(false)
        return Response.OKResult(calcMBI(request.weight, request.height))

    }




    /***************WITH CALLBACK INTERFACE***********************************/

    interface BMIResponse{
        fun onSuccess(result:Double)
        fun onHeightError(error:String)
        fun onWeightError(error:String)
        fun onError(error:String)
        fun onLoading(loading: Boolean)
    }

    fun calculateWithCallback(request: Request, bmiResponse: BMIResponse){
        bmiResponse.onLoading(true)
        val minHeight= 50
        val minWeight = 10

        var error = false

        Thread.sleep(5000)
        println(Thread.currentThread().name)

        //If height is lower than minHeight call ourCallback
        if(minHeight > request.height){
            bmiResponse.onHeightError("Height should be bigger")
            error = true
        }
        if(minWeight > request.weight){
            bmiResponse.onWeightError("Weight should be bigger")
            error = true
        }

        if(!error){
            //All works fine
            try{
                val bmi = calcMBI(request.weight, request.height)
                bmiResponse.onSuccess(bmi)
            }catch (e:Exception){
                bmiResponse.onError(e.toString())
            }
        }
        bmiResponse.onLoading(false)
    }

}</code></pre>
</section></section>

<p>Using callbacks we use an interface like this:
</p>

<section><pre><code class="language-kotlin">interface BMIResponse{
    fun onSuccess(result:Double)
    fun onHeightError(error:String)
    fun onWeightError(error:String)
    fun onError(error:String)
    fun onLoading(loading: Boolean)
}</code></pre>
</section><br><br>

<p>Using functions we have define some <span class="r-word">typealias</span> </p>

<section><pre><code class="language-kotlin">typealias OnWrongHeight = (error:String)->Unit
typealias OnWrongWeight = (error:String)->Unit
typealias onError = (error:String)->Unit
typealias OnSuccess = (bmi:Double)->Unit
typealias OnLoading = (loading:Boolean)->Unit</code></pre>
</section><br><br>

<p>Using <span class="r-word">sealed classes</span>  we have defined it</p>

<section><pre><code class="language-kotlin">sealed class Response{
    class OKResult(val result:Double):Response()
    class WrongWeight(val error:String):Response()
    class WrongHeight(val error:String):Response()
}</code></pre>
</section><br><br>

<p>Notice that we have added some extra function in order to control (in the backend side) some errors concerning the weight and height that they have a min value in this case.
    Also look at the loading it is to indicate <span class="r-word">ViewModel</span>  when we have started and stopped </p>

<p>Now let's see how our ViewModel looks. Depending on the case, we have to pass a callback, or implementing functions, o getting the resulted sealed class.</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMICalculatorViewModel.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">package com.cartatar.body_mass_index.viewmodel

import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.cartatar.body_mass_index.model.BMICalculator
import com.cartatar.body_mass_index.model.BMICalculator.BMIResponse
import kotlinx.coroutines.*

class BMICalculatorViewModel: ViewModel() {

    private val bmiCalculator: BMICalculator = BMICalculator()


    val bmi : MutableLiveData&lt;Double> = MutableLiveData()
    val heightError : MutableLiveData&lt;String> = MutableLiveData()
    val weightError : MutableLiveData&lt;String> = MutableLiveData()
    val error : MutableLiveData&lt;String> = MutableLiveData()
    val loading : MutableLiveData&lt;Boolean> = MutableLiveData()



    //Choose which of the three methods you want to use
    fun calculateBMI(weight:Double,height:Double){
        
        //calculateBMIFunctions(weight,height)
        calculateBMICallBack(weight,height)
        //calculateBMISealed(weight,height)

    }

    /**********WITH FUNCTIONS *************************/
    private fun calculateBMIFunctions(weight: Double, height: Double) {
        //Using coroutine
        CoroutineScope(Dispatchers.IO).launch {
            //Using callbacks
            bmiCalculator.calculateWithFunctions(BMICalculator.Request(weight, height),
                onSuccess = { mBMI->
                    bmi.postValue(mBMI)
                    heightError.postValue("")
                    weightError.postValue("")
                    error.postValue("")
                },
                onError = {
                        e -> error.postValue(e)
                },
                onLoading = {
                        isLoading -> loading.postValue(isLoading)
                },
                onWrongWeight = {
                        e -> weightError.postValue(e)
                }, null)

        }
    }

    /******************WITH CALLBACK*************************************/
    private fun calculateBMICallBack(weight: Double, height: Double) {


        CoroutineScope(Dispatchers.IO).launch {
            bmiCalculator.calculateWithCallback(
                BMICalculator.Request(weight,height),
                object:BMIResponse{
                    override fun onSuccess(result: Double) {
                        bmi.postValue(result)
                        error.postValue("")
                        heightError.postValue("")
                        weightError.postValue("")
                    }

                    override fun onHeightError(error: String) {
                        heightError.postValue(error)
                    }

                    override fun onWeightError(error: String) {
                        weightError.postValue(error)
                    }

                    override fun onError(mError: String) {
                        error.postValue(mError)
                    }

                    override fun onLoading(mLoading: Boolean) {
                        loading.postValue(mLoading)
                    }

                })


        }
    }


    /******************WITH SEALED***************************************/

    private fun calculateBMISealed(weight: Double, height: Double) {

        //viewModelScope.launch {
            CoroutineScope(Dispatchers.IO).launch {
            loading.postValue(true)
            bmiCalculator.calculateWithSealed(BMICalculator.Request(weight, height),null).also{ res ->
                when(res){
                    is BMICalculator.Response.OKResult -> {
                        bmi.postValue(res.result)
                        heightError.postValue("")
                        weightError.postValue("")
                        error.postValue("") }
                    is BMICalculator.Response.WrongHeight ->{
                        heightError.postValue(res.error)
                    }
                    is BMICalculator.Response.WrongWeight ->{
                        weightError.postValue(res.error)
                    }
                }

            }
            loading.postValue(false)
        }
    }




}</code></pre>
</section>
</section>
<p>As you can see the process is almost the same in the three variations. Make de call to our Model, 
    then through <span class="negrita">callback</span> , <span class="negrita">function</span> , or <span class="negrita">returned sealed class</span> 
     to set the data (bmi, errors, loading) into our LiveData with postValue()</p>
    
     <p>We've added some LiveData more</p>

     <section><pre><code class="language-kotlin">val bmi : MutableLiveData&lt;Double> = MutableLiveData()
val heightError : MutableLiveData&lt;String> = MutableLiveData()
val weightError : MutableLiveData&lt;String> = MutableLiveData()
val error : MutableLiveData&lt;String> = MutableLiveData()
val loading : MutableLiveData&lt;Boolean> = MutableLiveData()</code></pre>
    </section><br><br>


<p>Now, we have to observe all this LiveData in our View (Fragment).</p>
<p>Notice that we've added some extra checks in our views such us height or weight are not of double type. This kind of checks are usefull doing in the view side</p>

<section><pre><code class="language-kotlin">try {
    mHeight = binding.etHeight.text.toString().toDouble()
}catch (e : Exception){
    binding.etHeight.error = "You should insert a number"
    error = true
}</code></pre>
</section><br><br>


<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">BMIFragment.kt</span>
    </section>
<section class="marco-b">


<section><pre><code class="language-kotlin">package com.cartatar.body_mass_index

import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.ViewModelProvider
import com.cartatar.body_mass_index.databinding.FragmentBMIBinding
import com.cartatar.body_mass_index.model.BMICalculator
import com.cartatar.body_mass_index.viewmodel.BMICalculatorViewModel
import java.text.DecimalFormat
import android.app.Activity
import android.view.inputmethod.InputMethodManager


class BMIFragment : Fragment() {

    private lateinit var binding: FragmentBMIBinding


    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return FragmentBMIBinding
            .inflate(inflater, container, false)
                .also { binding = it }.root

    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        /*binding.btnCalculate.setOnClickListener {


            binding.progressCircular.visibility = View.VISIBLE

            val bmiCalculator = BMICalculator()
            val mHeight = binding.etHeight.text.toString().toDouble()
            val mWeight = binding.etWeight.text.toString().toDouble()

            val bmi = bmiCalculator.calculate(BMICalculator.Request(mWeight, mHeight))
            val dec = DecimalFormat("#,###.00")

            binding.tvBMI.text = dec.format(bmi).toString()
            binding.progressCircular.visibility = View.GONE
        }*/

        //Obtaining a reference to our ViewModel
        val bmiCalculatorViewModel:BMICalculatorViewModel = ViewModelProvider(this)[BMICalculatorViewModel::class.java]
        binding.btnCalculate.setOnClickListener {

            closeKeyBoard(it) //Closing soft keyboard

            var error = false
            var mHeight = 0.0
            var mWeight = 0.0

            binding.etHeight.error = null
            binding.etWeight.error = null
            try {
                mHeight = binding.etHeight.text.toString().toDouble()
            }catch (e : Exception){
                binding.etHeight.error = "You should insert a number"
                error = true
            }

            try {
                mWeight = binding.etWeight.text.toString().toDouble()
            }catch (e : Exception){
                binding.etWeight.error = "You should insert a number"
                error = true
            }

            if(!error){
                //Call to calculator viewModel
                bmiCalculatorViewModel.calculateBMI(mWeight,mHeight)
            }


        }

        //keep observing change on mbi from viewModel
        bmiCalculatorViewModel.bmi.observe(viewLifecycleOwner){ newBMI ->
            val dec = DecimalFormat("#,###.00")

            binding.tvBMI.text = dec.format(newBMI).toString()
            binding.etWeight.error = null
            binding.etHeight.error = null
        }

        bmiCalculatorViewModel.weightError.observe(viewLifecycleOwner){ error ->
            if(error != "") {
                binding.tvBMI.text  = ""
                binding.etWeight.error = error
            }else
                binding.etWeight.error = null

        }
        bmiCalculatorViewModel.heightError.observe(viewLifecycleOwner){ error ->

            if(error != "") {
                binding.tvBMI.text  = ""
                binding.etHeight.error = error
            }else
                binding.etHeight.error = null




        }
        bmiCalculatorViewModel.error.observe(viewLifecycleOwner){ error ->
            if(error != "")
                 binding.tvBMI.text = error


        }

        bmiCalculatorViewModel.loading.observe(viewLifecycleOwner){ isLoading ->
            if(isLoading)
                binding.progressCircular.visibility =  View.VISIBLE
            else
                binding.progressCircular.visibility =  View.GONE
        }
    }

    private fun closeKeyBoard(view:View){
            (activity?.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager).apply {
                hideSoftInputFromWindow(view.windowToken, 0)
            }
    }

}</code></pre>
</section>        
</section>

<p>Github <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD6/BodyMassIndexCalculator">link</a> to the code</p>

<div class="tarea">
    <p><span class="negrita">Exercise</span> </p>
    
<p>You implement a View that performs an action on a Model. For example a Mortgage calculator. Formula: capital*interest/12/(1-Math.pow(1+(interes/12),-returnPeriod*12)) where interest can be an arbitrary value (0.01605) or even an other field </p>
<p>The View has to get data from the user, and the Model has to use it to perform the action.</p>
<p>The Model must impose some kind of restriction on the data. Term (minimun number of months), capital (Max and min capital borrowed) </p>
<p>The View should show the result of the action, and report errors and progress.</p>

</div>

    </section><!-- End section -->

    <!--*********************************************************LIVE DATA***********************************************************-->
    <section class="apartado">
    <a name="sLiveData"></a>
    <h2>LIVE DATA</h2>
    

    <p><span class="r-word">LiveData</span>  is a class to hold <span class="negrita">observable</span>  data.</p>
    
<p>It is specifically designed to be used in Activities, Fragments or Services, so that it only notifies the observers if the Activity, Fragment or Service is running.</p>

<p>Android provides <span class="r-word">LiveData</span>  and <span class="r-word">MutableLiveData</span> classes that allow you to store any type of data, 
    and observe its changes.</p>

<p>We will develop an app that consists of a <span class="d-word">Gymnastics Trainer</span>.</p>

    <figure><img src="UD6/livedata/images/ud6_running.gif" /><br><figcaption>Running App: Trainer</figcaption></figure>
    <br>
    
    <h3>Creating the proyect</h3>

    <ol>
        <li>Select <span class="negrita">Empty Activity</span>  template</li>
        <li>Add the following dependencies</li>

        <section class="marco-t file-">
            <span class="icono file"> </span> <span class="negrita">build.gradle (Module: app)</span>
            </section>
        <section class="marco-b">
            <section><pre><code class="language-kotlin">dependencies {
    // ...

    def liveDataVersion ="2.5.1"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$liveDataVersion"
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$liveDataVersion"

    def navigationVersion = "2.5.3"
    implementation "androidx.navigation:navigation-fragment-ktx:$navigationVersion"
    implementation "androidx.navigation:navigation-ui-ktx:$navigationVersion"

}</code></pre>
            </section>
        </section>

        <li>Activate View Binding</li>

        <section class="marco-t file-">
            <span class="icono file"> </span> <span class="negrita">build.gradle (Module: app)</span>
            </section>
        <section class="marco-b">
                <section><pre><code class="language-kotlin">android {
    // ...

    buildFeatures {
        viewBinding true
    }
}</code></pre>
                </section>
        </section>
        
    <li>Create Navigation Graph: <span class="inline-file">res/navigation/nav_graph.xml</span>
         <br>
         Add the <span class="r-word">NavHostFragment</span>  to the <span class="negrita">MainActivity</span> 's layout

         <section class="marco-t file-">
             <span class="icono file"> </span> <span class="negrita">res/layout/activity_main.xml</span>
             </section>
         <section class="marco-b">
                 <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    &lt;androidx.fragment.app.FragmentContainerView
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:id="@+id/nav_host_fragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:defaultNavHost="true"
        app:navGraph="@navigation/nav_graph" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
                 </section>
         </section>
         
    </li>

    <li>Add a destination in the <span class="inline-file">nav_graph.xml</span> called <span class="d-word">TrainerFragment</span>
    <br>
    Configure the <span class="negrita">ViewBinding</span>
        <section class="marco-t file-">
            <span class="icono file"> </span> <span class="negrita">TrainerFragment.kt</span>
            </section>
        <section class="marco-b">
             <section><pre><code class="language-kotlin">import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import com.cartatar.livedatatrainer.databinding.FragmentTrainerBinding


class TrainerFragment : Fragment() {

    private lateinit var binding:FragmentTrainerBinding

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return FragmentTrainerBinding.inflate(inflater, container, false)
            .also { binding = it }
            .root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
    }


}</code></pre>
             </section>
        </section>
        
</li>

<li>
    Add the following Views to the Layout:
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">res/layout/fragment_trainer.xml</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="TrainerFragment">

    &lt;ImageView
        android:id="@+id/ivExercise"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    &lt;TextView
        android:id="@+id/tvRepetition"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textSize="48sp"/>
    &lt;TextView
        android:id="@+id/tvChange"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#ddee44"
        android:textColor="@color/white"
        android:visibility="gone"
        android:text="Change"
        android:gravity="center"
        android:textSize="48sp"/>
&lt;/FrameLayout></code></pre>
        </section>
    </section>
    
</li>

<li>Download the gif images from 
    <a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/blob/master/UD6/GymnasticsTrainer/app/src/main/res/raw/images.zip">here</a>
and drag them to the <span class="inline-folder">res/drawable</span> folder </li>
        
    </ol>


    <h3>Trainer</h3>

    <p>The following class implements the <span class="d-word">Trainer</span>. Its function is to give orders, which consist of what exercise to do and the number of repetitions. 
        When the repetition number reaches 0, it warns of the change and changes the exercise.</p>

    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">Trainer.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">package com.cartatar.livedatatrainer.model

import androidx.lifecycle.LiveData
import kotlinx.coroutines.*

import java.util.*
import androidx.lifecycle.MutableLiveData




typealias  OnOrder = (order:String) -> Unit

class Trainer {
    val random:Random = Random()

    var training:Job? = null

    var exercise = 0
    var repetitions = -1


    fun startTraining(onOrder: OnOrder) {
        if (training == null || training!!.isCancelled || training!!.isCompleted) {
            training = CoroutineScope(Dispatchers.IO).launch {

                while (true) {
                    if (repetitions &lt; 0) {
                        repetitions = random.nextInt(3) + 3
                        exercise = random.nextInt(5) + 1
                    }
                    onOrder("EXERCISE" + exercise + ":" + if (repetitions == 0) "CHANGE" else repetitions)
                    repetitions--

                    delay(1000)
                }

            }
        }
    }

    fun stopTraining() {
        training?.let {
            if(it.isActive)
                it.cancel()
        }
        exercise = 0
        repetitions = -1

    }
}</code></pre>
            </section>

            <p>If it all works fine and in an console enviroment we could get an exit like this:</p>

            <section><pre><code class="language-xml">Start
EXERCISE2:3
EXERCISE2:2
EXERCISE2:1
EXERCISE2:CHANGE
EXERCISE1:3
EXERCISE1:2
EXERCISE1:1
EXERCISE1:CHANGE
EXERCISE4:3
EXERCISE4:2
EXERCISE4:1
EXERCISE4:CHANGE
EXERCISE3:6
EXERCISE3:5
EXERCISE3:4
stop
</code></pre>
            </section><br><br>
            
    </section>

    <section class="marco-t warn">
        <span class="icono warning"> </span>Please, Note that our app still shows <span class="negrita">nothing</span> 
        </section>
    <section class="marco-b">
            
    </section>
    
    

    <h3>LiveData</h3>

    <p>There are two ways to use <span class="r-word">LiveData</span> : instantiating the <span class="r-word">MutableLiveData</span>  class 
        or extending the <span class="r-word">LiveData</span>  class.</p>
    
    <p class="sub-section">MutableLiveData</p>
    
    <p>To instantiate a <span class="r-word">MutableLiveData</span>  class object, you must put the type of data it is going to store in the diamond &lt;>. 
        For example to create a <span class="r-word">MutableLiveData</span> of type <span class="r-word">Integer</span>:</p>

        <section><pre><code class="language-kotlin">val integerNumberLiveData = MutableLiveData&lt;Int>()</code></pre>
        </section><br><br>  

    <p>In the construtor, you can pass the initial value as argument:</p>

    <section><pre><code class="language-kotlin">val integerNumberLiveData = MutableLiveData(2400)</code></pre>
    </section><br><br>

    <p>To change the value that a <span class="r-word">MutableLiveData</span> contains, two methods are provided:</p>

    <ul>
        <li><span class="r-word">setValue()</span>: allows you to change the value <span class="negrita">from the main thread</span> </li>
        <li><span class="r-word">postValue()</span>: allows changing the value <span class="negrita">from a background thread</span> </li>
</ul>

<section><pre><code class="language-kotlin">integerNumberLiveData.setValue(-500);    // it can only be done from Main Thread
integerNumberLiveData.postValue(7802);</code></pre>
</section><br><br>

<p>Both methods cause observers to be notified of the value change.</p>

<p>To observe a <span class="r-word">LiveData</span>  or <span class="r-word">MutableLiveData</span>  object, the <span class="r-word">observe()</span> 
     method must be called. This method must be passed the <span class="negrita">Activity</span>  or the <span class="negrita">Fragment</span> 
      from which it is observed, and the <span class="d-word">Observer</span> callback which will be called to notify the value changes. 
      Notifications of value changes will only be made if the Activity or the Fragment is running.</p>

<p>To get the Fragment or Activity and pass it to the <span class="r-word">observe()</span>  method, you can use the <span class="r-word">viewLifecycleOwner</span>  getter method.</p>

<p>The following code illustrates how to begin observing a <span class="r-word">LiveData</span>  object:</p>

    <section><pre><code class="language-kotlin">integerNumberLiveData.observe(viewLifecycleOwner, object : Observer<Int?>() {
    fun onChanged(@Nullable value: Int?) {
        // update UI with the new value
    }
})</code></pre>
    </section><br><br>

    or even better or more readable version

    <section><pre><code class="language-kotlin">integerNumberLiveData.observe(viewLifecycleOwner) { value ->
    // update UI with the new value
}
</code></pre>
    </section><br><br>
    
<p class="sub-section">LiveData</p>

<p>In the case of a <span class="r-word">MutableLiveData</span> object, it is an external entity that calls the <span class="r-word">setValue()</span> 
     or <span class="r-word">postValue()</span>  methods to change the value.</p>

<p>It is possible to extend the <span class="r-word">LiveData</span> class to make the object itself change its value. 
    When the <span class="r-word">LiveData</span>  class is extended there are two methods that need to be overridden:</p>

    <ol>
        <li><span class="r-word">onActive()</span>: This method is executed when you have an active observer.</li>
        <li><span class="r-word">onInactive()</span>: This method is executed when you no longer have any active observers.</li>
    </ol>

    <p>The <span class="r-word">setValue()</span>  method updates the value and notifies the active observers.</p>


    <p class="sub-section">Conclusion</p>

    <p>To change the value of a <span class="r-word">MutableLiveData</span> , you have to call the <span class="r-word">setValue()</span> 
         or <span class="r-word">postValue()</span>  method, from an external entity.</p>
    
    <p>To change the value of a <span class="r-word">LiveData</span> , <span class="r-word">LiveData</span>  itself calls the <span class="r-word">setValue()</span>  or <span class="r-word">postValue()</span> 
         method.</p>
    
    <figure><img src="UD6/livedata/images/ud6-2021-11-07-20-43-34.png" /><br><figcaption></figcaption></figure>
    <br>
    

    <h3>Implemention LiveData</h3>
    
    <p>In the case of the <span class="d-word">Trainer</span>  class, it is very useful to extend the <span class="r-word">LiveData</span>  class. 
            Since in this way it will be the <span class="d-word">Trainer</span>  himself who will change his exercise on his own without anyone having to tell him.</p>
        
    
<p>It is important to understand that the <span class="d-word">trainer</span>  should only be sending exercises if there is an active observer, that is, if the fragment is running.</p>
            
<p>The <span class="r-word">LiveData</span>  implementation would look like this:</p>


<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">Trainer.kt</span>
    </section>
<section class="marco-b">
     <section><pre><code class="language-kotlin">....... 
val orderLiveData:LiveData&lt;String> = object:LiveData&lt;String>(){
    override fun onActive() {
        super.onActive()
        startTraining { 
            order -> postValue(order)
        }
    }

    override fun onInactive() {
        super.onInactive()
        stopTraining()
    }
}
...........</code></pre>
     </section>  
</section>

<p>Now,  when there is an observer for the variable <span class="d-word">orderLiveData</span> , the <span class="r-word">onActive()</span>  method will be called and 
    the trainer will begin training and will change the value of the <span class="d-word">order</span> , notifying the observers of the new <span class="negrita">order</span> .</p>

<figure><img src="UD6/livedata/images/ud6-2021-11-07-21-12-43.png" /><br><figcaption></figcaption></figure>
<br>

<p>When there is no observer (that is, when the fragment is closed), the trainer will stop training.</p>


<h3>Transformations</h3>

<p>At this point we already have the variable <span class="d-word">orderLiveData</span>  that is emitting the exercise orders.</p>

<p>It might seem that from the View we can already observe this variable and use its value to show the user the image of the corresponding exercise, thus dispensing with the <span class="r-word">ViewModel</span>.
     However, the <span class="r-word">ViewModel</span>  fulfills another function, which is to <span class="negrita">transform</span>  the data from Model into the data that the view needs.</p>

<p>In this case, the model (the trainer) sends the orders in <span class="negrita">String</span> format, separating the exercise to be done and the repetition with a colon 
    <span class="d-word">(EXERCISE: 5)</span> . The View, for its part, needs to know separately which <span class="subrayado">image to display and the repetition number</span> . 
    It will then be the <span class="r-word">ViewModel</span>  that will transform the String emitted by <span class="r-word">LiveData</span> 
    order into the two different data that the View needs.</p>

<p>Two transformations must be made:</p>

<ul>
    <li>In one, the <span class="d-word">orderLiveData</span>  will be observed and it will be transformed into another LiveData <span class="d-word">exerciseLiveData</span>
     that only contains the image to be displayed, and that only changes, when the exercise changes (not the repetition).</li>
     <li>In the other, <span class="d-word">orderLiveData</span>  will be observed and it will be transformed into the LiveData <span class="d-word">repetitionLiveData</span>  that contains the repetition.</li>
</ul>
<br>

<figure><img src="UD6/livedata/images/ud6-2021-11-07-21-30-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>To transform one <span class="r-word">LiveData</span>  into another, Android provides the <span class="negrita">Transformations</span> class. 
    This class has the <span class="r-word">switchMap()</span>  method that allows observing a <span class="r-word">LiveData</span>  and returning a different <span class="r-word">LiveData</span>.</p>

    <section><pre><code class="language-kotlin">transformedLiveData : LiveData = Transformations.switchMap(originalLiveData){
    //Transformation method
}</code></pre>
    </section><br><br>

<p>The implementation of the <span class="d-word">TrainerViewModel</span>  looks like this:</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">TrainerViewModel.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">package com.cartatar.livedatatrainer.viewmodel

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.Transformations
import com.cartatar.livedatatrainer.model.Trainer
import androidx.lifecycle.MutableLiveData
import com.cartatar.livedatatrainer.R


class TrainerViewModel(application: Application) :AndroidViewModel(application) {
    private var trainer: Trainer = Trainer()


    var exerciseLiveData :LiveData&lt;Int>
    var repetitionLiveData :LiveData&lt;String>

    private var previousExercise:String =""


    init {

        exerciseLiveData = Transformations.switchMap(trainer.orderLiveData,){
                exercise ->
            val mExercise = exercise.split(":")[0]
            if(mExercise != previousExercise){
                previousExercise = mExercise

                var imageID:Int = when(mExercise){
                    "EXERCISE1" -> R.drawable.e1
                    "EXERCISE2" -> R.drawable.e2
                    "EXERCISE3" -> R.drawable.e3
                    "EXERCISE4" -> R.drawable.e4
                    else -> R.drawable.e1

                }
                return@switchMap MutableLiveData&lt;Int>(imageID)
            }

            return@switchMap null
        }

        repetitionLiveData = Transformations.switchMap(trainer.orderLiveData) { exercise ->
            return@switchMap MutableLiveData&lt;String>(exercise.split(":")[1])
        }



    }
}</code></pre>
        </section><br><br>
</section>


<p>To transform the <span class="negrita">order</span>  into the <span class="negrita">exercise</span> , we save the previous exercise, so that we only return a new <span class="r-word">LiveData</span>  with the corresponding image 
    if the exercise has changed with respect to the previous order. If it is the same exercise as the previous one, we return <span class="cursiva"><span class="negrita">null</span></span> 
    , and in that case <span class="subrayado">the transformation is not applied, and the observer is not notified</span>.</p>

<p>To transform the <span class="negrita">order</span>  into <span class="negrita">repetition</span> , you just have to stick with what is after the colon. 
    In this case, the previous order must not be taken into account, since the repetition always changes.</p>


    <h3>Updating the View</h3>

    <p>The last step is only for the view to observe the <span class="cursiva">exercise</span>  and the <span class="cursiva">repetition</span> and to show them to the user.</p>
    

    <p>The implementation of the view looks like this:</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">TrainerFragment.kt</span>
        </section>
    <section class="marco-b">
           <section><pre><code class="language-kotlin">package com.cartatar.livedatatrainer

import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.ViewModelProvider
import com.cartatar.livedatatrainer.databinding.FragmentTrainerBinding
import com.cartatar.livedatatrainer.viewmodel.TrainerViewModel


class TrainerFragment : Fragment() {

    private lateinit var binding:FragmentTrainerBinding

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return FragmentTrainerBinding.inflate(inflater, container, false)
            .also { binding = it }
            .root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        val trainerViewModel = ViewModelProvider(this)[TrainerViewModel::class.java]

        trainerViewModel.exerciseLiveData.observe(viewLifecycleOwner){ imageID ->
            binding.ivExercise.setImageResource(imageID)
        }

        trainerViewModel.repetitionLiveData.observe(viewLifecycleOwner) { repetition ->
            if (repetition.equals("CHANGE")) {
                binding.tvChange.visibility = View.VISIBLE
            } else {
                binding.tvChange.visibility = View.GONE
            }
            binding.tvRepetition.text = repetition
        }

    }


}</code></pre>
           </section>
    </section>
    
    <p>If we run the app it works changing all values and images but... One moment! we download a GIF image but there is no movement in the images. It's due to Android
        doesn't support natively Gif images.
    </p>
    <p>We have some solutions such us using some librearies like Glide or Picasso but we will see them in the next chapter. Now we're using this
        <a class="enlace" target="_blank" href="https://github.com/koral--/android-gif-drawable">dependencies</a>. So let's add it on our <span class="inline-file">gradle module app</span></p>

    <section><pre><code class="language-kotlin">dependencies {

    .......
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.25'

}</code></pre>
    </section><br><br>

    <p>Now we have to make a little change on <span class="inline-file">fragment_trainer.xml</span>. We should replace <span class="r-word">ImageView</span> 
        for <span class="r-word">pl.droidsonroids.gif.GifImageView</span> </p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">fragment_trainer.xml</span>
        </section>
    <section class="marco-b">
    <section><pre><code class="language-xml">
......
&lt;pl.droidsonroids.gif.GifImageView
    android:id="@+id/ivExercise"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />

......</code></pre>
</section>
    </section>
    
    <p><a class="enlace" target="_blank" href="https://github.com/sdram58/EjemplosPMDM2223/tree/master/UD6/GymnasticsTrainer">Here</a> you have the whole code </p>


    <a name="PR4" class="tarea" target="_blank" href="#PR4">
        <p>PRACTICE</p>
        <p>You have to implement a <span class="negrita">Model</span>  with a <span class="negrita">LiveData</span> variable that emits data when it is observed.</p>
        <p>Implement a <span class="negrita">ViewModel</span>  that transforms the <span class="negrita">Model</span>  data into another <span class="negrita">LiveData</span> .</p>
        <p>Implement a <span class="negrita">View</span>  that observes the <span class="negrita">LiveData</span>  of the <span class="negrita">ViewModel</span>  and shows it to the user with images.</p>
        <p>For instance:</p>
        <ol>
            <li>The LiveData of the model can emit a String every second that says: "sun", "clouds", "rain", "wind"</li>
            <li>The ViewModel can transform that String into an image identifier like R.drawable.sun, etc.</li>
            <li>The View shows the corresponding image.</li>
        </ol>
    </a> 


    </section><!-- End section -->

    <!--*********************************************************FLOWS***********************************************************-->
    <section class="apartado">
        <a name="sFlows"></a>
        <h2>INTRODUCTION TO FLOWS</h2>
    
        <h3>Introduction</h3>

        <p>Flow is a component of the coroutine library that allows us to implement reactive programming. </p>


        <p>It is the natural substitute for RxJava, since the vast majority of things that can be done are here, generally simpler, 
            since they are based on concepts that we already know about <span class="d-word">coroutines</span> , <span class="d-word">sequences</span> , 
            and <span class="d-word">collections</span>  to give us a very easy solution.</p>
        
        <h3>What are the Flows?</h3>

        <p>Flows are asynchronous sequences.</p>
        
        <p class="sub-section">The Flows are lazy</p>
        
        <p>Like sequences, Flows are lazy, which means that until someone requests the Flow's values, the operations on them are not executed. </p>
        <p>This causes them to be called <span class="negrita">cold streams</span>, because they will not start providing data until someone asks to collect them. 
            Also, if another element connects to the Flow, it starts from the first value of the flow.</p>
        <p>It is important to understand this, because <span class="negrita">if a Flow performs heavy operations, 
            they will be repeated every time someone collects its values</span>.</p>

        
        
        <p class="sub-section">Flows are asynchronous</p>
        
        <p>Unlike sequences, which are processed one element after another, in Flow this is not necessarily the case. It can take a long time between one value and the next.</p>

        <p>That's why we won't normally run them on the main thread.</p>

        <p>Since all this happens in a coroutine context, think that the thread management is going to be very easy to manage.</p>


        <p class="sub-section">Flows are sequential</p>
        
        <p>This means that if a Flow is going to generate x elements, and these consist of heavy processing, they will be executed one after the other: 
            until the previous one finishes, the next one will not start.</p>
        
        <p>This, which is often an advantage, can sometimes be a disadvantage. 
            Imagine that you have to make 10 requests to servers and that each one is independent of the previous one. Even so, 
            you would have to wait for the previous one to finish to launch the next one.</p>

        <p>This can be modified, and we'll see later. But keep in mind that they work like this by default</p>
            
        

        <h3>Flow Builders</h3>

        <p>We have 3 ways to build a Flow:</p>
        
        <p class="sub-section">asFlow()</p>
        
        <p>Perhaps this is the easiest way to generate a Flow. All collections, including sequences, can be converted to a Flow using this function</p>
        
        <section><pre><code class="language-kotlin">val flow = listOf(1, 2, 3, 4).asFlow()</code></pre>
        </section><br><br>
        
        <p class="sub-section">flowOf()</p>
        
        <p>A Flow is generated with a sequence of predefined values, the equivalent of <span class="d-word">listOf()</span> 
            or <span class="d-word">sequenceOf()</span> </p>

            <section><pre><code class="language-kotlin">val flow = flowOf(1, 2, 3, 4)</code></pre>
            </section><br><br>

        <p class="sub-section">flow { }</p>
        
        <p>The most versatile of all, and the one you will surely use most often. </p>
        <p>We create a <span class="negrita">flow { }</span>  block and add values ​​with the <span class="negrita">emit()</span> function.</p>

        <p>Also, here we add the advantage that this block receives a coroutine context, so we can call suspend functions without any problem within it.</p>
        
        <section><pre><code class="language-kotlin">flow {
    for (i in (0..3)) {
        delay(200)
        emit(i)
    }
}</code></pre>
        </section><br><br>

    <h3>Types of operators</h3>

    <p>Flows can be transformed just like collections, making them very easy to use.</p>

    <p>We can filter, map, combine, transform... and a large number of operations that allow you to adapt these flows to the needs you have in the place where you use them.</p>
    
    <p>As with sequences, there are two types of operators</p>
    
     <p class="sub-section">Intermediate operators</p>
     
     <p>They are operators that do not launch any operation, regardless of their complexity. What they do is return a <span class="negrita">new Flow</span> that is
         the combination of the previous one with the new operation.</p>

    
    <p>For example, we can use the filter() operation:</p>

    <section><pre><code class="language-kotlin">makeFlow()
    .filter { it % 2 == 0 }</code></pre>
    </section><br><br>
     
    <p>And then do a map() to transform the results:</p>
    <section><pre><code class="language-kotlin">makeFlow()
    .filter { it % 2 == 0 }
    .map { "Value is $it" }</code></pre>
    </section><br><br>

    <p>But there is a particularly interesting operator, which is <span class="negrita">transform()</span> , and which allows us to make as complex transformations 
        as we need. All we have to do is call <span class="negrita">emit()</span>  with the values ​​we want to return:</p>


    <p>You can also combine multiple Flows with operations like <span class="negrita">zip()</span>  or <span class="negrita">combine()</span> :</p>
    
    <section><pre><code class="language-kotlin">val flow1 = flowOf(1, 2, 3, 4)
val flow2 = flowOf("1", "2", "3", "4")
flow1.zip(flow2) { a, b -> "$a -> $b" }</code></pre>
    </section><br><br>

    <section><pre><code class="language-kotlin">val flow1 = flowOf(1, 2, 3, 4)
val flow2 = flowOf("1", "2", "3", "4", "5")
flow1.combine(flow2) { a, b -> "$a -> $b" }.collect(){
    println(it)
}</code></pre>
    </section><br><br>

    <p>Remember that all of these operators can have suspend functions inside them, 
        so those operations can be as simple as addition or as complex as calling a server and saving the result to a database.</p>
    

    <p class="sub-section">Terminal operators</p>
    
    <p>These do launch the execution and cause the production of values begins and these to be emitted.</p>

    <p>The most common terminal operator is <span class="negrita">collect()</span> , 
        which tells Flow that there is already someone on the other side (the collector) waiting for results, and that it can start emitting them.</p>
    
    <section><pre><code class="language-kotlin">makeFlow()
    .collect { print(it) }</code></pre>
        </section><br><br>

    <p>But there is not only this one, we have several more like <span class="negrita">toList(), toSet(), first(), single(), reduce()</span>  or <span class="negrita">fold()</span> .</p>
    
    <h3>Constraints on contexts and exceptions</h3>
    <p>Flow has some restrictions, to make the whole system work properly.</p>
    
    <p>The first is that we cannot switch context within the code of a flow. If we do this, we'll get an exception:</p>
    
    <section><pre><code class="language-kotlin">fun makeFlow() = flow {
    withContext(Dispatchers.IO) {
        for (i in (0..3)) {
            delay(200)
            emit(i)
        }
    }
}</code></pre>
    </section><br><br>

<p>Flow will always run in the context of the coroutine that launched it. 
    But many times it won't be what we want, how do we then change the execution context? We can use the <span class="negrita">flowOn()</span> function:</p>

    <section><pre><code class="language-kotlin">makeFlow()
    .flowOn(Dispatchers.IO)
    .collect { print(it) }</code></pre>
    </section><br><br>

    <p>With respect to exceptions, it happens a bit the same. Exceptions should not be caught within the flows, 
        so as not to hide them and the rest of the code does not find out. There is a special function for this:</p>
    

    <section><pre><code class="language-kotlin">makeFlow()
    .catch { throwable -> println(throwable.message) }
    .collect { print(it) }
}</code></pre>
    </section><br><br>

<p>If we don't catch the exception, it will continue to propagate normally, as it happens with the rest of the coroutine components.</p>



    </section><!-- End section -->

    <!--*********************************************************WebGraphy***********************************************************-->
    <section class="apartado">
    <a name="sWebGraphy"></a>
    <h2>WebGraphy</h2>

    <ul>
        <li>
            <a class="enlace" target="_blank" href="https://developer.android.com/reference/androidx/lifecycle/LiveData">https://developer.android.com/reference/androidx/lifecycle/LiveData</a> 
        </li>
        <li><a class="enlace" target="_blank" href="https://github.com/koral--/android-gif-drawable">https://github.com/koral--/android-gif-drawable</a> </li>
        <li><a class="enlace" target="_blank" href="https://gerardfp.github.io/livedata/">Gerard's notes</a> </li>
        <li><a class="enlace" target="_blank" href="https://devexperto.com/flows-kotlin/">Flows</a> </li>
    </ul>
    
   
    </section><!-- End section -->

    <script src="../script/prism.js"></script>
</body>
</html>
