<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD9.- Introducción a Unity</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">
    <div class="fila">
      <a href="#sIntroduccion" title="1.- Introducción">1.- Introducción</a>
      <a href="#sUnityHub" title="2.- Unity Hub">2.- Unity Hub</a>
      <a href="#sInstalacionUnity" title="3.- Instalación Unity">3.- Instalación Unity</a>
    </div>
    
    <div class="fila">
      <a href="#sCrear_Proyecto_Unity" title="4.- Crear Proyecto Unity">4.- Crear Proyecto Unity</a>
      <a href="#sEditor_Unity" title="5.- Editor Unity">5.- Editor Unity</a>
      <a href="#sEjecución_del_juego" title="6.- Ejecución del juego">6.- Ejecución del juego</a>
    </div>
    
    <div class="fila">
      <a href="#sAnyadiendo_codigo_ejecutable" title="7.- Añadiendo código ejecutable">7.- Añadiendo código ejecutable</a>
      <a href="#sScripting" title="8.- Scripting">8.- Scripting</a>
      <a href="#sManejo_de_Unity" title="9.- Manejo de Unity">9.- Manejo de Unity</a>
    </div>
    <div class="fila">
      <a href="#sAgregando_GameObjects_a_la_escena" title="10.- Agregando GameObjects a la escena">10.- Agregando GameObjects a la escena</a>
      <a href="#sMateriales" title="11.- Materiales">11.- Materiales</a>
      <a href="#sComponentes_de_GameObject" title="12. Componentes de GameObject">12. Componentes de GameObject</a>
    </div>
    <div class="fila">
      <a href="#sUI" title="13.- UI">13.- UI</a>
      <a href="#sPrefabs" title="14.- Prefabs">14.- Prefabs</a>
      <a href="#sLa_Clase_GameObject" title="15.- La Clase GameObject">15.- La Clase GameObject</a>
    </div>
    <div class="fila">
      <a href="#sEl_componente_Transform" title="16.- El componente Transform">16.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="17.- La clase Input">17.- La clase Input</a>
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="18.- Movimiento cinemático y movimiento físico">18.- Movimiento cinemático y movimiento físico</a>
    </div>
    <div class="fila">
      <a href="#sColisiones" title="19.- Colisiones">19.- Colisiones</a>
      <a href="#sMetodos_Intersantes" title="20.-Métodos Intersantes">20.-Métodos Intersantes</a>
    </div>
    
  </nav> <!-- BTM_MENU-->
  
  <h1>UD9.- Introducción a Unity</h1>  
  
  <div class="main-menu">    
    <div class="fila">
      <a href="#sIntroduccion" title="1.- Introducción">1.- Introducción</a>
      <a href="#sUnityHub" title="2.- Unity Hub">2.- Unity Hub</a>
      <a href="#sInstalacionUnity" title="3.- Instalación Unity">3.- Instalación Unity</a>
    </div>
    
    <div class="fila">
      <a href="#sCrear_Proyecto_Unity" title="4.- Crear Proyecto Unity">4.- Crear Proyecto Unity</a>
      <a href="#sEditor_Unity" title="5.- Editor Unity">5.- Editor Unity</a>
      <a href="#sEjecución_del_juego" title="6.- Ejecución del juego">6.- Ejecución del juego</a>
    </div>
    
    <div class="fila">
      <a href="#sAnyadiendo_codigo_ejecutable" title="7.- Añadiendo código ejecutable">7.- Añadiendo código ejecutable</a>
      <a href="#sScripting" title="8.- Scripting">8.- Scripting</a>
      <a href="#sManejo_de_Unity" title="9.- Manejo de Unity">9.- Manejo de Unity</a>
    </div>
    <div class="fila">
      <a href="#sAgregando_GameObjects_a_la_escena" title="10.- Agregando GameObjects a la escena">10.- Agregando GameObjects a la escena</a>
      <a href="#sMateriales" title="11.- Materiales">11.- Materiales</a>
      <a href="#sComponentes_de_GameObject" title="12. Componentes de GameObject">12. Componentes de GameObject</a>
    </div>
    <div class="fila">
      <a href="#sUI" title="13.- UI">13.- UI</a>
      <a href="#sPrefabs" title="14.- Prefabs">14.- Prefabs</a>
      <a href="#sLa_Clase_GameObject" title="15.- La Clase GameObject">15.- La Clase GameObject</a>
    </div>
    <div class="fila">
      <a href="#sEl_componente_Transform" title="16.- El componente Transform">16.- El componente Transform</a>
      <a href="#sLa_clase_Input" title="17.- La clase Input">17.- La clase Input</a>
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="18.- Movimiento cinemático y movimiento físico">18.- Movimiento cinemático y movimiento físico</a>      
    </div>
    <div class="fila">
      <a href="#sColisiones" title="19.- Colisiones">19.- Colisiones</a>
      <a href="#sMetodos_Intersantes" title="20.-Métodos Intersantes">20.-Métodos Intersantes</a>
      <a href="" class="relleno"></a>
    </div>
  </div>

  
  <!--*********************************************************Introducción***********************************************************-->
  <section class="apartado">
  <a name="sIntroduccion"></a>
  <h2>Introducción</h2>
 <h3>¿Qué es Unity?</h3>
 <p>Unity es un motor de juego multiplataforma.</p>
 <p>Su origen data del año 2005.</p>
 <p>Permite el desarrollo de juegos 2D y 3D.</p>
 <p>Actualmente Unity soporta el desarrollo para unas 20 plataformas de las cuales las más populares son PC, iOS y Android.</p>
 <p>Unity ofrece un conjunto de herramientas tan completo que minimiza el uso de herramientas externas para realizar los proyectos.</p>
 
 
</section><!-- End section Introducción-->
<!--*********************************************************Unity Hub***********************************************************-->
<section class="apartado">
<a name="sUnityHub"></a>
<h2>Unity Hub</h2>

<p>El programa <a class="enlace" target="_blank" href="https://unity.com/es/pricing?check_logged_in=1#plans-student-and-hobbyist">Unity Hub</a> permite administrar las versiones del editor Unity que se deseen utilizar.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-08-33.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para poder utilizar Unity Hub se necesita disponer de una <span class="negrita">Unity ID</span></p>
<figure><img src="UD9/images/ud9-2024-01-24-12-09-03.png" /><br><figcaption></figcaption></figure>
<br>
<p>También se puede crear la Unity ID desde la web de Unity:
<a class="enlace" target="_blank" href="https://id.unity.com/es/">https://id.unity.com/es/</a>
</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-09-38.png" /><br><figcaption></figcaption></figure>
<br>
<p>Al disponer de una Unity ID además de poder utilizar el motor de videojuegos (licencia de uso) también se puede usar la <span class="negrita">Unity Asset Store</span>
   desde la cual se podrá descargar assets tanto gratuitos como de pago.</p>

   <p><a class="enlace" target="_blank" href="https://assetstore.unity.com/ ">https://assetstore.unity.com/ </a></p>
   
<figure><img src="UD9/images/ud9-2024-01-24-12-10-47.png" /><br><figcaption></figcaption></figure>
<br>


</section><!-- End section Unity Hub-->


<!--*********************************************************Instalación Unity***********************************************************-->
<section class="apartado">
<a name="sInstalacionUnity"></a>
<h2>Instalación Unity</h2>
<p>Para desarrollar videojuegos se necesita el <span class="negrita">editor Unity</span>.</p>

<p>La primera vez que se accede a Unity Hub con la Unity ID se indica que se puede instalar un editor Unity.</p>

<p>Por defecto, el editor Unity que se instalará será la última versión estable <span class="negrita">LTS</span> (Long Term Support).</p>

<p>No se recomienda esta instalación por defecto ya que no permite configurar la instalación.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-12-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>Desde el apartado <span class="negrita">Installs</span> de <span class="negrita">Unity Hub</span>
   se pueden instalar las diferentes versiones del editor Unity disponibles:</p>

<figure><img src="UD9/images/ud9-2024-01-24-12-35-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se debe elegir qué configuración se quiere para el editor Unity que permitirá crear los ejecutables del juego para cada plataforma, añadir idiomas asiáticos y la documentación de Unity.</p>
<p>Para clase será suficiente con marcar <span class="negrita">Linux Build Support (IL2CPP)</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-36-15.png" /><br><figcaption></figcaption></figure>
<br>
<h3>Editor de código</h3>
<p>Unity necesita un editor de código para la programación de scripts, en Windows durante la instalación del editor Unity se incluye <span class="negrita">Microsoft Visual Studio Community</span>. 
  En clase, aquellos que lo tengan, detectará <span class="negrita">Visual Studio Code</span> y lo configurará como editor por defecto.</p>

<p>Si no se tiene instalado ese editor y no se quiere instalar, se debe desmarcar.</p>

<p>En el caso de usar <span class="negrita">Microsoft Visual Studio Community</span> o <span class="negrita">Visual Studio Code</span>
   como editor por defecto se pueden instalar las extensiones para el lenguaje de programación <span class="negrita">C#</span> que es el usado con Unity.</p>

<figure><img src="UD9/images/ud9-2024-01-24-12-38-44.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si no se tiene instalado <span class="negrita">Microsoft Visual Studio Community</span> y no se quiere instalar, se debe desmarcar.</p>
<p>Se puede utilizar cualquier otro editor de código cambiando la configuración del editor Unity una vez esté instalado. 
  En <span class="negrita">Menú &rarr; Edit &rarr; Preferences</span>.</p>

  <figure><img src="UD9/images/ud9-2024-01-24-12-40-06.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Si más adelante en el desarrollo se necesita, se pueden añadir/eliminar módulos al editor.</p>
  
<figure><img src="UD9/images/ud9-2024-01-24-12-40-35.png" /><br><figcaption></figcaption></figure>
</section><!-- End section Instalación Unity-->

<!--*********************************************************Crear Proyecto Unity***********************************************************-->
<section class="apartado">
<a name="sCrear_Proyecto_Unity"></a>
<h2>Crear Proyecto Unity</h2>

<p>Unity HUB será el punto de inicio de cualquier proyecto Unity, en su ventana se pueden ver las secciones:
  <ul>
    <li><span class="negrita">Projects</span>: gestor de proyectos.</li>
    <li><span class="negrita">Installs</span>: gestor de editores Unity instalados.</li>
    <li><span class="negrita">Learn</span>: apartado de autoaprendizaje</li>
    <li><span class="negrita">Community</span>: acceso a la comunidad con secciones como Assets Store o Foros.</li>
    
  </ul>
  
</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-43-08.png" /><br><figcaption></figcaption></figure>
<br>

<p>Desde <span class="negrita">Unity Hub</span>, en el apartado <span class="negrita">Projects</span> se pueden crear proyectos pulsando el botón <span class="d-word">New project</span>.</p>

<figure><img src="UD9/images/ud9-2024-01-24-12-43-46.png" /><br><figcaption></figcaption></figure>
<br>
<p>Al crear un proyecto se debe <span class="negrita">elegir el tipo de proyecto</span> para que se carguen las librerías necesarias.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-44-24.png" /><br><figcaption></figcaption></figure>
<br>
<p>Una vez creado el proyecto, este estará disponible en Unity Hub.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-45-11.png" /><br><figcaption></figcaption></figure>
<br>

<p>Durante la creación <span class="subrayado">se abrirá el editor Unity</span> para ese proyecto.</p>

<div class="tarea">
  <p><span class="negrita">Actividad 1:</span> <br>Instalación de un editor Unity.</p>
  <p><span class="negrita">Actividad 2:</span> <br>Crea el proyecto <span class="negrita">PruebaTuNombre</span>.</p>
</div>

</section><!-- End section Crear Proyecto Unity-->
<!--*********************************************************Editor Unity***********************************************************-->
<section class="apartado">
<a name="sEditor_Unity"></a>
<h2>Editor Unity</h2>
<p>Por defecto la ventana del editor Unity tiene el siguiente aspecto:</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-47-45.png" /><br><figcaption></figcaption></figure>
<br>

<p>Unity hace uso de la <span class="negrita">Programación Orientada a Objetos</span>, 
  por esta razón todos los elementos del juego se incluyen en la jerarquía de objetos.</p>

<p>El <span class="negrita">juego</span> ocupa la posición más alta de la jerarquía y 
  dentro de él se ubican las <span class="negrita">escenas</span> que podrían considerarse las pantallas del juego.</p>

<p>La <span class="negrita">jerarquía</span> muestra todos los elementos que tiene una escena.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-49-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>Dentro de cada escena se deben añadir todos los elementos que se necesiten, 
  estos elementos son los <span class="d-word">GameObject</span>, las escenas también siguen una estructura jerárquica pudiendo agruparse los <span class="negrita">GameObjects</span>
  unos dentro de otros.</p>

<p>Por defecto, un proyecto Unity contiene una <span class="negrita">Escena</span> que a su vez contiene un <span class="negrita">GameObject</span>
   de tipo <span class="negrita">cámara</span> llamado <span class="d-word">Main Camera</span> y un <span class="negrita">GameObject</span> de tipo 
   <span class="negrita">luz</span> llamado <span class="d-word">Directional Light</span>.</p>

  <p>En la parte central del editor se puede observar una <span class="negrita">visualización de la escena</span> que
    cuando se pulse el botón de reproducir juego se convertirá en <span class="negrita">la visualización desde la cámara configurada en el juego</span>.</p>
    <figure><img src="UD9/images/ud9-2024-01-24-12-52-56.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Cuando se selecciona un objeto de la escena, en el <span class="negrita">Inspector</span> se pueden observar todas sus características.</p>
    
<figure><img src="UD9/images/ud9-2024-01-24-12-53-48.png" /><br><figcaption></figcaption></figure>
<br>

    <p>Desde el código se podrá acceder a los componentes de cada objeto.</p>
   
  <p>Cada tipo de objeto tendrá unos componentes por defecto, y además, se les puede añadir componentes si se necesita.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-54-33.png" /><br><figcaption>Main Camera</figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-01-24-12-54-55.png" /><br><figcaption>Directional Light</figcaption></figure>
  <br>
  <p>En el <span class="negrita">Gestor de archivos</span> permite visualizar y realizar todas las acciones que se requieran sobre los archivos del proyecto.</p>
  <p>Se recomienda que todas las carpetas y archivos que se quieran crear se creen desde el gestor de archivos del editor.</p>
  
   <figure><img src="UD9/images/ud9-2024-01-24-12-55-54.png" /><br><figcaption></figcaption></figure>
   <br>
  <p>En la documentación oficial se puede encontrar toda la información de la interfaz de Unity: 
    <a class="enlace" target="_blank" href="https://docs.unity3d.com/2023.3/Documentation/Manual/UsingTheEditor.html">https://docs.unity3d.com/2023.3/Documentation/Manual/UsingTheEditor.html</a>
  </p>
  
  <figure><img src="UD9/images/ud9-2024-01-24-12-56-39.png" /><br><figcaption></figcaption></figure>
    
   
</section><!-- End section Editor Unity-->

<!--*********************************************************Ejecución del juego***********************************************************-->
<section class="apartado">
<a name="sEjecución_del_juego"></a>
<h2>Ejecución del juego</h2>
<p>Cuando se <span class="negrita">ejecuta el juego</span> (botón "Play" ▶ de la barra superior) la sección de visualización cambia a la vista de la cámara y
   toda la interfaz se oscurece.</p>

<p>Al ejecutar el juego se puede trabajar con el proyecto para poder ver cómo reacciona según diferentes valores, 
  pero <span class="negrita">los cambios solo se mantienen durante la ejecución del juego</span>.</p>

<p>Al no haber casi diferencia de estilo entre los dos estados a veces se nos olvida que se está ejecutando el juego y se pierden los cambios.</p>
<figure><img src="UD9/images/ud9-2024-01-24-12-59-27.png" /><br><figcaption></figcaption></figure>
<br>

<p>Desde el <span class="negrita">Menú &rarr; Edit &rarr; Preferences</span> en la sección <span class="negrita">Colors</span>
   se puede decidir qué color va a superponer a la interfaz cuando se ejecute el juego: <span class="negrita">Playmode tint</span>.</p>

<p>Interesa poner un modo que aporte mucho contraste para así saber siempre si se está ejecutando o no.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-00-34.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una vez cambiado el color se aprecia mucho mejor que se está ejecutando el juego.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-01-12.png" /><br><figcaption></figcaption></figure>



</section><!-- End section Ejecución del juego-->

<!--*********************************************************Añadiendo código ejecutable***********************************************************-->
<section class="apartado">
  <a name="sAnyadiendo_codigo_ejecutable"></a>
  <h2>Añadiendo código ejecutable</h2>

  <p>Para añadir código ejecutable al proyecto se deben crear los archivos que permitan contener dicho código, a estos archivos se les llama <span class="negrita">scripts</span>.</p>
  <p>Existen varias maneras de añadir scripts al proyecto pero la más adecuada es mediante el gestor de archivos.</p>
  <p>Además, es importante mantener una buena organización de los archivos por lo que lo más habitual 
    es crear dentro de la carpeta <span class="inline-folder">Assets</span> una carpeta llamada <span class="inline-folder">Scripts</span> 
    y en ella crear todos los Scripts necesarios.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-14-52.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una vez creada la carpeta <span class="inline-folder">Scripts</span> con el botón derecho sobre ella o sobre la parte derecha en el gestor 
  (la que representa la carpeta), se debe seleccionar <span class="negrita">Create &rarr; C# Script</span></p>

<figure><img src="UD9/images/ud9-2024-01-24-13-15-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>En ese momento se debe escribir el nombre del archivo, <span class="subrayado">siguiendo las convenciones de C# que son similares a las de Java</span>
   (<span class="negrita">CamelCase</span> con la primera en mayúscula).</p>

<p>Además, el script debe tener un nombre que identifique correctamente las acciones que realiza.</p>

<p>Cuando se selecciona un Script en el Gestor de archivos, en el Inspector se puede ver su código aunque no se puede editar desde ahí.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-16-57.png" /><br><figcaption></figcaption></figure>
<br>
<p>Al hacer doble clic sobre el Script se abrirá el editor de código configurado.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-37-10.png" /><br><figcaption>Microsoft Visual Studio Community</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-24-13-37-44.png" /><br><figcaption>Visual Studio Code</figcaption></figure>
<br>

<h3>Estructura por defecto de un Script de Unity</h3>
<p>Un Script de Unity por defecto tiene la siguiente estructura:</p>

<figure><img src="UD9/images/ud9-2024-01-24-13-39-20.png" /><br><figcaption></figcaption></figure>
<br>
<p>La cantidad de negº   de un juego es variable por lo que el método <span class="r-word">Update</span> no siempre se ejecuta la misma cantidad de veces.</p>

<p>El siguiente código hará que cuando se ejecute el script aparezcan por consola dichos mensajes.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-40-27.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para probarlo se pulsa el botón "Play" ▶ en la parte superior central del editor Unity.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-40-42.png" /><br><figcaption></figcaption></figure>
<br>

<p>Como se puede observar una vez seleccionada la pestaña <span class="negrita">Console</span> no aparece ningún mensaje.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-41-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>Esto se debe a que <span class="negrita">para que un script se ejecute debe estar asociado a un GameObject</span>.</p>

<p>Se puede asociar un script a un GameObject arrastrando el script desde el gestor de tareas al GameObject de diferentes maneras:
  <ul>
    <li>Arrastrando el script hasta el GameObject en la jerarquía.</li>
    <li>Arrastrando el script hasta el GameObject en la zona de visualización.</li>
    <li>Seleccionando el GamObject y arrastrando el script hasta el Inspector.</li>
  </ul>
</p>

<p>Una vez se ha asociado un script a un GameObject, este se convierte en un componente del GameObject y aparece en el Inspector.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-42-50.png" /><br><figcaption></figcaption></figure>
<br>
<p>Ahora, al ejecutar el juego sí que se ejecutará el script creado.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-45-10.png" /><br><figcaption></figcaption></figure>
<br>

<p>Es importante marcar la opción <span class="negrita">Collapse</span> que unificará en una línea los mensajes con el mismo contenido e 
  irá aumentando el número de veces.</p>

<p>También puede ser interesante activar la opción <span class="negrita">Stats</span> en la visualización para obtener información como puede ser los <span class="negrita">FPS</span> 
  (frames por segundo) a los que se está ejecutando el juego.</p>
  
<figure><img src="UD9/images/ud9-2024-01-24-13-45-54.png" /><br><figcaption></figcaption></figure>
<br>
<br>
<hr>
<div class="tarea">
  <p>Actividad 3: <br>Crea un Script llamado MiPrimerScript que muestre "hola mundo! y asócialo a la Main Camera, luego quítalo y asócialo a Directional Light, 
    finalmente crea un EmptyObject y asócialo a éste. ¿Hay alguna diferencia?"</p>
</div>

</section><!-- End section Añadiendo código ejecutable-->

<!--*********************************************************Scripting***********************************************************-->
<section class="apartado">
<a name="sScripting"></a>
<h2>Scripting</h2>
<p>Como toda aplicación informática, los juegos necesitan que se codifique su funcionalidad.</p>

<p>En Unity la codificación de la funcionalidad se realiza mediante los <span class="negrita">scripts</span>.</p>

<p>Mediante los scripts se podrá:
  <ul>
    <li>Responder a las entradas del jugador.</li>
    <li>Ejecución eventos en el momento adecuado.</li>
    <li>Crear efectos gráficos.</li>
    <li>Controlar el comportamiento físico de los GameObjects.</li>
    <li>Implementar un sistema de IA para los NPC del juego.</li>
    <li>…</li>
  </ul>
</p>




<p>Actualmente el único lenguaje de programación recomendado para realizar proyectos con Unity es <span class="r-word">C#</span>.</p>
<p>También hay soporte para el lenguaje <span class="negrita">UnityScript</span> que se diseñó a partir de JavaScript específicamente para Unity, 
  pero se desaconseja su uso. Es posible que algún proyecto actual aún tenga scripts con UnityScript.</p>
<p>Antiguamente también se podría utilizar el lenguaje <span class="negrita">Boo</span> que tenía una sintaxis similar a Python. Hoy en día no tiene soporte</p>

<p><span class="negrita">C#</span> fue creado en el año 2000 para ser compatible con la plataforma <span class="cursiva">.NET de Microsoft</span>.

<p>Hereda lo mejor de C++, Java y Visual Basic.</p>

<p>Es un lenguaje orientado a objetos nativo.</p>

<p>Gracias a la librería IL2CPP los scripts realizados en Unity se convierten a scripts C++ 
  para que el compilador nativo finalice la compilación en la plataforma destino.</p>

  <p>Un script para Unity tiene la siguiente estructura básica:
    <ul>
      <li><span class="negrita">UnityEngine</span>: importa la clase MonoBehaviour necesaria para definir los scripts asociados a GameObjects.</li>
      <li><span class="negrita">System.Collections</span>: librería de .NET con listas, arrays, tablas hash…</li>
      <li> Clase definida que extiende a MonoBehaviour:
        <ul>
          <li><span class="negrita">Método Start</span>: se usa para inicializar el GameObject.</li>  
          <li><span class="negrita">Método Update</span>: se ejecuta una vez por frame, se le llama bucle del juego.</li>
        </ul>
      </li>
    </ul>
  </p>
    
  <p>En C# todas las instrucciones deben acabar con <span class="d-word">;</span> <span class="subrayado">igual que pasa en Java</span>.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-54-35.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
  <h3>Tipos de datos en C#</h3>
<p class="sub-section">Tipos de datos básicos de C# son:</p>

<figure><img src="UD9/images/ud9-2024-01-24-13-55-57.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Tipos de datos compuestos:</p>

<p>
    <ul>
      <li><span class="negrita">Array</span>: conjunto de un tipo de dato.</li>
      <li><span class="negrita">List</span>: listas dinámicas (pueden modificar su tamaño).</li>
    </ul>
  </p>
  
<p class="sub-section">Tipos de datos específicos de C# para Unity son:</p>

<p>
  <ul>
    <li><span class="negrita">Vector3</span>: empaquetado de tres floats (x, y, z) que facilita el trabajo con puntos, vectores y direcciones dentro del espacio 3D.</li>
    <li><span class="negrita">GameObject</span>: referencia a un GameObject de la escena o a un prefab del proyecto.</li>
    <li><span class="negrita">Transform, Rigidbody o cualquier otro componente</span>: referencia a dicho componente dentro de un GameObject.</li>
    <li><span class="negrita">Texture, Material o cualquier otro tipo de asset</span>: referencia a un asset del proyecto</li>
  </ul>
</p>

<h3>Operadores</h3>
<p>Los operadores son similares a los usados en Java:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-27-24.png" /><br><figcaption></figcaption></figure>
<br>
<p>La clase <span class="r-word">Mathf</span> permite cálculos con números tipo <span class="r-word">float</span>:</p>

<p>Ejemplos:
  <ul>
    <li>Mathf.Abs(number)</li>
    <li>Mathf.Round(number)</li>
    <li>Mathf.Ceiling(number)</li>
    <li>Mathf.Floor(number)</li>
    <li>Mathf.Max(a, b, c, d)</li>
    <li>Mathf.Min(a, b, c, d)</li>
    <li>Mathf.Pow(number, exponent)</li>
    <li>Mathf.Sqrt(number)</li>
    <li>…</li>

  </ul>
</p>

<h3>Variables</h3>

<p>Las variables en C# se definen igual que en java:</p>

	<section><pre><code class="language-kotlin">int age;</code></pre>
  </section><br>

<p>También se puede inicializar cuando se declara:</p>

	<section><pre><code class="language-kotlin">int age = 21;</code></pre>
  </section><br>

<p>Una vez declarada en cualquier momento se puede cambiar su valor:</p>

	<section><pre><code class="language-kotlin">age = 22;</code></pre>
  </section><br>


<p>Si las variables se declaran para la clase como propiedades se pueden declarar su acceso como <span class="negrita">public</span> o <span class="negrita">private</span>.</p>
<p>Si la variable se declara dentro de un método no se debe declarar el tipo de acceso ya que solo será visible dentro de ese método.</p>

<figure><img src="UD9/images/ud9-2024-01-25-10-30-33.png" /><br><figcaption></figcaption></figure>
<br>

<p>Las variables declaradas como propiedades con acceso public <span class="subrayado">serán visibles desde el Inspector de Unity</span> durante la ejecución, permitiendo cambiar su valor durante la ejecución desde allí.</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-31-18.png" /><br><figcaption></figcaption></figure>
<br>


<p>Hay que recordar que los cambios realizados durante la ejecución son cambios temporales y al parar la ejecución se volverá al estado inicial.</p>

<h3>Estructuras de control</h3>

<figure><img src="UD9/images/ud9-2024-01-25-10-48-49.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Arrays</h3>
<p class="sub-section">Declarar un <span class="negrita">Array</span></p>
<p>Se puede indicar su tamaño y posteriormente asignar valores:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-49-57.png" /><br><figcaption></figcaption></figure>
<br>


<p>Se puede declarar asignando directamente los valores:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-50-13.png" /><br><figcaption></figcaption></figure>

<p class="sub-section">Recorrer un <span class="negrita">Array</span></p>
<p>Con un bucle <span class="negrita">for</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-51-21.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con un bucle <span class="negrita">foreach</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-51-40.png" /><br><figcaption></figcaption></figure>

<h3>Listas</h3>
<p>Las <span class="negrita">listas</span> permiten modificar su tamaño y añadir/eliminar elementos de la misma.</p>

<p>Se necesita importar la librería:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-04.png" /><br><figcaption></figcaption></figure>
<br>

<p>Declarar una lista vacía:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-18.png" /><br><figcaption></figcaption></figure>
<br>

<p>Declarar una lista asignando datos:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-33.png" /><br><figcaption></figcaption></figure>
<br>
<p>Las <span class="negrita">listas</span> permiten modificar su tamaño y añadir/eliminar elementos de la misma.</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-17.png" /><br><figcaption></figcaption></figure>
<br>

<p>Modificar elementos se realiza igual que con los Array:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-36.png" /><br><figcaption></figcaption></figure>
<br>

<p>Añadir elementos a una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-57.png" /><br><figcaption></figcaption></figure>
<br>

<p>Eliminar elementos de una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-58-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Obtener la longitud de una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-58-36.png" /><br><figcaption></figcaption></figure>
<br>
<p>Eliminar todos los elementos de una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-00-32.png" /><br><figcaption></figcaption></figure>
<br>

<p>Comprobar si un valor está en una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-00-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Ordenar una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-01-05.png" /><br><figcaption></figcaption></figure>
<br>

<p>Invertir el orden de una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-01-21.png" /><br><figcaption></figcaption></figure>
<br>
<p>Recorrer una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-23.png" /><br><figcaption></figcaption></figure>
<br>

<p>Convertir una lista en un array:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-38.png" /><br><figcaption></figcaption></figure>
<br>

<p>Convertir un array en una lista:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-58.png" /><br><figcaption></figcaption></figure>
<br>

<h3>ArrayList</h3>
<p>En un Array o en una Lista solo se pueden almacenar datos de un tipo.</p>


<p>En los <span class="r-word">ArrayList</span> se permite almacenar datos de diferentes tipos además de no tener un tamaño predeterminado como las listas.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-04-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se debe tener cuidado al cambiar los datos porque el compilador no realiza ninguna comprobación de tipo de dato:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-05-06.png" /><br><figcaption></figcaption></figure>
<br>

<h3>HashTable</h3>
<p>Los <span class="r-word">HashTable</span> también conocidos como <span class="negrita">diccionarios</span> son un tipo de dato 
  compuesto en el que cada elemento es un par <span class="negrita">clave-valor</span>.</p>

<p>En los HashTable se accede a los datos a través de la clave.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-06-39.png" /><br><figcaption></figcaption></figure>
<br>

<p>Las claves siempre deben ser de tipo <span class="negrita">string</span>.</p>

<p>El tamaño de una HashTable es dinámico como las listas.</p>

<p>Se puede comprobar si existe una clave con el método <span class="negrita">Contains</span> y para usar el valor se debe realizar un casting:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-07-37.png" /><br><figcaption></figcaption></figure>
<br>

<p>Recorrer un HashTable:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-08-34.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Métodos</h3>
<p>Como en cualquier lenguaje orientado a objetos dentro de las clases se pueden crear métodos.</p>


<p>En C# para crear un método se debe seguir la siguiente estructura:
  <ul>
    <li>Tipo de acceso (si no se pone nada por defecto será private).</li>
    <li>Tipo de dato que devuelve (void si no devuelve nada).</li>
    <li>Identificador del método (primera letra en mayúscula y CamelCase).</li>
    <li>Paréntesis para indicar los parámetros si los hay.</li>
    <li>Llaves para indicar el bloque de código del método.</li>
  </ul>
</p>
<p>Declaración de un método:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-10-37.png" /><br><figcaption></figcaption></figure>
<br>

<p>La llamada a un método se realiza igual que en cualquier lenguaje de programación:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-11-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Clase MonoBehaviour</h3>
<p>Cuando se crea un script C# en Unity se puede observar que la clase que contiene el script hereda de la clase <span class="r-word">MonoBehaviour</span>.</p>

<p>La clase <span class="negrita">MonoBehaviour</span> es necesaria para los scripts que se asocian a los <span class="negrita">GameObject</span> del proyecto.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-12-47.png" /><br><figcaption></figcaption></figure>
<br>
<p>Como Unity funciona por eventos, dentro de las clases que heredan de MonoBehaviour se pueden incluir una serie de métodos definidos por defecto que se ejecutarán cuando se produzcan los eventos asociados a dichos métodos.</p>

<p>Por defecto se añaden dos métodos que se ejecutan con determinados eventos:
  <ul>
    <li><span class="negrita">Start</span>: se llama en el frame en el que el script se activa y justo antes de la primera llamada de cualquier método Update.</li>
    <li><span class="negrita">Update</span>: se llama en cada frame.</li>
  </ul>
</p>


<p>Hay muchos métodos más que se pueden consultar en la documentación: 
  <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a></p>

<h3>Bucle del juego</h3>

<p>Se puede definir como bucle del juego las diferentes fases por las que pasa un script cuando se ejecuta:
  <ul>
    <li>Inicialización</li>
    <li>Actualización de físicas</li>
    <li>Actualización de INPUT</li>
    <li>Lógica del juego</li>
    <li>Destrucción</li>
  </ul>
</p>

<p>Cada una de estas fases tiene asociados un conjunto de métodos de la clase MonoBehaviour:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-15-54.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al ejecutar el juego, Unity comienza a ejecutar el bucle del juego, de esta manera, 
  en cada fase ejecutará los métodos correspondientes que se encuentren en los scripts añadidos a los GameObject de la escena.</p>

<p>Ejemplo de un script implementando algunos de los métodos de la clase MonoBehaviour:</p>

<figure><img src="UD9/images/ud9-2024-01-25-11-16-34.png" /><br><figcaption></figcaption></figure>

</section><!-- End section Scripting-->

<!--*********************************************************Manejo de Unity***********************************************************-->
<section class="apartado">
<a name="sManejo_de_Unity"></a>
<h2>Manejo de Unity</h2>
<p>Es muy importante aprender cómo funciona la ventana de visualización de Unity para poder trabajar correctamente con los GameObject.</p>

<p>La ventana de visualización es el lugar donde se pueden ver los objetos que forman parte de la escena.</p>

<p>En esta ventana suelen aparecer los llamados gizmos, un gizmo es un gráfico que ayuda al programador ofreciendo información sobre el GameObject dentro de la escena.</p>

<p>Por ejemplo, si se selecciona la luz que aparece en la escena se podrá ver cómo aparece un gizmo que indica la dirección de la luz.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-22-45.png" /><br><figcaption></figcaption></figure>
<br>
<p>El sistema de coordenadas es el que permite ubicar a todos los GameObject en la escena.</p>

<p>Cada GameObject tendrá unas coordenadas que indican su posición.</p>

<p>Unity utiliza un sistema de coordenadas <span class="negrita">Y-Up</span>:
  <ul>
    <li><span class="negrita">x</span>: eje horizontal</li>
    <li><span class="negrita">y</span>: eje vertical</li>
    <li><span class="negrita">z</span>: eje profundidad</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-59-29.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cada motor de juegos y cada editor 3D utiliza un sistema de coordenadas diferente.</p>

<p>Unity utiliza el sistema Y-Up.</p>

<p>Unreal y Blender utilizan el sistema Z-Up donde el eje vertical es z y el eje de profundidad es y.</p>
<p>En la <span class="negrita">parte superior derecha de la ventana de visualización</span> aparece un <span class="negrita">gizmo</span>
   muy útil que indica la dirección en la que se está visualizando la escena.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-00-40.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al hacer clic en lo conos se cambia la visualización para orientarse en ese eje.</p>

<p>En la parte inferior de ese gizmo aparece el punto de vista actual, puede indicar "Persp" o cualquier otra dirección como "Back", si se pulsa sobre el cubo central o en el icono de debajo con el punto de vista actual, se cambia a una visualización isométrica.</p>

<p>Si se está desarrollando un juego en 3D la visualización irá cambiando constantemente, pero si se está desarrollando un juego en 2D la visualización por defecto no es la correcta y debería cambiarse.</p>

<p>En la parte superior se encuentran las siguientes herramientas.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-01-47.png" /><br><figcaption></figcaption></figure>
<br>

<p>En la izquierda:
  <ul>
    <li>Las dos primeras son opciones de cómo funciona la herramienta "mano".</li>
    <li>La tercera permite activar/desactivar la visualización de la rejilla.</li>
    <li>La cuarta permite que al mover los GamObjects se "enganchen" a los puntos de la rejilla.</li>
    <li>La quinta indica los pasos de movimiento cuando se mueve un GameObject.</li>
  </ul>
</p>

<p>En la derecha:
  <ul>
    <li>La primera indica cómo se van a visualizar los GameObjects de la escena (sólidos, aristas…).</li>
    <li>La segunda permite cambiar el tipo de cámara de 3D a 2D (ortográfica).</li>
    <li>La tercera permite activar/desactivar las luces de la escena.</li>
    <li>La cuarta permite activar/desactivar los sonidos.</li>
    <li>La quinta permite activar efectos como el cielo, la niebla…</li>
    <li>La sexta permite mostrar/ocultar el número de GameObjects ocultos en la escena.</li>
    <li>La séptima permite configurar la cámara.</li>
    <li>La octava permite configurar la visualización de los gizmos.</li>
  </ul>
</p>

<p>En la parte superior izquierda se encuentran las siguientes herramientas que permiten desplazarse por la escena y manipular los GameObject de la misma:</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-09-50.png" /><br><figcaption></figcaption></figure>
<br>
<p>Las herramientas anteriores que permiten modificar un GameObject de la escena, 
  al seleccionarlas mostrarán un gizmo sobre el GameObject para facilitar la manipulación del GameObject.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-11-24.png" /><br><figcaption></figcaption></figure>
<br>

<p>Todos los GameObjects tienen un <span class="negrita">punto pivote</span> que será a partir del cual se ejecutarán los cambios sobre ellos.</p>

<p>El punto pivote por defecto se encuentra en el <span class="negrita">centro del Gameobject</span>, 
  por eso el gizmo de las herramientas anteriores se dibuja desde el centro del GameObject seleccionado.</p>

  <figure><img src="UD9/images/ud9-2024-01-25-13-50-41.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>El punto pivote no se puede cambiar de sitio.</p>

  <h3>Movimiento de la cámara de visualización</h3>

  <p class="sub-section">Con teclas:</p>
  <p>
    <ul>
      <li>Flechas ⬅ ➡: desplaza izquierda-derecha la cámara.</li>
      <li>Flechas ⬆ ⬇: zoom-in y zoom-out.</li>
    </ul>
  </p>
  
  
  <p class="sub-section">Con ratón:</p>
  <p>
    <ul>
      <li>Con la herramienta mano seleccionada al hacer clic y arrastrar: se desplaza en horizontal y vertical la cámara.</li>
      <li>Botón central (rueda) del ratón: misma acción que la línea anterior.</li>
      <li>CTRL + ALT + clic izquierdo: misma acción que la línea anterior.</li>
      <li>Con el botón derecho pulsado: se rota la cámara sobre sí misma.</li>
      <li>ALT + clic izquierdo: rota la cámara sobre el punto central de la visualización.</li>
    </ul>
  </p>

  <p>Todos los GameObject se pueden mover/alinear con la visualización.</p>

  <p>Esto es útil con las cámaras porque permiten alinear la cámara a la vista de visualización para que al ejecutar el juego sea esa orientación vista la que se vea.</p>
  
  <figure><img src="UD9/images/ud9-2024-01-25-13-53-48.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Como se ha indicado anteriormente, si se está desarrollando un juego en 2D interesa cambiar la visualización de la escena para que se ajuste a la visualización 
    del juego teniendo el eje z en horizontal y el eje y en vertical.</p>
  <figure><img src="UD9/images/ud9-2024-01-25-13-54-45.png" /><br><figcaption></figcaption></figure>
  <br>
  
</section><!-- End section Manejo de Unity-->

  <!--*********************************************************Agregando GameObjects a la escena***********************************************************-->
  <section class="apartado">
    <a name="sAgregando_GameObjects_a_la_escena"></a>
    <h2>Agregando GameObjects a la escena</h2>
    
    <p>Para agregar GameObjects a la escena se puede hacer click derecho sobre la zona de elementos de la escena (jerarquía) 
      o bien se puede pulsar la opción del menú GameObject.</p>
    
<p>La opción del menú ofrece además acciones a realizar sobre un GameObject si está seleccionado.</p>
<figure><img src="UD9/images/ud9-2024-01-25-13-56-44.png" /><br><figcaption></figcaption></figure>
<br>
<p>Dependiendo del tipo de proyecto se tendrán disponibles diferentes tipos de GameObjects para a la escena 
  (desde el Package Manager se pueden agregar paquetes para ampliar el catálogo).</p>

<p>Se pueden añadir GameObjects vacíos (empty) que sirven para agrupar otros GameObjects y así mantener la jerarquía organizada.</p>

<p>También existen objetos 3D que serán los primeros con los que se trabajará en clase.</p>

<figure><img src="UD9/images/ud9-2024-01-25-13-58-59.png" /><br><figcaption>Proyecto 3D</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-25-13-59-21.png" /><br><figcaption>Proyecto 3D con el paquete 2D Sptrite</figcaption></figure>
<br>
<p>Al agregar un GameObject a la escena en la jerarquía se permite cambiar el nombre 
  (posteriormente se puede cambiar haciendo clic derecho sobre él en la jerarquía).</p>

<p>Además, al añadir el GameObject, este se posiciona en el centro de la escena sean cuales sean esas coordenadas.</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-00-24.png" /><br><figcaption></figcaption></figure>
<br>


<p>Al seleccionar el GameObject en el inspector se puede ver los componentes que tiene, 
  entre ellos se encuentra <span class="r-word">Transform</span> que indica los valores de <span class="negrita">posición, rotación y escala</span>.</p>

  <p>Los GameObject se agregan en la jerarquía como hijos de la escena.</p>

  <p>Desde la jerarquía, se pueden organizar los GameObject unos dentro de otros arrastrándolos encima del que debe contenerlos o 
    arrastrándolos fuera del que los contiene.</p>
  
  <p>Si se hace clic derecho sobre un objeto en la jerarquía y se añade un GameObject, este se añadirá directamente como hijo del que se ha pulsado.</p> 
  <figure><img src="UD9/images/ud9-2024-01-25-14-01-59.png" /><br><figcaption></figcaption></figure>
  <br>
  
<section class="marco-t warn">
  <span class="icono warning"> </span>Todas las modificaciones que se realicen sobre un GameObject afectan a todos los GameObjects que se encuentren 
  dentro de él en la jerarquía.
  </section>
<section class="marco-b">
    
</section>

<h3>Punto pivote de un GameObject</h3>
<p><span class="negrita">Todos los GameObject tienen un punto pivote situado en su centro.</span></p>

<p>Las coordenadas de este punto pivote en la escena es lo que utiliza Unity para realizar todos los cálculos necesarios.</p>

<p>El punto pivote <span class="negrita">no se puede cambiar de sitio</span>.</p>

<p>El punto pivote también es la referencia cuando un GameObject sigue a otro, por ejemplo, una cámara que sigue a un personaje, 
  en este caso la cámara tomará como centro a seguir el punto pivote del GameObject.</p>

<p>Si se quiere que ese centro de seguimiento sea diferente se puede crear un GameObject vacío y añadirlo al GameObject principal en las coordenadas que se quiera, y a continuación indicar que la cámara siga al GameObject vacío.</p>

<h3>Modificando GameObjects</h3>
<p>Para modificar un GameObject se debe seleccionar o haciendo clic en él en la jerarquía o haciendo clic en él en la visualización de la escena.</p>

<p>Si se hace doble clic en un GameObject de la jerarquía además de seleccionar el GameObject la vista se centrará en ese GameObject.</p>

<p>Si se hace clic sobre un GameObject en la visualización además de seleccionar el GameObject la vista se centrará donde se hecho doble clic.</p>

<p><span class="negrita">Todas las modificaciones se realicen sobre un GameObject toman como referencia el punto pivote del GameObject</span>.</p>

<p>Existen varias formas de modificar un GameObject en la escena:</p>

<p class="sub-section">Cambiando manualmente sus valores en el inspector</p>

<figure><img src="UD9/images/ud9-2024-01-25-14-06-47.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede indicar que el GameObject se sitúe en el centro del las coordenadas (0,0,0).</p>

<figure><img src="UD9/images/ud9-2024-01-25-14-07-26.png" /><br><figcaption></figcaption></figure>
<br>

<p>Esta acción puede ser problemática debido a que el punto pivote por defecto se encuentra en su centro, así que al mover a (0,0,0)
  puede ocurrir algo como lo de la siguiente imagen donde el GameObject tiene la mitad debajo del punto (0,0,0).</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-07-47.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Desde el inspector situando el ratón encima de una de las coordenadas </p>
<p>cambia el icono y permite que al hacer clic y desplazar sin soltar el clic se cambie el valor</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-08-44.png" /><br><figcaption></figcaption></figure>
<br>
<p class="sub-section">Con las herramientas vistas anteriormente</p>
<p>Utilizando el ratón podemos modificar un GameObject.</p>

<p>Al seleccionarlas aparece un gizmo y al interactuar con él con el ratón se realizan las acciones requeridas.</p>

<p>Cada gizmo funciona de una manera diferente</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-09-56.png" /><br><figcaption></figcaption></figure>
<br>
<p>Movimiento solo en el eje X</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-10-56.png" /><br><figcaption></figcaption></figure>
<br>

<p>Movimiento en los ejes que no son Y (plano X, Z):</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-10-43.png" /><br><figcaption></figcaption></figure>
<br>
<p>Al usar las herramientas con los gizmos se puede utilizar el ajuste por <span class="negrita">snaps</span>.</p>

<p>Los pasos o snaps por defecto se pueden cambiar:</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-28-26.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para realizar las modificaciones por snaps al usar los gizmos se debe pulsar la tecla control.</p>

<p>Todas las modificaciones se realizan tomando como punto de referencia el punto pivote.</p>

<p>Se pueden realizar modificaciones cambiando el punto de referencia a un vértice de la malla del GameObject, para esto se debe pulsar la tecla v tras seleccionar la herramienta.</p>

<p>Se puede ver como al pulsar la tecla v, al mover el ratón sobre el GameObject el gizmo se sitúa en el vértice más cercano.</p>

<p>Esta acción se conoce como vertex snap y permite situar GameObjects a partir de uno de sus vértices en el vértice de otro Gameobject.</p>

<figure><img src="UD9/images/ud9-2024-01-26-09-29-17.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Unidades de medida</h3>
<p>Por defecto las unidades de medida usadas en Unity son:
  <ul>
<li><span class="negrita">Distancias</span>: metros.</li>
<li><span class="negrita">Tamaños</span>: metros.</li>
<li><span class="negrita">Peso (masa)</span>: kilogramos.</li>
<li><span class="negrita">Tiempo</span>: segundos.</li>
  </ul>
</p>

<p>Es importante tener esto en cuenta ya que el comportamiento de los GameObjects con las físicas va a depender de su tamaño y peso.</p>



</section><!-- End section Agregando GameObjects a la escena-->
<!--*********************************************************Materiales***********************************************************-->
<section class="apartado">
<a name="sMateriales"></a>
<h2>Materiales</h2>
<p>Los <span class="negrita">materiales</span> permiten dar aspecto a los GameObject.</p>

<p>Para crear un material se hace clic derecho en el gestor de archivos y se selecciona <span class="negrita">Create &rarr; Material</span>, 
  al crearlo permitirá asignarle un nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-32-28.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cabe recordar que para mantener la organización de archivos los materiales deben incluirse en una carpeta llamada <span class="inline-folder">Materials</span>
   dentro de la carpeta <span class="inline-folder">Assets</span>.</p>

   <p>Un material en el gestor de archivos se representa con una esfera y según la configuración que se le aplique en el inspector tendrá un aspecto u otro.</p>
   
<figure><img src="UD9/images/ud9-2024-01-26-09-33-59.png" /><br><figcaption></figcaption></figure>
<br>
<p>Con una buena configuración se puede conseguir que el material sea realista.</p>

<p>También se pueden conseguir materiales de la Unity Asset Store y de repositorios de internet.</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-53-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se puede aplicar un material a un GameObject de varias maneras:
  <ul>
<li>Arrastrar el material al GameObject en la jerarquía.</li>
<li>Arrastrar el material al GameObject en la visualización.</li>  
<li>Arrastrar el material al GameObject en el inspector en la zona "Add Component".</li>
</ul>
</p>

<figure><img src="UD9/images/ud9-2024-01-26-09-54-59.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Materiales Físicos</h3>
<p>Los materiales físicos (Physic Material) permiten controlar como van a interactuar físicamente los GameObject cuando colisionan entre sí.</p>

<p>Se suelen utilizar para permitir que los GameObject reboten o para que haya fricción entre ellos.</p>

<p>Para crear un material físico se hace clic con el botón derecho sobre el gestor de archivos y se elige la opción <span class="negrita">Create &rarr; Physic Material</span>.</p>

<p>Al crearse, se debe introducir su nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-05-23.png" /><br><figcaption></figcaption></figure>
<br>
<p>Los parámetros que se pueden configurar en un material físico son:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-05-53.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede aplicar un material físico a un GameObject de varias maneras:
  <ul>
    <li>Arrastrar el material al GameObject en la jerarquía.</li>
    <li>Arrastrar el material al GameObject en la visualización.</li>
    <li>Arrastrar el material al GameObject en el inspector en la zona "Add Component".</li>
</ul>
</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-06-48.png" /><br><figcaption></figcaption></figure>
 <br>
 <br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 3. Montando la escena</span> <br>
    Crea un proyecto 3D en Unity llamado <span class="subrayado">EscenaTuNombre</span>. <br>
Pon la cámara de visualización como si se fuera a desarrollar un juego en 2D (eje z hacia atrás). <br>
Añade a la escena un plano y modifica su tamaño para que tenga poca profundidad, pero sea muy ancho (como una pasarela en horizontal de izquierda a derecha). <br>
Añade a la escena un cubo, una esfera, una cápsula y un cilindro. Sitúalos en la escena como quieras, pero deben de estar en la misma coordenada Z que el plano. <br>
Solo uno debe estar tocando la superficie del plano. <br>
De los GameObject que no están tocando la superficie del plano debes colocar uno en la misma coordenada z que el que está tocando la superficie otro, 
la coordenada x debe estar un poco desplazada (tiene que seguir estando encima del otro) y la coordenada y debe ser más alta, en la parte superior de la escena. <br>
Crea 5 materiales con color y aspecto distinto y asigna cada uno a un GameObject. <br>

Sitúa la visualización en un ángulo diferente al de la cámara, puedes rotarla y moverla, pero tienen que aparecer el plano y todos los objetos.
<span class="oculto">Haz una captura de la ventana de visualización y ponle el nombre TuNombreUnity1.png </span>
<span class="oculto">Haz una captura de la ventana del juego en ejecución, ponle el nombre TuNombreUnity2.png.
  Comprime las dos capturas en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.</span>

  </p>
</div>

<br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 4. Eventos MonoBehaviour</span> <br>
    Abre el proyecto EscenaTuNombre. <br>
Crea un script llamado EventsScript y añádelo al GameObject que está en la superficie. <br>
En el script añade instrucciones para mostrar mensajes por consola con Debug.Log para los siguientes eventos:
 Start, Update, OnMouseEnter (el ratón se sitúa sobre el GameObject), OnMouseDrag (se clica sobre el GameObject y sin soltar se mueve el ratón). <br>
Los mensajes deben seguir el siguiente formato "TuNombre (NombreEvento): LoQueQuieras".  <br>
 <span class="oculto">
  Haz clic en el script en el gestor de archivos para que se vea en el inspector el código del script, a continuación, 
ejecuta el juego y haz una captura donde se visualice la consola y el inspector (recuerda activar la opción Collapse de la consola), 
ponle a la captura el nombre TuNombreUnity3.png. <br>
Comprime la captura en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.
 </span>


  </p>
</div>

<br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 5. Gravedad</span> <br>
    Abre el proyecto EscenaTuNombre. <br>
Uno de los GameObject de la escena se encuentra en la misma vertical que el que estaba tocando la superficie, 
pues a ese objeto que está en la parte superior de la escena añádele el componente RigidBody. <br>
Ejecuta el juego y observa qué ocurre. <br>
Cambia el peso de ese GameObject y vuelve a ejecutar el juego para observar qué ocurre. <br>
Cambia otras configuraciones del RigidBody y vuelve a ejecutar el juego para observar qué ocurre. <br>

<div class="oculto">Haz una captura de la ventana del juego en ejecución antes de que el cubo caiga, ponle el nombre TuNombreUnity4.png. <br>
  Haz una captura de la ventana del juego en ejecución cuando el cubo golpea al objeto que tiene debajo, ponle el nombre TuNombreUnity5.png. <br>
  Haz una captura de la ventana del juego en ejecución cuando el cubo deje de moverse, ponle el nombre TuNombreUnity6.png. <br>
  Comprime las dos capturas en un archivo rar o zip llamado TuNombre y adjunta ese archivo</div>

</div>

</section><!-- End section Materiales-->

<!--*********************************************************Componentes de GameObject***********************************************************-->
<section class="apartado">
<a name="sComponentes_de_GameObject"></a>
<h2>Componentes de GameObject</h2>
<p>Los GameObject pueden contener diferentes componentes.</p>

<p>Como mínimo todos los GameObject tienen_el compone_te Transform que sirve para indicar la posición, la rotación y el tamaño del GameObject</p>

<p>Los GameObject geométricos también tienen un Mesh y un Mesh Renderer para poder dibujarse.</p>

<p>Los GameObject que se visualizan en las cámaras tienen un Collider para detectar las colisiones.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-00-53.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se pueden añadir otros componentes a los GameObject desde el <span class="negrita">Menú &rarr; GameObject</span> o
  desde el inspector con el botón "<span class="negrita">Add Component</span>" que aparece en la parte inferior.</p>


<p>Usando el botón "Add Componen" aparece un buscador en el que se puede escribir el componente que se quiere.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-02-02.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cuando se desarrolla un videojuego suele ser necesario que algunos GameObjects estén <span class="negrita">afectados por las físicas</span>
   (gravedad, fuerzas…) para eso se necesita que los GameObject tengan un componente llamado <span class="r-word">RigidBody</span>.</p>

<p>En la configuración del <span class="r-word">RigidBody</span> se indica el peso del GameObject dentro de la escena entre otros parámetros.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-03-05.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Componentes de GameObject-->

<!--*********************************************************UI (User Interface)***********************************************************-->
<section class="apartado">
<a name="sUI"></a>
<h2>UI (User Interface)</h2>
<p>La interfaz de usuario (UI) son elementos que se añaden a la escena para dar información al usuario.</p>

<p>Con a la interfaz de usuario se pueden crear los menús y el HUD (Head-Up display).</p>

<p>La interfaz de usuario se puede crear tanto con GameObjects 2D como 3D pero habitualmente se utilizan GameObjects 2D.</p>

<p>Dentro de la interfaz de usuario pueden aparecer GameObjects como texto, imágenes, sliders, scrollbars, botones o campos de texto.</p>

<p>Los GameObjects de interfaz de usuario deben ser hijos de un GameObject de tipo <span class="negrita">Canvas</span>.</p>

<p>Cuando se añade a la escena un GameObject de interfaz de usuario, si no existe un <span class="negrita">Canvas</span> en la escena, 
  se creará para poder contener el GmaObject de la interfaz de usuario.</p>

  <figure><img src="UD9/images/ud9-2024-01-26-10-09-35.png" /><br><figcaption></figcaption></figure>

  <h3>UI - Texto</h3>
  <p>Existen dos GameObjects para añadir texto a la escena:
    <ul>
      <li><span class="negrita">Text</span>: texto primitivo con pocas opciones de configuración.</li>
      <li><span class="negrita">TextMeshPro</span>: texto avanzado con muchas opciones de configuración.</li>
    </ul>
  </p>

<p>Existen otros GameObject de tipo MeshPro que mejoran a los tipos primitivos.</p>

<p>Se recomienda el uso de los MeshPro siempre que estén disponibles.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-11-13.png" /><br><figcaption></figcaption></figure>
<br>
<p>Cuando se añade un <span class="negrita">TextMeshPro</span> por primera vez al proyecto aparecerá una ventana indicando que se necesita importar todos los paquetes 
  necesarios, se debe pulsar en el botón "<span class="cursiva">Import TMP Essentials</span>".</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-12-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>También indica que se pueden importar paquetes de ejemplos y extras.</p>

<p>Para visualizar correctamente los elementos del <span class="negrita">Canvas</span> en la pantalla hay que realizar 
  desde el inspector algunos cambios en la configuración.</p>

<p>Se debe seleccionar como "<span class="negrita">Render Mode</span>" la opción "<span class="negrita">Screen Space - Camera</span>" 
  y posteriormente arrastrar desde la jerarquía la cámara a la casilla "<span class="negrita">Render Camera</span>"</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-14-41.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-15-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>UI - Imágenes</h3>
<p>Para añadir imágenes a la interfaz de usuario se necesita que las imágenes sean <span class="d-word">sprites</span>.</p>

<p>Los sprites son imágenes de mapa de bits que contienen una unidad mínima de información como puede ser la imagen de un botón o la imagen de un personaje.</p>

<p>Una imagen puede contener uno o más sprites.</p>

<p>Cada sprite se pueden añadir a la escena directamente de manera independiente convirtiéndose en un GameObject.</p>

<p>Si una imagen contiene varios sprites se optimiza la carga de las imágenes en el juego.</p>

<p>Los sprites pueden usarse para formar un personaje completo y poder animar cada uno de los sprite de manera independiente.</p>

<p>También pueden usarse para formar la animación de un personaje o un objeto al moverse haciendo que un GameObject vaya cambiando de sprite.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-28-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una imagen con varios sprites también sirve para contener los diferentes elementos del mundo o de la interfaz de usuario.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-29-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>El primer paso para poder añadir sprites al proyecto Unity es añadir el paquete 2D Sprite desde el <span class="negrita">Menú &rarr; Window &rarr; Package Manager</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-30-33.png" /><br><figcaption></figcaption></figure>
<br>

<p>De esta manera se instala la herramienta <span class="negrita">Unity Sprite Editor</span>.</p>

<p>El siguiente paso es arrastrar las imágenes al gestor de archivos a una carpeta llamada <span class="inline-folder">Sprites</span>.</p>

<p>Al seleccionar una imagen del gestor de archivos, en el inspector se puede indicar el tipo de textura que es.
  Para convertirla en un Sprite se debe elegir la opción <span class="negrita">Sprite (2D and UI)</span>.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-31-40.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al realizar esta acción estará disponible el botón <span class="negrita">Sprite Editor</span> y 
  al pulsarlo se abrirá el editor que permite crear el sprite a partir de la imagen.</p>

<p>Si la imagen solo contiene un Sprite al estar seleccionado el modo por defecto "<span class="cursiva">Single</span>" 
  solo con abrir el editor ya se habrá convertido la imagen en un Sprite.</p>

<p>Cuando una imagen se convierte en un Sprite en el gestor de archivos aparece una flecha sobre ella.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-32-54.png" /><br><figcaption></figcaption></figure>
<br>

<p>El editor de sprites permite modificar el sprite.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-33-21.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si una imagen contiene varios sprites, en el inspector la opción <span class="negrita">Sprite Mode</span> se debe marcar como <span class="negrita">Multiple</span>.</p>

<p>Es importante que el fondo de la imagen sea transparente para obtener mejores resultados con los sprites.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-34-18.png" /><br><figcaption></figcaption></figure>
<br>


<p>De esta manera el editor de sprite permite obtener varios sprites a partir de la imagen.</p>

<p>Desde el editor de sprites se pueden seleccionar a mano los diferentes sprites con el ratón, una vez seleccionado un sprite se debe poner un nombre para reconocerlo posteriormente:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-35-15.png" /><br><figcaption></figcaption></figure>
<br>
<p>Una vez creado el sprite, con la opción <span class="negrita">Trim</span> se recorta el sprite ajustándose al contenido de la imagen (el fondo debe ser transparente).</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-35-48.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede cambiar la manera de seleccionar el sprite si se quiere ajustar mejor a la imagen.</p>

<p>Con <span class="negrita">Outline Tolerance</span> se ajusta el contorno a la imagen, 
  con <span class="negrita">Generate</span> se genera el contorno y con <span class="negrita">Apply</span> se crea el sprite con ese contorno.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-37-14.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si los sprites se organizan en la imagen de una manera ordenada, 
  desde el editor en el desplegable <span class="negrita">Slice</span> se puede seleccionar la manera en la que se va a dividir la imagen para que 
  el editor cree automáticamente los sprites:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-37-42.png" /><br><figcaption></figcaption></figure>
<br>

<p><ul>
  <li><span class="negrita">Automatic</span>: el editor detecta los sprites según el contenido.</li>
  <li><span class="negrita">Grid By Cell Size</span>: en la imagen los sprites se encuentran organizados en forma de rejilla, con esta opción se debe indicar el tamaño de cada cuadro de la rejilla.</li>
  <li><span class="negrita">Grid By Cell Count</span>: en la imagen los sprites se encuentran organizados en forma de rejilla, con esta opción se debe indicar el número de filas y de columnas.</li>
</ul></p>

<p>Tras seleccionar la opción deseada se debe pulsar el botón Slice para generar todos los sprites</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-39-10.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-39-17.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-40-12.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si la imagen contiene los sprites de animación de un personaje, como en el ejemplo, 
  cuando se utilizan las opciones del botón <span class="negrita">Slice</span> se debe estudiar el contenido de la imagen para que el pivote sea correcto 
  y la animación funcione correctamente.</p>

<p>Lo más habitual en estos casos es que los sprites estén organizados en forma de rejilla y el pivote se sitúe en el centro, 
  aunque esto puede cambiar entre las diferentes hojas de sprites.</p>

<p>Una vez creados los sprites en el gestor de archivos al pulsar la flecha que aparece en la imagen se mostrarán todos los sprites creados junto con su nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-41-11.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una vez una imagen se ha convertido en uno o varios sprites, se puede arrastrar uno de los sprite a la jerarquía o a la visualización y se añadirá un GameObject que muestre ese sprite.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-52-04.png" /><br><figcaption></figcaption></figure>
<br>
<p>También se puede añadir un GameObject de tipo <span class="negrita">UI &rarr; Image</span> y añadirle el sprite arrastrándolo a la opción Source Image.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-52-56.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-53-10.png" /><br><figcaption></figcaption></figure>
<br>

</section><!-- End section UI (User Interface)-->

<!--*********************************************************Prefabs***********************************************************-->
<section class="apartado">
<a name="sPrefabs"></a>
<h2>Prefabs</h2>
<p>Un <span class="r-word">Prefab</span> es un GameObject con todas sus características 
  (tamaño, rotación, giro, material, texturas, físicas…) almacenado como un asset.</p>

<p>Al tener un GameObject guardado como un prefab este <span class="negrita">podrá ser instanciado desde un script</span>.</p>

<p>Un ejemplo típico de un prefab en un juego serían los objetos que dejan los enemigos cuando desaparecen tras ser golpeados.</p>

<p>Los prefab también son fáciles de exportar para poder ser usados en otros proyectos.</p>

<p>Para crear un prefab se debe arrastrar el objeto desde la jerarquía al gestor de archivos.</p>

<p>Para mantener una buena organización todos los prefab se situarán en una carpeta llamada <span class="inline-folder">Prefabs</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-55-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>En la jerarquía se indica que el GameObject proviene de un prefab mostrando su nombre en color azul.</p>

<p>En el gestor de archivos aparece una previsualización del prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-56-18.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al seleccionar el prefab en el inspector se pueden ver sus características y componentes.
</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-56-46.png" /><br><figcaption></figcaption></figure>
<br>
<p>Un GameObject en la jerarquía que proviene de un prefab se puede editar en la escena actual sin que esta edición afecte al prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-57-23.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para editar un prefab se debe hacer doble clic sobre él en el gestor de archivos.</p>

<p>Los cambios sobre el prefab se replicarán en todos los GameObject del proyecto que estén creados a partir del prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-57-56.png" /><br><figcaption></figcaption></figure>
<br>
<p>En una escena se pueden añadir todas las copias de un prefab que se necesiten.</p>

<p>Desde un script también se pueden añadir GameObjects que sean prefabs.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-58-35.png" /><br><figcaption></figcaption></figure>
<br>


<br>
<hr>
<br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 6. Imágenes y prefabs</span> <br>
Abre el proyecto <span class="subrayado">EscenaTuNombre</span>. <br>
Añade un GameObject del tipo Cube, crea un material nuevo para él y asígnaselo. <br>
Crea 5 copias de este último cubo y crea una figura juntándolos como quieras (puedes rotarlos y escalarlos). <br>
Crea un GameObject vacío y añádele los 6 cubos que forman la figura, ten cuidado con las coordenadas. <br>
Crea un Prefab con ese GameObject vacío. <br>
Añade a la escena un texto con tu nombre. <br>
Añade a la escena una foto tuya tipo carnet (actual). <br>

<div class="oculto">Haz una captura de toda la ventana de Unity en ejecución, se tiene que ver el Asset en el gestor de archivos y 
  en la ventana de visualización se tienen que ver todos los GameObject de la escena, ponle el nombre TuNombreUnity7.png. <br>
  Comprime la captura en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.</div>
</p>
  
</div>

</section><!-- End section Prefabs-->

<!--*********************************************************La Clase GameObject***********************************************************-->
<section class="apartado">
<a name="sLa_Clase_GameObject"></a>
<h2>La Clase GameObject</h2>
<h3>Acceso a las propiedades del GameObject</h3>
<p>Desde un script añadido a un GameObject se puede acceder a las propiedades del propio GameObject y a todos los componentes que se añadan al GameObject.</p>

<p>Para acceder a toda esta información se utiliza la variable <span class="r-word">gameObject</span> 
  que <span class="negrita">se inyecta directamente</span> al heredar de la clase <span class="r-word">MonoBehaviour</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-10-56-27.png" /><br><figcaption></figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-01-29-10-56-54.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-10-57-11.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-10-57-50.png" /><br><figcaption>Cambiando la propiedad nombre por código</figcaption></figure>
<br>

<p>Todos los GameObject tienen al menos un componente <span class="negrita">Transform</span> que sirve para <span class="negrita">indicar la posición, 
  la rotación y el tamaño del GameObject</span>.</p>

<p>Como es un componente presente <span class="subrayado">en todos</span> los GameObject, 
  Unity inyecta directamente la propiedad <span class="negrita">transform que se puede usar directamente</span> o 
  desde la propiedad gameObject para poder utilizarlo directamente.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-00-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para acceder a un componente <span class="negrita">diferente a Transform</span>, 
  se debe crear una propiedad para poder almacenar ese componente en ella mediante el método <span class="negrita">GetComponent</span> y poder acceder.</p>

<p>Por ejemplo, para acceder al componente <span class="negrita">Collider</span>:</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-01-57.png" /><br><figcaption>Al ejecutar se desactiva el collider</figcaption></figure>
<br>
<h3>Acceso a otros GameObjects</h3>
<p>Para acceder desde un script a otros GameObjects <span class="negrita">se debe <span class="negrita">declarar una propiedad de tipo GameObject</span></span>
  y posteriormente <span class="negrita">asignarle el GameObject que se quiera</span>. (Sphere<span class="negrita">GO</span>  &rarr; <span class="negrita">G</span>ame<span class="negrita">O</span>bject).</p>

  <figure><img src="UD9/images/ud9-2024-01-29-11-03-58.png" /><br><figcaption></figcaption></figure>
  <br>

<p>Hay varias opciones para asignar el GameObject a la propiedad.
  <ul>
    <li>Si la propiedad es <span class="negrita">pública</span> se puede <span class="negrita">arrastrar</span> el GameObject desde la jerarquía a la variable en el Inspector.
      <figure><img src="UD9/images/ud9-2024-01-29-11-06-10.png" /><br><figcaption></figcaption></figure>     
    </li>
    <li>Desde el propio script con el método <span class="negrita">Find</span> de la clase <span class="negrita">GameObject</span>
       para buscar por el <span class="negrita">nombre</span> (en estos casos la propiedad suele ser privada).
       <figure><img src="UD9/images/ud9-2024-01-29-11-07-41.png" /><br><figcaption>Al ejecutar se buscan los GameObjects con esa etiqueta y se rellena el array</figcaption></figure>
    </li>
    <li><span class="negrita">Asignar etiquetas</span> a los GameObject y 
      desde el propio script con el método <span class="r-word">FindGameObjectsWithTag</span> de la clase <span class="negrita">GameObject</span>
       para buscar por <span class="negrita">etiqueta</span>.
       <figure><img src="UD9/images/ud9-2024-01-29-11-09-22.png" /><br><figcaption></figcaption></figure>
       <br>
       <p>En este caso la variable se debe declarar como array porque pude haber más de un GameObject con esa etiqueta (en estos casos la propiedad suele ser privada).</p>
       <figure><img src="UD9/images/ud9-2024-01-29-11-11-20.png" /><br><figcaption></figcaption></figure>  
       <br>    
       
       <figure><img src="UD9/images/ud9-2024-01-29-11-12-54.png" /><br><figcaption>Al ejecutar se buscan los GameObjects con esa etiqueta y se rellena el array.
</figcaption></figure>
       <br>
       
      </li>
  </ul>
</p>

<p>Al acceder a otros GameObjects se puede acceder a sus propiedades, por ejemplo, 
  el siguiente script añadido a la MainCamera, accedería a la propiedad <span class="negrita">Text</span> de un GameObject de tipo TextMeshPro y modificaría su valor.</p>

<p>Para poder acceder al GameObject se deberá arrastrar dicho GameObject a la casilla correspondiente del Inspector al seleccionar la MainCamera.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-14-25.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Acceso a componentes de otros GameObjects</h3>
<p>Una vez se tiene la referencia a un GameObject con cualquiera de las técnicas vistas anteriormente, 
  se puede acceder a los componentes de dicho GameObject con el método <span class="negrita">GetComponent</span>
   igual que se accede a los componentes del propio GameObject .</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-15-43.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si la propiedad para acceder al componente se declara pública <span class="negrita">al arrastrar el GameObject</span>
   a la casilla en el Inspector <span class="negrita">se asignará directamente el tipo de componente especificado</span> al declarar la propiedad.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-16-38.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede acceder a los scripts de otros GameObjetcs a partir del GameObject al que se quiere acceder y al <span class="negrita">nombre del script</span>.</p>

<p>Se puede utilizar cualquier técnica de las vistas anteriormente para obtener la referencia al otro GameObject.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-18-28.png" /><br><figcaption></figcaption></figure>
<br>
</section><!-- End section La Clase GameObject-->

<!--*********************************************************El componente Transform***********************************************************-->
<section class="apartado">
<a name="sEl_componente_Transform"></a>
<h2>El componente Transform</h2>
<p>El componente <span class="r-word">Transform</span> se estructura en tres elementos:
  <ul>
    <li><span class="negrita">Posición</span></li>
    <li><span class="negrita">Rotación</span></li>
    <li><span class="negrita">Escala</span></li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-20-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para cada elemento se especifica un valor por cada coordenada que se puede consultar como se ha visto anteriormente.</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-20-54.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para modificar la <span class="negrita">posición</span>, la <span class="negrita">rotación</span> y la <span class="negrita">escala</span>
   se usan objetos de la clase <span class="r-word">Vector3</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-22-06.png" /><br><figcaption></figcaption></figure>
<br>

<p>El código de la imagen representa las coordenadas: x=3, y=8, z=1.</p>

<p>Los parámetros que admite son números decimales (float) aunque se puede indicar con enteros.</p>

<p>Si se indica un número decimal se debe añadir al final la letra f:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-22-20.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Cambiar posición de un GameObject</h3>

<p>Para <span class="negrita">cambiar la posición</span> de un GameObject:
<ul>
  <li>
    Indicar <span class="negrita">un nuevo Vector3</span> para la propiedad <span class="negrita">position</span> de su <span class="negrita">Transform</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-23-18.png" /><br><figcaption></figcaption></figure>
  </li>
  <li>
    Operar la propiedad <span class="negrita">position</span> del <span class="negrita">Transform</span> con un <span class="negrita">Vector3</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-24-03.png" /><br><figcaption></figcaption></figure>
  </li>
  <li>
    Usar el método <span class="r-word">Translate</span> sobre el <span class="negrita">Transform</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-24-40.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Con <span class="r-word">Translate</span> se puede indicar si se usará como referencia el transform propio (valor por defecto) 
      o el punto central del espacio de coordenadas (0, 0, 0):</p>
    <figure><img src="UD9/images/ud9-2024-01-29-11-25-39.png" /><br><figcaption></figcaption></figure>
    <br>
    
  </li>
</ul>
</p>

<p>Además, la clase <span class="r-word">Vector3</span> dispone de algunas propiedades que devuelven objetos Vector3 a una unidad en las coordenadas:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-26-32.png" /><br><figcaption></figcaption></figure>
<br>
<p>En la documentación se puede consultar todo lo disponible:
<a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Vector3.html">https://docs.unity3d.com/ScriptReference/Vector3.html</a>
</p>

<p>Los objetos de la clase <span class="r-word">Vector3</span> se pueden operar:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-27-08.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Rotar un GameObject</h3>
<p class="sub-section">Sobre sí mismo</p>

<p>Indicar un <span class="negrita">nuevo Vector3</span> para la propiedad <span class="negrita">rotation</span> de su <span class="negrita">Transform</span>
   usando el método <span class="negrita">Euler</span> de la clase <span class="negrita">Quaternion</span>:</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-29-15.png" /><br><figcaption></figcaption></figure>
<br>

<p>Usar la propiedad <span class="negrita">eulerAngles</span> (comportamiento similar al método anterior):</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-30-49.png" /><br><figcaption></figcaption></figure>
<br>

<p>Usar el método <span class="negrita">Rotate</span> sobre el <span class="negrita">Transform</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-30-56.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con <span class="negrita">Rotate</span> se puede indicar si se usará como referencia el transform propio (valor por defecto)
   o el punto central del espacio de coordenadas (0, 0, 0).</p>

<p class="sub-section">Girar alrededor de otro</p>

<p>Con el Método <span class="r-word">RotateAround(origen, eje, velocidad)</span> se puede hacer que un GameObject gire alrededor de otro:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-32-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con el método <span class="r-word">LookAt(transformOtherGameObject)</span> se puede hacer que un GameObject mire siempre hacia otro GameObject:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-33-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Estas dos técnicas deben usarse dentro del método Update del script.</p>

<h3>Escalar un GameObject</h3>
<p>Para <span class="negrita">escalar</span> un GameObject solo tiene sentido el escalarlo respecto a su punto pivote.</p>
<p>Por esta razón se utiliza la propiedad <span class="r-word">localScale</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-34-06.png" /><br><figcaption></figcaption></figure>
<br>

<h3>El componente Transform en la jerarquía</h3>
<p>Cuando se tienen GameObjects agrupados, el componente Transform permite acceder a todos los Transform y GameObjects de la agrupación</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-35-02.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-11-35-14.png" /><br><figcaption></figcaption></figure>
<br>
<p>El orden de acceso a los GameObject hijos es el mismo que el orden en el que se encuentren en la jerarquía.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-38-33.png" /><br><figcaption></figcaption></figure>
<br>
<p>Desde un GameObject agrupado también se puede acceder a su padre.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-39-18.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Movimiento desde los métodos Update y FixedUpdate</h3>
<p class="sub-section">Método Update</p>

<p>El método <span class="r-word">Update</span> se ejecuta una vez por cada frame generado.</p>

<p>Cuando se aplica una modificación del componente transform de un GameObject en el método Update <span class="negrita">se produce un movimiento</span>, por ejemplo: 
  añadir 0,01 unidad a la posición x en cada Update.</p>

  <figure><img src="UD9/images/ud9-2024-01-29-11-40-35.png" /><br><figcaption>Moviendo el GameObject</figcaption></figure>
  <br>
  
  <p>El problema de usar el método <span class="negrita">Update</span> es que la cantidad de FPS que se generar depende de muchísimos factores, 
    desde la capacidad del equipo donde se ejecuta el juego hasta la cantidad de elementos que se muestran en un momento determinado.</p>
  <figure><img src="UD9/images/ud9-2024-01-29-11-41-57.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Por esta razón, no es buena idea realizar movimientos directamente de esta manera.</p>
  
  <p>Existen dos formas para solucionar este problema:
    <ul>
      <li>La clase <span class="r-word">Time</span> y su método <span class="r-word">deltaTime</span>. <br>
Si se multiplica un movimiento por <span class="negrita">Time.deltaTime</span> se consigue que el movimiento sea constante independientemente de la cantidad de frames
de cada momento.
<span class="negrita">Time.deltaTime</span> devuelve el valor 0,02 (que corresponde a 20 milisegundos).
(Técnica usada hasta la creación del método siguiente).</li>
<li>El método <span class="r-word">FixedUpdate</span> de la clase <span class="negrita">MonoBehaviour</span>.
	Se ejecuta en intervalos regulares de tiempo de 20 ms (50 veces/segundo).</li>
    </ul>
  </p>
  
<p>Además, es habitual crear una propiedad de tipo float llamada <span class="negrita">speed</span> para usarla como multiplicador y controlar la velocidad.</p>

<p>Mover un objeto en el eje x dependiendo del valor de la propiedad speed desde el método <span class="negrita">Update</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-44-47.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Método FixedUpdate</p>
<p>Por defecto el método <span class="negrita">FixedUpdate</span> se ejecuta cada 20 ms, 
  pero este comportamiento se puede cambiar desde <span class="negrita">Menú &rarr; Edit &rarr; Project Settings</span>… en la sección <span class="negrita">Time</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-45-47.png" /><br><figcaption></figcaption></figure>
<br>

<p>Mover un objeto en el eje x dependiendo del valor de la propiedad <span class="negrita">speed</span> desde el método <span class="r-word">FixedUpdate</span></p>
<figure><img src="UD9/images/ud9-2024-01-29-11-46-19.png" /><br><figcaption></figcaption></figure>
<br>
<p>Con los dos métodos, Update y Fixedupdate se puede conseguir el mismo resultado si se acaba multiplicando por el mismo valor.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-47-06.png" /><br><figcaption>speed*Time.deltaTime</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-11-47-21.png" /><br><figcaption>speed</figcaption></figure>
<br>
<p>La ventaja de FixedUpdate es que se puede configurar desde los ajustes del proyecto.</p>

</section><!-- End section El componente Transform-->

<!--*********************************************************La clase Input***********************************************************-->
<section class="apartado">
<a name="sLa_clase_Input"></a>
<h2>La clase Input</h2>
<p>Mediante la clase <span class="r-word">Input</span> se pueden capturar <span class="negrita">los eventos de entrada</span>
   del dispositivo del usuario (teclado, ratón, gamepad…).</p>

<p>La <span class="negrita">clase Input permite unificar</span> en un único punto todos los dispositivos de entrada disponibles.</p>

<p>Unity ofrece una herramienta donde poder configurar los dispositivos de entrada.</p>

<p>En muchos juegos también se permite cambiar esa configuración para que el usuario tenga una experiencia personalizada.</p>

<p>Desde el <span class="negrita">Menu &rarr; Edit &rarr; Project Settings…</span>
   se abre la configuración del proyecto, allí en la opción <span class="negrita">Input Manager</span> se puede visualizar y
    configurar los <span class="negrita">dispositivos de entrada</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-29-19-19-18.png" /><br><figcaption></figcaption></figure>
<br>
<p>La clase <span class="r-word">MonoBehaviour</span> ofrece algunos métodos que permiten ejecutar código cuando se producen eventos de ratón:
<ul>
  <li><span class="negrita">OnMouseDown</span></li>
  <li><span class="negrita">OnMouseDrag</span></li>
  <li><span class="negrita">OnMouseEnter</span></li>
  <li><span class="negrita">OnMouseExit</span></li>
  <li><span class="negrita">OnMouseOver</span></li>
  <li><span class="negrita">OnMouseUp</span></li>
  <li><span class="negrita">OnMouseUpAsButton</span></li>
</ul>
</p>
<p>La <span class="negrita"> clase Input</span> tiene una serie de métodos que devuelven un valor booleano cuando se produce la interacción del usuario con una <span class="negrita">tecla</span>, 
  <span class="negrita">un botón del ratón</span> o un <span class="negrita">botón virtual</span> como "<span class="cursiva">Fire1</span>".</p>

<p>Estos métodos se suelen utilizar dentro del método Update del script debido a que se ejecuta muchas más veces que otros métodos.</p>
<figure><img src="UD9/images/ud9-2024-01-29-19-21-12.png" /><br><figcaption></figcaption></figure>
<br>
<p>
  <ul>
    <li>Input.GetKeyDown(KeyCode.E)
Input.GetKey(KeyCode.V)
Input.GetKeyUp(KeyCode.Space)
Input.GetMouseButtonDown(0)
Input.GetMouseButton(1)
Input.GetMouseButtonUp(2)
Input.GetMouseButtonUp("Fire1")
Input.GetMouseButton("Jump")
</li>
  </ul>
</p>

<p>Todos los métodos en la  <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Input.html">documentación</a></p>

<p>La <span class="negrita">clase Input</span> tiene una serie de métodos para capturar los valores de los ejes de movimiento.</p>

<p>Estos métodos devuelven un valor decimal float que cuando el eje está en reposo el valor es 0 y cuando se pulsan devuelven un entre -1 y 1 dependiendo de la aceleración (tiempo de pulsación de la tecla o rango de movimiento del joystick).</p>
<p>Existen los ejes:
  <ul>
    <li>Horizontal y Vertical: w, a, s, d, flechas, joystick, cruceta.
      <ul>
          <li>Input.GetAxis("Horizontal")</li>
          <li>Input.GetAxis("Vertical")</li>
      </ul>
    </li>
    <li>Mouse X y Mouse Y: asignados al movimiento del ratón.
      <ul>
<li>Input.GetAxis("Mouse X")</li>
<li>Input.GetAxis("Mouse Y")</li>
      </ul>
    </li>
  </ul>
</p>


<h3>Movimiento mediante la clase Input</h3>
<p>Gracias a la <span class="negrita">clase Input se pueden mover GameObjects</span> cuando el usuario interactúe con los <span class="negrita">dispositivos de entrada</span>.</p>

<p>En el código, teniendo la cámara con la orientación que se indica con el gizmo:
  <ul>
    <li>flecha arriba o w	 &rarr;	<span class="negrita">mover</span> hacia adelante (se aleja de la cámara).</li>
    <li>flecha abajo o s	 &rarr;	<span class="negrita">mover</span> hacia atrás ( se acerca a la cámara).</li>
    <li>flecha izquierda o a &rarr;	<span class="negrita">mover</span> hacia izquierda.</li>
    <li>flecha derecha o d &rarr;	<span class="negrita">mover</span> hacia derecha.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-12-50-54.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-31-12-51-05.png" /><br><figcaption></figcaption></figure>
<br>
<p><ul>
  <li>flecha arriba o w		&rarr;	<span class="negrita">mover</span> hacia adelante.</li>
	<li>flecha abajo o s		&rarr;	<span class="negrita">mover</span> hacia atrás.</li>
	<li>flecha izquierda o a	&rarr;	<span class="negrita">rotar</span> hacia izquierda.</li>
	<li>flecha derecha o d	&rarr;	<span class="negrita">rotar</span> hacia derecha</li>
</ul></p>

<figure><img src="UD9/images/ud9-2024-01-31-12-55-05.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con cualquiera de los dos códigos anteriores, si se sitúa la cámara detrás del GameObject, en la misma orientación x y se añade la cámara como hija del GameObject, 
  la cámara seguirá al GameObject mientras se mueva.</p>

<figure><img src="UD9/images/ud9-2024-01-31-12-55-32.png" /><br><figcaption></figcaption></figure>
<br>
<br>
<hr>
<br>
<div class="tarea">
  <p>
    <span class="subrayado negrita">Actividad 7.  Modificando GameObjects mediante Inputs</span> <br>
Crea un proyecto 3D en Unity llamado <span class="subrayado">InputsTuNombre</span>. <br>
Pon la cámara de visualización como si se fuera a desarrollar un juego en 2D (eje z hacia atrás). <br>
Añade a la escena un plano y modifica su tamaño para que sea de 15x15x15 y esté en las coordenadas (0, 0, 0). <br>
Añade un GameObject del tipo Capsule y sitúalo en las coordenadas (0, 1, 0). <br>
Añade un GameObject del tipo Cube y sitúalo en las coordenadas (3, 0.5, 0). <br>
Añade un GameObject del tipo Sphere y sitúalo en las coordenadas (6, 0.5, 0). <br>
Crea un material de color naranja y asígnaselo al GameObject Capsule. <br>
Crea un material de color azul y asígnaselo al cubo. <br>
Crea un material de color verde y asígnaselo a la esfera <br>
Duplica el cubo y muévelos por el plano (puedes hacer unas 20  copias). <br>
Crea un script para la cápsula y añade en él el código necesario para realizar las siguientes acciones:
<ul>
  <li>Al pulsar los ejes Horizontal y vertical la cápsula debe moverse por el plano.</li>
  <li>Al pulsar la tecla E la esfera debe escalarse en todos sus ejes creciendo 0.5.</li>
  <li>Al pulsar la tecla Q la esfera debe escalarse en todos sus ejes decreciendo -0.5. Debes comprobar que la esfera nunca sea más pequeña que 0.5.</li>
</ul>
 <br>
Crea un script para la cámara y añádele el código para que siempre esté mirando hacia la cápsula

  </p>
</div>

</section><!-- End section La clase Input-->
<!--*********************************************************Movimiento cinemático y movimiento físico***********************************************************-->
<section class="apartado">
<a name="sMovimiento_cinematico_y_movimiento_fisico"></a>
<h2>Movimiento cinemático y movimiento físico</h2>
<p>Tipos de movimientos en Unity:
  <ul>
    <li><span class="negrita">Cinemático</span>:
      <ul>
        <li>Movimiento que se realiza directamente sobre el componente transform del GameObject.</li>
        <li>Estos movimientos son independientes de las físicas del juego (gravedad, aceleración, impulsos, inercias, rozamiento…).</li>
      </ul>
    </li>
    <li><span class="negrita">Físico</span>:
      <ul>
        <li>Movimientos que se realizan usando el motor físico del juego.</li>
        <li>El GameObject debe tener el componente <span class="negrita">Rigidbody</span>.</li>
      </ul>
    </li>
  </ul>
</p>

<p>Al añadir el componente <span class="r-word">Rigidbody</span> a un GameObject en el inspector se puede ver su configuración.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-00-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Propiedades de <span class="negrita">Rigidbody</span>:
<ul>
    <li><span class="negrita">Mass</span>: peso del objeto en kilogramos.</li>
  <li><span class="negrita">Drag</span>: resistencia al movimiento lineal.</li>
  <li><span class="negrita">Angular Drag</span>: resistencia a las rotaciones.</li>
  <li><span class="negrita">Use Gravity</span>: indica si le afecta o no la gravedad.</li>
  <li><span class="negrita">Is Kinematic</span>: si se activa, el GameObject no se verá afectado por el motor físico.
    Se suele activar para detectar colisiones.	(solo se podrá manipular con su Transform).</li>
  <li><span class="negrita">Constraints</span>: permite bloquear coordenadas.</li>

</ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-02-08.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con los movimientos cinemáticos (sin físicas) cuando se mueve un GameObject lo que ocurre es que el GameObject se está <span class="negrita">transportando</span>
   a la nueva posición.</p>

<p>Cuando un GameObject tiene el componente <span class="negrita">Rigidbody</span> no es recomendable modificar su posición usando su 
  Transform ya que al transportarse a la nueva posición podría aparecer parcialmente dentro de otro objeto y generar una colisión indeseada.</p>

<p>Para mover un GameObject que tenga un Rigidbody se le deben <span class="negrita">aplicar fuerzas que empujen</span> al GameObject en alguna dirección.</p>

<p>Si las <span class="negrita">fuerzas se aplican sin interacción con el Input</span> se utiliza el método <span class="negrita">FixedUpdate</span>.</p>

<p>Si las <span class="negrita">fuerzas se aplican con interacción con el Input</span> se utiliza el método <span class="negrita">Update</span>.</p>

<h3>Movimiento Físico</h3>
<p>Ejemplo de movimiento físico:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-29-35.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con el código anterior se debe tener cuidado con los materiales físicos de los GameObjects 
  ya que la fricción puede hacer que el GameObject no se comporte como se desea.</p>

<p>El suelo ofrece rozamiento y al empujar al GameObject este vuelca hacia adelante.</p>

<p>Además, por la fricción, al aplicar las fuerzas el GameObject tarda un tiempo en realizar el movimiento y al parar de aplicar fuerzas el GameObject va frenándose.</p>

<figure><img src="UD9/images/ud9-2024-01-31-13-30-46.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para solucionar estos problemas se puede optar una de las siguientes opciones:
  <ul>
    <li>Crear <span class="negrita">Materiales físicos</span> para ofrecer más realismo. 
      Estos materiales físicos se deben configurar correctamente y se deben de asignar a los GameObject que afecten al movimiento como son superficies o personaje.</li>
    <li>Añadir <span class="negrita">restricciones</span> al componente Rigidbody para bloquear la posición y/o rotación en alguno de los 3 ejes.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-32-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>Como se ha visto para aplicar fuerzas se necesita una propiedad el tipo Rigidbody en el código.</p>

<p>Algunos de los métodos que se pueden utilizar son:
  <ul>
    <li><span class="negrita">AddForce</span>: aplica fuerzas de empuje en las coordenadas del mundo.</li>
    <li><span class="negrita">AddTorque</span>: aplica fuerzas de giro en las coordenadas del mundo.</li>
    <li><span class="negrita">AddRelaviteForce</span>: aplica fuerzas de empuje en las coordenadas locales.</li>
    <li><span class="negrita">AddRelaviteTorque</span>: aplica fuerzas de giro en las coordenadas locales.</li>
    <li><span class="negrita">AddForceAtPosition</span>: aplica fuerzas de empuje en una posición determinada.</li>
    <li><span class="negrita">AddExplosionForce</span>: se utiliza para simular explosiones.</li>
  </ul>
</p>

<p>Estos métodos tienen una versión que además de recibir un Vector3 también se les puede indicar el tipo de fuerza a aplicar con las siguientes propiedades:
  <ul>
    <li><span class="negrita">ForceMode.Force</span>: en función del objeto. fuerza = masa * aceleración.</li>
    <li><span class="negrita">ForceMode.Acceleration</span>: aceleración ignorando la masa del GameObject.</li>
    <li><span class="negrita">ForceMode.Impulse</span>: aplica la fuerza de manera instantánea en un frame (se usa en Update).</li>
    <li><span class="negrita">ForceMode.VelocityChange</span>: aplica directamente una velocidad.</li>
  </ul>
</p>

<p>Usando solo movimientos físicos se puede mantener la inercia de los movimientos en cualquier eje.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-35-11.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Combinación de movimientos cinemáticos y físicos</h3>
<p>Aunque no es recomendable, se pueden mezclar los dos tipos de movimiento:
  <ul>
    <li><span class="negrita">Cinemático</span>: mover al personaje/enemigos por las superficies.</li>
    <li><span class="negrita">Físico</span>: aplicar fuerza hacia arriba para que el personaje salte.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-36-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>El problema con este código es que si se deja de mover el personaje en mitad de un salto, no mantendrá la inercia en el salto.</p>
 <br><br>
 <hr>
 <br>
 <div class="tarea">
  <p>
    <span class="subrayado negrita">Actividad 8. Rigidbody y seguimiento de cámara</span> <br>
    Abre el proyecto <span class="subrayado">InputsTuNombre</span>.
    Añade a la cápsula el componente Rigidbody. <br>
    Configura las restricciones del Rigidbody de la cápsula para que no vuelque al chocar. <br>
    A la hora de programar el movimiento de la cápsula había dos opciones, la que rotaba con las teclas a y d y la que no rotaba. 
    Si usaste la que no rotaba, cambia el código para usar la opción que sí que rota. <br>
    Añade a la esfera el componente Rigidbody. <br>
    Desactiva el script de la cámara. <br>
    Pon la visualización detrás de la cápsula como en la imagen (eje z apuntando al fondo). <br>
     <figure><img src="UD9/images/ud9-2024-02-01-10-37-56.png" /><br><figcaption></figcaption></figure>
     <br>
     
    Selecciona la cámara y selecciona la opción Menú &rarr; GameObject &rarr; Align With View. <br> <br>
    Haz que la cámara sea hija de la cápsula. <br> <br>
    Ejecuta el juego y mueve la cápsula para observar que la cámara ahora sigue a la cápsula y que la cápsula colisiona con el resto de GameObjects gracias al Rigidbody.
    
  </p>
 </div>


</section><!-- End section Movimiento cinemático y movimiento físico-->

<!--*********************************************************Colisiones***********************************************************-->
<section class="apartado">
<a name="sColisiones"></a>
<h2>Colisiones</h2>
<p>Para poder detectar las colisiones entre GameObjects, estos deben tener un componente <span class="r-word">Collider</span> 
  (suele estar presente en todos los GameObjects).</p>

<p>Unity ofrece dos mecanismos que permiten detectar las colisiones entre GameObjects:
  <ul>
    <li>Mediante <span class="negrita">Collider</span>.</li>
    <li>Mediante <span class="negrita">Trigger</span> (Collider marcado como is Trigger generalmente cuando son GameObjects sin representación gráfica en pantalla).</li>
  </ul>
</p>

<p>Lo más habitual es utilizar el nombre del GameObject o las etiquetas (<span class="negrita">Tag</span>) para detectar las colisiones.</p>

<h3>Colisiones con Collider</h3>
<p>Las <span class="negrita">colisiones mediante collider</span> se utilizan cuando un GameObject toca a otro.</p>

<p>Por ejemplo:
  <ul>
    <li>El jugador empuja a otro GameObject.</li>
    <li>Un GameObject impacta en otro GameObject como podría ser un disparo.</li>
    <li>…</li>
  </ul>
</p>

<p>Los collider pueden ser 3D o 2D, así, la clase MonoBehaviour ofrece métodos que se ejecutarán cuando se detecte una colisión entre colliders.</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter(Collision collision)</span>: se activa en el frame en el que inicia la colisión.</li>
    <li><span class="negrita">void OnCollisionStay(Collision collision)</span>: activo mientras la colisión se mantiene.</li>
    <li><span class="negrita">void OnCollisionExit(Collision collision)</span>: se activa en el frame que termina la colisión.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionStay2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionExit2D(Collision collision)</span></li>
  </ul>
</p>

<p>En los métodos se recibe un objeto del tipo Collisión a través del cual se podrá acceder a todo lo relacionado con la colisión y con el otro GameObject.</p>

<p>Al colisionar con otros GameObjects se pueden ejecutar acciones.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-40-49.png" /><br><figcaption></figcaption></figure>
<br>

<p>A través de la colisión se puede acceder a todos los elementos del GameObject contra el que se ha colisionado.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-41-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Colisiones con Trigger</h3>
<p>Las <span class="negrita">colisiones con trigger</span> se utilizan para determinar si un GameObject esta en una zona determinada</p>
<p>Por ejemplo:
  <ul>
    <li>Un GameObject tiene un collider más grande que su tamaño para poder detectar que el jugador está en el radio de acción 
      y cuando pulse una tecla lo pueda recoger (consumible) o utilizar (interruptor).</li>
    <li>Un GameObject vacío tiene un collider para detectar si el jugador está dentro de él.</li>
    <li>…</li>
  </ul>
</p>

<p>Para que un GameObject actúe como Trigger se debe marcar la opción <span class="negrita">Is Trigger</span> en el Inspector dentro del componente Collider.</p>

<p>En ocasiones los GameObject que actúan como Trigger solo tienen los componentes Transform y Collider porque no es necesario que se muestren en pantalla.</p>

<p>Si se configura un collider como Is Trigger los métodos que ofrece la clase MonoBehaviour son los siguientes:</p>


<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter(Collider other)</span>: se activa en el frame en el que inicia la colisión.</li>
    <li><span class="negrita">void OnTriggerStay(Collider other)</span>: activo mientras la colisión se mantiene.</li>
    <li><span class="negrita">void OnTriggerExit(Collider other)</span>: se activa en el frame que termina la colisión.</li>
  </ul>
</p>


<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerStay2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerExit2D(Collider other)</span></li>
  </ul>
</p>

<p>En esta ocasión el otro objeto se recibe en los métodos como objetos del tipo Collider que es el Collider del otro GameObject implicado.</p>
<p>En el GameObject que se mueve:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-44-02.png" /><br><figcaption></figcaption></figure>
<br>


<p>En el GameObject configurado como <span class="negrita">is Trigger</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-44-10.png" /><br><figcaption></figcaption></figure>
<br>

<p>En el siguiente ejemplo, un GameObject invisible con un Collider aplica una fuerza que hace flotar a otro GameObject que esté dentro de él, 
  siempre y cuando el otro GameObject tenga un componente Rigidbody:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-45-12.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Colisiones-->

<!--*********************************************************Métodos Intersantes***********************************************************-->
<section class="apartado">
<a name="sMetodos_Intersantes"></a>
<h2>Métodos Intersantes</h2>
<h3>Método Destroy</h3>
<p>El método <span class="r-word">Destroy</span> elimina al GameObject, si no se indica tiempo se eliminará inmediatamente, 
  si se indica tiempo se eliminará pasados esos segundos.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-47-43.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Método Instantiate</h3>
<p>El método <span class="r-word">Instantiate</span> permite crear GameObjects en tiempo de ejecución.</p>

<p>Ejemplos de uso:
  <ul>
    <li>Cuando el jugador dispara debe crearse el proyectil en ese punto y moverse en la dirección en la que apunta.</li>
    <li>En una zona del escenario aparece un enemigo en la parte superior que cae y al llegar abajo desaparece 
      (bucle con Instantiate, movimiento, detección por trigger al llegar abajo y Destroy).</li>
  </ul>
</p>

<p>Se crea un objeto cuando se pulsa el botón "<span class="cursiva">Fire1</span>" (botón izquierdo del ratón).</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-03.png" /><br><figcaption></figcaption></figure>
<br>
<p>Cuando el jugador toca al GameObject este se replica a si mismo 10 veces.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-19.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se crea un objeto cuando en intervalos de tiempo fijos sin tener que realizar ninguna acción.
Al GameObject creado se le aplica una fuerza al crearse y saldrá lanzado.
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-37.png" /><br><figcaption>GameObject generador</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-55.png" /><br><figcaption>GameObject generado</figcaption></figure>
<br>

<h3>Utilidades</h3>
<p>Mediante los métodos <span class="r-word">Invoke</span> e <span class="r-word">InvokeRepeating</span>
   se puede indicar el tiempo de espera antes de realizar la llamada a otro método.</p>


<figure><img src="UD9/images/ud9-2024-01-31-13-50-28.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se pueden cancelar las invocaciones a ctivas con el método <span class="r-word">CancelInvoke</span>.</p>
<p>Si no se le indica ningún parámetro cancelará todas las invocaciones, si se le pasa como parámetro el nombre de un método cancelará esa invocación.</p>

<figure><img src="UD9/images/ud9-2024-01-31-13-50-52.png" /><br><figcaption></figcaption></figure>
<br>

<p>Otra manera de realizar las tareas de <span class="r-word">InvokeRepeating</span> es con el uso de <span class="negrita">Corrutinas</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-51-28.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para cancelar corrutinas se utilizan los métodos <span class="negrita">StopAllCoroutines</span> y <span class="negrita">StopCoroutine("NombreMétodo")</span>.</p>


<br><br>
<hr>
<br>
<div class="tarea">
  <p><span class="subrayado negrita">Práctica 7 – Pachinko</span></p>
  
<p>Un Pachinko es una máquina recreativa de origen japonés en la que el jugador tiene una gran cantidad de bolas de acero que se introducen en la máquina recreativa. <br>
La máquina de pachinko tiene un sistema que lanza las bolas desde abajo por un lateral para que lleguen a la parte superior y desde ahí comiencen a bajar. <br>
En el tablero hay una serie de alfileres (pines) en los que las bolas metálicas rebotan y toman caminos de manera aleatoria. <br>
Además, en el tablero puede haber diferentes puertas por las que pueden entrar las bolas para así conseguir puntos con los que se consiguen premios, 
y en ocasiones, puertas que devuelven la bola al jugador para que vuelva a introducirla. <br>
Por último, las bolas que llegan a la parte inferior no otorgan premios. <br></p>


<p>A continuación, se pueden ver algunos ejemplos reales y en videojuegos.</p>
<figure><img src="UD9/images/ud9-2024-02-01-11-00-27.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-01-11-00-52.png" /><br><figcaption></figcaption></figure>
<br>


 	  	 
<p>Crea un proyecto 3D en Unity llamado <span class="subrayado">PachinkoTuNombre</span>. <br>
Instala en el proyecto el paquete de Unity que se <a class="enlace" target="_blank" href="./UD9/resources/pr-pachinko.unitypackage">adjunta</a> 
en la tarea de una de las siguientes maneras: 
<ul>
  <li>Al hacer doble clic en el archivo del paquete se abrirá la ventana de diálogo para incorporar todos los elementos del paquete. </li>
  <li>Al arrastrar el archivo del paquete se abrirá la ventana de diálogo para incorporar todos los elementos del paquete.</li>
</ul> <br>
</p>
<p>El paquete incluye además del tablero, una imagen con sprites y 
  una serie de materiales que puedes aplicar al tablero y a las bolas metálicas. <br> 

Todos los elementos del tablero incluyen un Collider para que las bolas no puedan traspasarlos, y además se incluye un Collider 
delante para que así las bolas no puedan salir despedidas hacia delante (quedando el hueco para las bolas metálicas).</p>
<figure><img src="UD9/images/ud9-2024-02-01-11-04-26.png" /><br><figcaption></figcaption></figure>
<br>

 <p>En el siguiente enlace puedes encontrar el mismo paquete que de materiales metálicos que se incluye con la tarea. 
Puedes usar alguno de esos materiales para las bolas metálicas. 
<a class="enlace" target="_blank" href="https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949">https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949</a></p>


<p>Primero deberás crear los siguientes prefabs (presta atención a la escala de los elementos para que no haya problema con las colisiones):
<ul>
  <li>Una bola metálica con físicas y colisiones.</li>
  <li>Un pin estático (puede ser un cilindro) con material metálico y con material físico para que reboten las bolas.</li>
  <li>Un pin giratorio (puede ser un cilindro con un cubo alargado, o con dos cubos alargados en forma de cruz o cualquier cosa que se te ocurra) 
    que no tendrá material que haga que rebote. En este pin cuando la bola choque con él, deberá girar el pin teniendo como eje su centro.</li>
   <figure><img src="UD9/images/ud9-2024-02-01-11-09-34.png" /><br><figcaption></figcaption></figure>
   <br>
   
  <li>Puerta en la que se ganan 5 puntos si la bola cae en ella.</li>
  <li>Puerta en la que se ganan 10 puntos si una bola cae en ella, debe ser algo más pequeña que la anterior.</li>
  <li>Puerta en la que se obtiene una bola extra.</li>
</ul></p>


<p>Los prefabs de las puertas deben tener los sprites incluidos para indicar al usuario qué ocurre al caer la bola en esas puertas.
En la escena debes añadir:
<li>En la parte superior central debe verse una foto tuya tipo carnet (actual), tu nombre la cantidad de puntos y la cantidad de bolas restantes.</li>
 <figure><img src="UD9/images/ud9-2024-02-01-11-12-11.png" /><br><figcaption></figcaption></figure>
 <br>
 
<li>Tantos pines estáticos y giratorios como quieras para que el juego se vea dinámico.</li>
<li>Dos puertas de 5 puntos.</li>
<li>Una puerta de 10 puntos.</li>
<li>Dos puertas de bola extra.</li></p>



<p><span class="subrayado">Mecánicas del juego:</span> 
<ul>
  <li>El juego empezará con 100 bolas y 0 puntos.</li>
  <li>Al pulsar la tecla flecha izquierda caerá una bola desde el hueco superior izquierdo y se restará una bola a la cantidad de bolas.</li>
  <li>Al pulsar la tecla flecha derecha caerá una bola desde el hueco superior derecho y se restará una bola a la cantidad de bolas.</li>
  <li>Cuando una bola cae en alguna puerta se deben sumar los puntos correspondientes o sumar una bola a la cantidad de bolas restantes.</li>
  <li>Cuando una bola cae en alguna puerta o por la parte inferior se debe destruir.</li>
  <li>En todo momento el HUD debe estar actualizado con los puntos actuales y la cantidad de bolas restantes.</li>
</ul></p>



<p>Los GameObjects en la escena deben tener nombres apropiados. <br>
Crea y asigna todas las etiquetas que veas que son necesarias. <br>
Crea los scripts necesarios y añádelos a los GameObjects o Prefabs para que el juego funcione correctamente.</p>


<p>
<span class="subrayado">Extras:</span>
<ul>
  <li>Cada vez que se cree una bola su material será uno aleatorio de entre todos los materiales de bolas metálicos incluidos en el paquete.</li>
  <li>Prefab de una puerta que premia al jugador con 50 bolas más. Debe ser una puerta que sea difícil que una bola caiga a ella. 
    Una vez creada la puerta añádela al tablero.</li>
  <li>Modificar el tablero para que sea como los pachinko originales en los que la bola se lanza desde abajo por el lateral hacia la parte superior del tablero. 
    En este caso las teclas de las flechas se sustituirán por la tecla espacio y al pulsarla se lanzará una bola. 
    Debes crear un mecanismo para que la fuerza de la bola pueda cambiar, por ejemplo, una rueda que gire con las teclas de las flechas e indique la potencia.</li>
</ul></p>



</div>

</section><!-- End section Métodos Intersantes-->

  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>