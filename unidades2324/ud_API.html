<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UDXX.- API's</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">
    <div class="fila">
      <a href="#sIntroduccion" title="1.- Introducción">1.- Introducción</a>
      <a href="#sArquitecturaorientadaaServicios" title="2. Arquitectura orientada a Servicios">2. Arquitectura orientada a Servicios</a>
      <a href="#sAPI_Rest" title="3.- API Rest">3.- API Rest</a>      
    </div>    
    <div class="fila">
      <a href="#sCoil" title="4.- Coil">4.- Coil</a>
      <a href="#sConexionainternet" title="5.- Conexión a Internet">5.- Conexión a Internet</a>
      <a href="#sHttpURLConnection" title="6.- HttpURLConnection">6.- HttpURLConnection</a>
    </div>
    <div class="fila">
      <a href="#sLibreriasparaconexionesHTTP" title="7.- Librerías para conexiones HTTP">7.- Librerías para conexiones HTTP</a>
      <a href="#sRetrofit" title="8.- Retrofit">8.- Retrofit</a>
      
    </div>
  </nav> <!-- BTM_MENU-->

  <h1>UDXX.- API's</h1>  

  <div class="main-menu">
    <div class="fila">
      <a href="#sIntroduccion" title="1.- Introducción">1.- Introducción</a>
      <a href="#sArquitecturaorientadaaServicios" title="2. Arquitectura orientada a Servicios">2. Arquitectura orientada a Servicios</a>
      <a href="#sAPI_Rest" title="3.- API Rest">3.- API Rest</a>
    </div>
  </div>
  
  <!--*********************************************************Introducción***********************************************************-->
  <section class="apartado">
  <a name="sIntroduccion"></a>
  <h2>Introducción</h2>
  <p>En la unidad anterior se estudió cómo almacenar y acceder a información en el propio dispositivo.</p>
  
  <p>En esta unidad se estudiarán las diferentes técnicas para el acceso a información disponible en internet a través de API Rest.</p>
  
  <p>De esta manera se verán las técnicas para poder obtener y enviar información de API's existentes y enviar información a API's exsitentes.</p>
  


</section><!-- End section Introducción-->

<!--*********************************************************Arquitectura orientada a Servicios***********************************************************-->
<section class="apartado">
<a name="sArquitecturaorientadaaServicios"></a>
<h2>Arquitectura orientada a Servicios</h2>

<h3><span class="negrita">Arquitectura orientada a servicios</span> &rarr; <span class="negrita">SOA (Service Oriented Architecture)</span></h3>

<p>Los <span class="negrita">servicios web</span> (web services) son un conjunto de protocolos y estándares que permiten que diferentes aplicaciones intercambien datos.</p>

<p>Una de las características principales es que estas aplicaciones pueden estar desarrolladas con diferentes lenguajes de programación 
  y pueden estar ejecutándose en plataformas diferentes.</p>

<p>Incluso pueden estar desarrolladas por entidades diferentes.</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-06-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cuando se utiliza una arquitectura orientada a servicios, el desarrollo de aplicaciones <span class="negrita">no se basa en generar aplicaciones completas</span>.</p>

<p>Con SOA se desarrollan servicios (aplicaciones) que <span class="negrita">generan resultados</span> y 
  estos servicios se pueden <span class="negrita">utilizar</span> tanto en la <span class="negrita">propia aplicación</span> como en <span class="negrita">aplicaciones de terceros</span>.</p>

<h3>Estándares usados en SOA</h3>
<p>Para la implementación de servicios se pueden utilizar diferentes tecnologías dependiendo de las características del servicio a desarrollar.
  Entre las más usadas se encuentran las siguientes:
<ul>
  <li><span class="negrita">HTML</span>: HyperText Markup Language</li>
  <li><span class="negrita">XML</span>: eXtensible Markup Language</li>
  <li><span class="negrita">JSON</span>: JavaScript Object Notation</li>
  <li><span class="negrita">SOAP</span>: Simple Object Access Protocol</li>
  <li><span class="negrita">WSDL</span>: Web Servides Description Language</li>
  <li><span class="negrita">REST</span>: Representational State Transfer</li>
</ul>
</p>

</section><!-- End section Arquitectura orientada a Servicios-->

<!--*********************************************************API Rest***********************************************************-->
<section class="apartado">
<a name="sAPI_Rest"></a>
<h2>API Rest</h2>

<h3>API (Application Programming Interface)</h3>

<p>Una <span class="negrita">API</span> es un <span class="negrita">conjunto de funcionalidades</span> ya desarrolladas 
  y preparadas para ser usadas dentro de otras tecnologías haciendo uso de los principios SOA.</p>

<p>Su finalidad es ofrecer una <span class="negrita">capa de abstracción</span> a la hora de realizar diferentes tareas 
  (cálculos, obtener/guardar datos…) de manera que se facilitan las tareas a los desarrolladores.</p>

<h3>REST</h3>
<p><span class="negrita">REST</span> → REpresentational State Transfer</p>
<p>Es una arquitectura que se basa en <span class="negrita">peticiones HTTP</span>
   para trabajar con los datos de la aplicación web (almacenados en la base de datos) mediante operaciones bien definidas:
<ul>
  <li><span class="negrita">GET</span>: obtener uno o varios registros de una tabla.</li>
  <li><span class="negrita">POST</span>: almacenar un registro nuevo en una tabla.</li>
  <li><span class="negrita">PUT</span>: cambiar todos los campos de un registro de una tabla.</li>
  <li><span class="negrita">PATCH</span>: cambiar algún campo de un registro de una tabla.</li>
  <li><span class="negrita">DELETE</span>: eliminar un registro de una tabla.</li>
</ul>
</p>

<h3>API Rest</h3>
<p><span class="negrita">API Rest</span> es una implementación de servicios web donde se utiliza principalmente las tecnologías 
  <span class="negrita">REST</span> y <span class="negrita">JSON</span> para el acceso a los datos.</p>

<p>Para desarrollar servicios web API REST se debe:
  <ul>
    <li>Definir las <span class="negrita">URL</span> (amigables) aceptadas por la API REST.</li>
    <li>Definir el <span class="negrita">tipo de petición</span> aceptado para cada URL.</li>
    <li>Crear los scripts que traten las peticiones a las URL que se definan y generen lo datos resultado.</li>
  </ul>
</p>

<p>A cada para "URL-tipo petición" se le conoce como <span class="negrita">endpoint</span>.</p>

<p>Actualmente muchas empresas ofrecen su API para la integración de sus datos y funcionalidades en cualquier aplicación.</p>


<figure><img src="UD9/images/ud9-2024-03-06-13-15-22.png" /><br><figcaption>Noticia de Febrero de 2023</figcaption></figure>
<br>
<p>Existen infinidad de API's públicas, algunas requieren de registro:
  <ul>
    <li><span class="negrita">Datos abiertos Valencia</span>: <a class="enlace" target="_blank" href="https://valencia.opendatasoft.com/pages/home/">https://valencia.opendatasoft.com/pages/home/</a></li>
    <li><span class="negrita">Rick y Morty</span>: <a class="enlace" target="_blank" href="https://rickandmortyapi.com/">https://rickandmortyapi.com/</a></li>
    <li><span class="negrita">Star Wars</span>: <a class="enlace" target="_blank" href="https://swapi.dev/">https://swapi.dev/</a></li>
    <li><span class="negrita">Disney</span>: <a class="enlace" target="_blank" href="https://disneyapi.dev/">https://disneyapi.dev/</a></li>
    <li>…</li>
  </ul>
</p>

<p>Listados con API's públicas:
  <ul>
    <li><a class="enlace" target="_blank" href="https://github.com/public-apis/public-apis">https://github.com/public-apis/public-apis</a></li>
    <li><a class="enlace" target="_blank" href="https://rapidapi.com/collection/list-of-free-apis">https://rapidapi.com/collection/list-of-free-apis</a></li>
  </ul>
</p>

<p>API's con datos ficticios para pruebas:
  <li><a class="enlace" target="_blank" href="https://httpbin.org">https://httpbin.org</a>: dispone de una gran variedad de peticiones disponibles.</li>
	<li><a class="enlace" target="_blank" href="https://app.mocklab.io">https://app.mocklab.io</a>: al crear una cuenta se puede configurar las peticiones al gusto.</li>
</p>

<p>Como se ha indicado anteriormente para hacer uso de una API es necesario conocer sus <span class="negrita">endpoints</span>.</p>

<p>A continuación, se muestra un endpoint junto con los datos JSON que genera:
  <a class="enlace" target="_blank" href="https://swapi.dev/api/starships/10/?format=json">https://swapi.dev/api/starships/10/?format=json</a></p>

<figure><img src="UD9/images/ud9-2024-03-06-13-19-12.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section API Rest-->

<!--*********************************************************Coil***********************************************************-->
<section class="apartado">
<a name="sCoil"></a>
<h2>Coil</h2>
<h3>Librería Coil</h3>

<p>En la UD4 se estudió el uso de la librería Coil para el acceso a imágenes ubicadas en internet.</p>

<p>La librería Coil necesita una URL de donde obtener la imagen, esta URL puede ser la ruta directa a una imagen 
  o bien un <span class="negrita">endpoint de una API</span> como en los ejemplos vistos:</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-21-06.png" /><br><figcaption></figcaption></figure>
<br>


</section><!-- End section Coil-->

<!--*********************************************************5.- Conexión a internet***********************************************************-->
<section class="apartado">
<a name="sConexionainternet"></a>
<h2>5.- Conexión a internet</h2>
<p>Es importante destacar que si la aplicación va a acceder a internet se deben dar permisos indicándolo en el archivo del manifiesto
   <span class="negrita">manifest</span> &rarr; <span class="inline-file">AndroidManifest.xml</span>
con la siguiente línea: </p>

<figure><img src="UD9/images/ud9-2024-03-06-13-23-27.png" /><br><figcaption></figcaption></figure>
<br>


</section><!-- End section 5.- Conexión a internet-->

<!--*********************************************************HttpURLConnection***********************************************************-->
<section class="apartado">
<a name="sHttpURLConnection"></a>
<h2>HttpURLConnection</h2>
<p>Android ofrece la clase <span class="negrita">HttpURLConnection</span> para realizar conexiones HTTP de manera manual.</p>

<p>Las conexiones con HttpURLConnection se deben de realizar en una corrutina fuera del hilo principal.</p>

<p>Se pueden realizar peticiones de cualquier tipo de los permitidos en el protocolo HTTP.</p>

<p>El siguiente código sirve para realizar una petición tipo GET en Jetpack Compose.</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-25-41.png" /><br><figcaption></figcaption></figure>
<figure><img src="UD9/images/ud9-2024-03-06-13-25-50.png" /><br><figcaption></figcaption></figure>
<br>
<p>Ejemplo de ejecución del código anterior:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-29-05.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-29-20.png" /><br><figcaption></figcaption></figure>
<br>

<p>En una aplicación real se deberán parsear los datos para mostrarlos de una manera entendible y atractiva para los usuarios.</p>




</section><!-- End section HttpURLConnection-->

<!--*********************************************************Librerías para conexiones HTTP***********************************************************-->
<section class="apartado">
<a name="sLibreriasparaconexionesHTTP"></a>
<h2>Librerías para conexiones HTTP</h2>

<p>Aunque anteriormente se ha visto como utilizar la clase HttpURLConnection para realizar conexiones HTTP desde Android, 
  también existen una serie de librerías para facilitar y agilizar estas acciones.</p>
  <p>Librerías Android:
    <ul>
      <li><span class="negrita">Retrofit</span> (Será el que veamos)</li>
      <li>Volley</li>
    </ul>
  </p>
  
  
  <p>Librerías Kotlin (disponibles en proyectos Android y Kotlin):
    <ul>
      <li>Ktor</li>
      <li>http4k</li>
    </ul>
  </p>
  

</section><!-- End section Librerías para conexiones HTTP-->

<!--*********************************************************Retrofit***********************************************************-->
<section class="apartado">
<a name="sRetrofit"></a>
<h2>Retrofit</h2>
<p>Retrofit es una librería de código abierto para Java y Android que permite simplificar la realización de peticiones HTTP y el procesamiento de los datos obtenidos.</p>
<p>Características:
  <ul>
    <li><span class="negrita">Seguridad de tipos</span>: se garantiza la seguridad al convertir automáticamente las respuestas JSON a objetos Java/Kotlin y en las peticiones lo objetos Java/Kotlin a JSON.</li>
    <li><span class="negrita">Código legible y mantenible</span>: gracias a anotaciones en interfaces se definen las peticiones HTTP simplificando su uso.</li>
    <li>Permite <span class="negrita">añadir parámetros, cabeceras y variables</span> a los endpoint.</li>
    <li>Permite manejar <span class="negrita">diferentes formatos de respuesta</span> además de JSON.</li>
  </ul>
</p>



En la  <a class="enlace" target="_blank" href="https://square.github.io/retrofit/">web oficial</a> se puede encontrar toda la información.

<h3>Caso de estudio</h3>
<p>Para estudiar el uso de la librería <span class="r-word">Retrofit</span> se va a realizar un caso de estudio que constará de una aplicación que realizará peticiones a una API pública.</p>

<p>Se utilizará la API <a class="enlace" target="_blank" href="https://rickandmortyapi.com">https://rickandmortyapi.com</a> para recuperar personajes de la serie.</p>

<p>El endpoint que se usará será el siguiente, sustituyendo el parámetro <span class="negrita">name</span> por el valor que introduzca el usuario:
  <br>
  <a class="enlace" target="_blank" href="https://rickandmortyapi.com/api/character/?name=rick">https://rickandmortyapi.com/api/character/?name=rick</a>
</p>
 	

<p>Esta API devuelve la información de los personajes encontrados en formato JSON.</p>

<p>Retrofit permitirá realizar la petición a la API y almacenar la información recibida en objetos fácilmente usables desde el código kotlin.</p>

<p>La aplicación contendrá un campo de búsqueda para introducir un nombre y un botón de buscar.</p>

<p>Con los datos obtenidos de la API se mostrarán por pantalla la información de los personajes encontrados.</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-37-09.png" /><br><figcaption></figcaption></figure>
<br>

<p>Evidentemente, el uso de Retrofit para obtener datos de una API puede ser para realizar tareas diferentes a las utilizadas en el caso de estudio.</p>

<p class="sub-section">Ejemplos de petición a la API y datos recibidos de esta:</p>

<p><a class="enlace" target="_blank" href="https://rickandmortyapi.com/api/character/?name=frank">https://rickandmortyapi.com/api/character/?name=frank</a></p>

<figure><img src="UD9/images/ud9-2024-03-06-13-38-02.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con el atributo image tenemos la url de la imagen</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-38-42.png" /><br><figcaption></figcaption></figure>
<br>


<p><a class="enlace" target="_blank" href="https://rickandmortyapi.com/api/character/?name=felipe">https://rickandmortyapi.com/api/character/?name=felipe</a></p>
<p>Si no lo encuentra nos devuelve el siguiente mensaje</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-38-56.png" /><br><figcaption></figcaption></figure>
<br>

<p>Tras crear un proyecto se debe:</p>

<p>Añadir en el <span class="inline-file">AndroidManifest.xml</span> el permiso a conexión a internet.</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-39-54.png" /><br><figcaption></figcaption></figure>
<br>

<p>Añadir la dependencia en <span class="inline-file">build.gradle.kts (Module)</span> y sincronizar.</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-40-22.png" /><br><figcaption></figcaption></figure>
<br>

<p>La respuesta de la API es en formato JSON, así que <span class="negrita">se debe analizar la estructura de dicho JSON</span>
   para crear los modelos de datos que se necesiten.</p>

<p>Para almacenar estos modelos se utilizarán <span class="negrita">Data class</span>.</p>

<p>Es conveniente crear la estructura de Data class dentro de una carpeta (package) que se puede llamar <span class="negrita">model</span>.</p>

<p>Para el ejemplo se podrían crear las siguientes Data class:
  <ul>
    <li><span class="negrita">Response</span>: para representar toda la respuesta.</li>
    <li><span class="negrita">Info</span>: para representar el elemento info de la respuesta.</li>
    <li><span class="negrita">Results</span>: para representar la información de cada personaje.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-42-31.png" /><br><figcaption>Estructura JSON respuesta</figcaption></figure>
<br>

<h3>Data class necesarias</h3>
<figure><img src="UD9/images/ud9-2024-03-06-13-43-18.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-43-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se puede observar que no es necesario utilizar todos los datos de la respuesta, Retrofit se encargará de seleccionar solo los necesarios</p>

<p>La tarea de crear las Data Class necesarias puede ser laboriosa por ello se puede usar el plugin <span class="negrita">JSON To Kotlin Class</span>
   para detectar automáticamente la estructura de datos la respuesta de una petición a una API.</p>

<p><span class="negrita">File &rarr; Settings…</span></p>
<figure><img src="UD9/images/ud9-2024-03-06-13-44-37.png" /><br><figcaption></figcaption></figure>
<br>

<p>Dentro de la carpeta <span class="negrita">model</span> haciendo clic con el botón derecho se selecciona la opción 
  <span class="negrita">New &rarr; Kotlin data class File from JSON</span>.</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-45-23.png" /><br><figcaption></figcaption></figure>
<br>

<p>En la ventana que se abre se debe copiar toda la respuesta del endpoint que se quiera.</p>

<p>Para el case de estudio se va a usar el endpoint de ejemplo:
<a class="enlace" target="_blank" href="https://rickandmortyapi.com/api/character/?name=Morty">https://rickandmortyapi.com/api/character/?name=Morty</a> </p>

<figure><img src="UD9/images/ud9-2024-03-06-13-46-04.png" /><br><figcaption></figcaption></figure>
<br>

<p>La estructura Data class generada es la siguiente:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-47-22.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si alguno de los datos de la respuesta no se va a utilizar se puede eliminar de la estructura de Data class creada.</p>

<p>Con Kotlin data class File from JSON los nombres de las propiedades se obtienen directamente de la respuesta JSON.</p>


<p>En ocasiones puede que no sean los más idóneos, en este caso se podrían cambiar utilizando la notación <span class="r-word">@SerializedName</span>:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-48-13.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para facilitar el uso de los datos recibidos se cambia el nombre de la propiedad <span class="negrita">results</span>
   por <span class="d-word">characters</span> y el nombre de la Data class <span class="negrita">Results</span> por <span class="d-word">CharacterInfo</span>:</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-49-03.png" /><br><figcaption></figcaption></figure>
<br>

<p>El siguiente paso es crear una <span class="negrita">interface</span> que permita realizar las peticiones.</p>

<p>Para ello se crea dentro del paquete <span class="negrita">data</span> un archivo llamado <span class="inline-file">RetrofitService.kt</span> con el siguiente código:</p>


<figure><img src="UD9/images/ud9-2024-03-06-13-49-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>En este archivo se deben crear tantas funciones como peticiones a diferentes endpoints se vayan a realizar en la aplicación.</p>

<p>En el caso de que la aplicación <span class="negrita">también haga uso de una base de datos local SQLite</span> se habrán creado al menos un DAO general 
  y un DAO específico.</p>

<p>En este caso es recomendable que el archivo <span class="inline-file">RetrofitService.kt</span> siga la estructura DAO.</p>

<p>En la aplicación se deberá comprobar el estado de la conexión a internet para decidir si se utilizan peticiones a la API o a la base de datos Local.</p>

<p>También habrá que tener en cuenta el respaldo de datos en las dos direcciones.</p>

<p>Para poder usar la <span class="negrita">interface</span> creada anteriormente se debe tener un objeto que devuelva el <span class="negrita">servicio Retrofit</span>.</p>

<p>Para ello se crea dentro del paquete <span class="negrita">data</span> un archivo llamado RetrofitServiceFactory.kt con el siguiente código:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-51-47.png" /><br><figcaption></figcaption></figure>
<br>
<p>La aplicación hará uso de un ViewModel y LiveData para mantener los datos durante la ejecución.</p>

<p>En un paquete llamado <span class="negrita">viewmodel</span> se crea el archivo <span class="inline-file">CharacterViewModel</span> con el siguiente código:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-52-27.png" /><br><figcaption></figcaption></figure>
<br>

<p>Por último, se muestra el código de la pantalla principal en el archivo <span class="inline-file">MainActivity.kt</span></p>
<figure><img src="UD9/images/ud9-2024-03-06-13-53-01.png" /><br><figcaption></figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-03-06-13-53-32.png" /><br><figcaption>Componente GridListSwitch</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-53-46.png" /><br><figcaption>Componente SearchBox</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-54-00.png" /><br><figcaption>Componente LoadingInfo</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-55-09.png" /><br><figcaption>Componentes CharacterVerticalGrid y CharacterInfoGrid</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-06-13-55-54.png" /><br><figcaption>Componentes CharactersLazyColumn y CharacterInfoList</figcaption></figure>
<br>

<p>La aplicación desarrollada en el caso de estudio se puede ampliar de las siguientes maneras.</p>

<p>Si se analiza el JSON de la respuesta se puede observar que no se reciben todos los datos existentes si no que se reciben paginados de 20 en 20.</p>

<p>Con las variables <span class="negrita">pages</span> y <span class="negrita">next</span> se puede saber si se necesitan hacer más peticiones para seguir obteniendo datos.</p>

<p>De esta manera se puede añadir un botón al final de los personajes y que al pulsarlo cargue los siguientes resultados para el personaje que se busca.</p>

<figure><img src="UD9/images/ud9-2024-03-06-13-56-53.png" /><br><figcaption></figcaption></figure>
<br>
<p>Otra mejora sería crear una pantalla para mostrar la información completa de cada personaje.</p>

<p>De esta manera se puede hacer que al pulsar sobre el personaje se navegue a esa pantalla y se le pase como parámetro todos los datos del personaje.</p>

<p>Si se han modificado las Data class para la respuesta eliminando campos innecesarios, 
  en la pantalla para la información del personaje se podría realizar una petición nueva a la API 
  para obtener solo la información de ese personaje mediante su endpoint. </p>

<p>En el JSON también se puede observar que cada personaje tiene un endpoint propio:</p>
<figure><img src="UD9/images/ud9-2024-03-06-13-57-46.png" /><br><figcaption></figcaption></figure>
<br>


</section><!-- End section Retrofit-->


  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>