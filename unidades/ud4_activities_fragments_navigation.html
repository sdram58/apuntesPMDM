<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activities, Intents, Fragments. Navigation</title>
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/prism.css">
    <link rel="stylesheet" href="../styles/styles.css">
    <script src="../script/script.js"></script>
</head>
<body class="line-numbers">
    <h1>Activities, Fragments. Navigation</h1>

    <div class="main-menu">
        <a href="#sActivities">Activities</a><a 
           href="#sFragments">Fragments</a><a 
           href="#sNavigation">Navigation</a><a
           href="#sWebgrafia">Webgraphy</a>
    </div>

    <!--*********************************************************Activities***********************************************************-->
    <section class="apartado">
    <a name="sActivities"></a>
    <h2>Activities</h2>
    <h3>Introduction to Activities</h3>
    <p>The <span class="r-word">Activity</span>  class is a crucial component of an Android app, and the way activities are launched and put together is a fundamental part of the platform's application model.
        Unlike other programming paradigms in which apps are launched with a <span class="negrita">main()</span> method, the Android system initiates code in an <span class="r-word">Activity</span> 
        instance by invoking specific callback methods that correspond to <span class="negrita">specific stages of its <span class="subrayado">lifecycle</span> </span> .</p>

    <p class="sub-section">The concept of activities</p>
    
    <p>The mobile-app experience <span class="subrayado">differs from</span>  its <span class="subrayado">desktop</span>  counterpart in that a user's interaction with the app 
        doesn't always begin in the same place. Instead, the user journey often begins non-deterministically. For instance, if you open an email app from your home screen,
        you might see a list of emails. By contrast, if you are using a social media app that then launches your email app, 
        you might go directly to the email app's screen for composing an email.</p>

    <p>The <span class="r-word">Activity</span>  class is designed to facilitate this paradigm. When one app invokes another, the calling app invokes an activity in the other app,
        rather than the app as an atomic whole. In this way, the <span class="negrita">activity serves as the entry point</span> for an app's interaction with the user.
        You implement an activity as a subclass of the <span class="r-word">Activity</span> class.</p>

    <p>An <span class="subrayado">activity provides the window</span> in which the app draws its UI. This window typically fills the screen, but may be smaller 
        than the screen and float on top of other windows. <span class="negrita">Generally, one activity implements one screen in an app</span>. 
        For instance, one of an app’s activities may implement a <span class="cursiva">Preferences screen</span> , while another activity implements a <span class="cursiva">Select Photo screen</span> .</p>

    <p>Most apps contain <span class="negrita">multiple screens</span> , which means they are composed by <span class="negrita">multiple activities</span>. 
        Typically, one activity in an app is specified as the main activity, which is the first screen to appear when the user launches the app. 
        Each activity can then start another activity in order to perform different actions. 
        For example, the main activity in a <span class="cursiva">simple e-mail app</span>  may provide the screen that shows an <span class="cursiva">e-mail inbox</span>. 
        From there, the main activity might launch other activities that provide screens for tasks like <span class="cursiva">writing e-mails</span>  and <span class="cursiva">opening individual e-mails</span> .</p>

    <p>Although activities work together to form a cohesive user experience in an app, each activity is only loosely bound to the other activities; 
        there are usually minimal dependencies among the activities in an app. In fact, activities often start up activities belonging to other apps. 
        For example, a browser app might launch the <span class="cursiva">Share activity</span>  of a <span class="cursiva">social-media app.</span></p>

    <p>To use activities in your app, you must register information about them in the app’s manifest, and you must manage activity lifecycles appropriately.</p>


    <p class="sub-section">Configuring the manifest</p>
    
    <p>For your app to be able to use activities, you must declare the activities, and certain of their attributes, in the manifest.</p>
    <p>To declare your activity, open your manifest file and add an <span class="d-word">&lt;activity></span>  element as a child of the <span class="d-word">&lt;application></span>  element. For example:</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">AndroidManifest.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">&lt;manifest ... >
  &lt;application ... >
      &lt;activity android:name=".ExampleActivity" />
      ...
  &lt;/application ... >
  ...
&lt;/manifest ></code></pre>
            </section><br><br>
    </section>
    





    
    <h3>Live cicle.</h3>

    <p>
        As a user navigates through, out of, and back to your app, the <span class="r-word">Activity</span> instances in your app transition through different states
         in their <span class="d-word">lifecycle</span>. The <span class="r-word">Activity</span>  class <span class="negrita">provides a number of callbacks</span> 
         that allow the activity to know that a state has changed: that <span class="cursiva">the system is creating, stopping, or resuming an activity</span> , or 
         destroying the process in which the activity resides. </p>
    <p>Within the lifecycle callback methods, you can declare how your activity behaves when the user <span class="cursiva">leaves and re-enters the activity</span> . 
        For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. 
        When the user returns, you can reconnect to the network and allow the user to resume the video from the same spot. 
        In other words, each callback allows you to perform specific work that's appropriate to a given change of state. 
        Doing the <span class="negrita">right work at the right time</span> and handling transitions properly <span class="subrayado"> make your app more robust and performant</span>.
        For example, good implementation of the lifecycle callbacks can help ensure that your app avoids:</p>
        <ul>
            <li>Crashing if the user receives a phone call or switches to another app while using your app.</li>
            <li>Consuming valuable system resources when the user is not actively using it.</li>
            <li>Losing the user's progress if they leave your app and return to it at a later time.</li>
            <li>Crashing or losing the user's progress when the screen rotates between landscape and portrait orientation.</li>
        </ul>

        <p>To navigate transitions between stages of the activity lifecycle, the Activity class provides a core set of six callbacks: 
            <span class="r-word">onCreate()</span> , <span class="r-word">onStart()</span> , <span class="r-word">onResume()</span> , <span class="r-word">onPause()</span> , 
            <span class="r-word">onStop()</span> , and <span class="r-word">onDestroy()</span> . The system invokes each of these callbacks as an activity enters a new state.</p>
        
    <figure><img src="imagenes/ud4-2021-10-03-19-45-47.png" /><br><figcaption>Activity Lifecycle</figcaption></figure>
    <br>

    <p>As the user begins to leave the activity, the system calls methods to dismantle the activity. In some cases, this dismantlement is only partial; 
        the activity still resides in memory (such as when the user switches to another app), 
        and can still come back to the foreground. If the user returns to that activity, the activity resumes from where the user left off.</p>

    <p>The system’s likelihood of killing a given process —along with the activities in it— depends on the state of the activity at the time</p>
    <figure><img src="imagenes/ud4-2021-10-03-19-51-35.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p class="sub-section">onCreate()</p>
    
    <p>You must implement this callback, which fires when the system creates your activity. 
        Your implementation should initialize the essential components of your activity: 
        For example, your app should create views and bind data to lists here.
        Most importantly, this is where you must call <span class="r-word">setContentView()</span>  to define the layout for the activity's user interface.</p>

    <p>When <span class="r-word">onCreate()</span>  finishes, the next callback is always onStart().</p>

    <p class="sub-section">onStart()</p>
    <p>As <span class="r-word">onCreate()</span>  exits, the activity enters the <span class="negrita">Started state</span> , 
        and the <span class="subrayado">activity becomes visible to the user</span>. This callback contains what amounts to the activity’s final 
        preparations for coming to the foreground and becoming interactive.</p>
    
    <p class="sub-section">onResume()</p>
    <p>The system invokes this callback just before the activity starts interacting with the user. 
        At this point, the activity is at the top of the activity stack, and captures all user input. Most of an app’s core functionality is 
        implemented in the <span class="r-word">onResume()</span>  method.

        The <span class="r-word">onPause()</span> callback always follows <span class="r-word">onResume()</span> .</p>

    
    <p class="sub-section">onPause()</p>
    <p>The system calls <span class="r-word">onPause()</span>  when the activity loses focus and enters a <span class="negrita">Paused state</span>. 
        This state occurs when, for example, the user taps the <span class="cursiva">Back</span>  or <span class="cursiva">Recents button</span>. 
        When the system calls <span class="r-word">onPause()</span> for your activity, it technically means your activity is still partially visible, 
        but most often is an indication that the user is leaving the activity, and the activity will soon enter the <span class="cursiva">Stopped</span>  or <span class="cursiva">Resumed state</span>.</p>

    <p>An activity in the <span class="negrita">Paused state</span> may continue to update the UI if the user is expecting the UI to update. 
        Examples of such an activity include one showing a navigation map screen or a media player playing. 
        Even if such activities lose focus, the user expects their UI to continue updating.</p>
        
    <p>You should <span class="subrayado">not use</span> <span class="r-word">onPause()</span> to save application or user data, make network calls, 
        or execute database transactions.</p>
        
    <p>Once <span class="r-word">onPause()</span>  finishes executing, the next callback is either <span class="r-word">onStop()</span>  or <span class="r-word">onResume()</span>, 
        depending on what happens after the activity enters the <span class="negrita">Paused state</span> .</p>

    <p class="sub-section">onStop()</p>
    <p>The system calls <span class="r-word">onStop()</span>  when the activity is no longer visible to the user. This may happen because the activity is <span class="negrita">being destroyed</span> , 
        <span class="negrita">a new activity is starting</span> , or an existing activity is entering a <span class="negrita">Resumed state</span>  and is covering the stopped activity. 
        In all of these cases, the stopped activity is no longer visible at all.

    <p>The next callback that the system calls is either <span class="r-word">onRestart()</span> , 
        if the activity is coming back to interact with the user, or by <span class="r-word">onDestroy()</span> if this activity is completely terminating.</p></p>
    

    <p class="sub-section">onRestart()</p>
    <p>The system invokes this callback when an activity in the <span class="negrita">Stopped state</span>  is about to restart. <span class="r-word">onRestart()</span> 
        restores the state of the activity from the time that it was stopped.</p>
    <p>This callback is always followed by <span class="r-word">onStart()</span>.</p>
    
    <p class="sub-section">onDestroy()</p>
    <p>The system invokes this callback before an <span class="cursiva">activity is destroyed.</span> </p>
    <p>This callback is the final one that the activity receives <span class="r-word">onDestroy()</span>  is usually implemented to 
        ensure that all of an activity’s resources are released when the activity, or the process containing it, is destroyed.</p>



    

    <h3>Intents - Intent Filters</h3>

    <p>An <span class="d-word">Intent</span> is a messaging object you can use to request an action from another app component. 
        Although intents facilitate communication between components in several ways, there are three fundamental use cases:</p>

    <p>
        <ul>
            <li><span class="negrita">Starting an activity</span><p>An Activity represents a single screen in an app. 
                You can start a new instance of an Activity by passing an Intent to <span class="r-word">startActivity()</span>. 
                The Intent describes the activity to start and carries any necessary data.</p><p>If you want to receive a result from the activity 
                    when it finishes, call <span class="r-word">startActivityForResult()</span>. 
                    Your activity receives the result as a separate Intent object in your activity's <span class="negrita">onActivityResult()</span> callback</p></li>
            <li><span class="negrita">Starting an service</span><p>A <span class="negrita">Service</span> is a component that performs operations in the background 
                without a user interface. With Android 5.0 (API level 21) and later, you can start a service with <span class="d-word">JobScheduler</span>.</p></li>
            <li><span class="negrita">Delivering a broadcast</span><p>A broadcast is a message that any app can receive. 
                The system delivers various broadcasts for system events, such as when the system boots up or the device starts charging. 
                You can deliver a broadcast to other apps by passing an <span class="d-word">Intent</span>  to <span class="r-word">sendBroadcast()</span>  or <span class="r-word">sendOrderedBroadcast()</span> </p></li>        </ul>
    </p>

    <p class="sub-section">Launching another Activity from same app</p>

    <p>You can see the whole example in: </p>
    
    <p>In this subsection we are going to see one way to launch another activity in the same app with intents.</p>

    <p>Firstly, we have to create new project with an empty activity template and then we're going to add another activity. For that, click with the right button of the mouse over project section and then selecte new -> activity -> empty activity</p>


    <figure><img src="./imagenes/ud4_NewActivity.gif" /><br><figcaption></figcaption></figure>
    <br>

    <p>Name it as <span class="d-word">Activity2</span> . Is not a good name but for this example is enough.</p>

    <figure><img src="imagenes/ud4-2021-10-03-21-22-23.png" /><br><figcaption>New activity "Activity2" created</figcaption></figure>
    <br>

    <p>In order to show <span class="d-word">Activity2</span>  we're going to add a button in the <span class="d-word">MainActivity</span> </p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
        &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:app="http://schemas.android.com/apk/res-auto"
            xmlns:tools="http://schemas.android.com/tools"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            tools:context=".Activity2">
        
            &lt;TextView
                android:id="@+id/tvGreeting"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="76dp"
                android:text="Main Activity"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toTopOf="parent" />
        
        
            &lt;Button
                android:id="@+id/btnGoActivity2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="56dp"
                android:text="@string/go"
                app:layout_constraintEnd_toEndOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintTop_toBottomOf="@+id/tvGreeting" />
        &lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
        </section><br><br>

        <figure><img src="imagenes/ud4-2021-10-04-00-12-55.png" /><br><figcaption>activity_main.xml</figcaption></figure>
        <br>
        
    </section>

    <p><span class="cursiva">Actitivy2</span> layout will have the next code below with a <span class="cursiva">TextView</span> , <span class="cursiva">EditText</span>  and a <span class="cursiva">Button</span>  to go back. For now we're not using them</p>
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_2.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Activity2">

    &lt;TextView
    android:id="@+id/tvTop"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="76dp"
    android:text="Second Activity"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent" />

    &lt;EditText
        android:id="@+id/etName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="32dp"
        android:ems="10"
        android:inputType="textPersonName"
        android:text="Name"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tvTop" />

    &lt;Button
        android:id="@+id/btnBack"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="56dp"
        android:text="@string/back"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/etName" />
&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
            </section><br><br>

    <figure><img src="imagenes/ud4-2021-10-04-00-12-13.png" /><br><figcaption>activity_2.xml</figcaption></figure>
    <br>
    
    </section>

    <p>For create an <span class="r-word">Intent</span>  that goes to another of our actitities we should use its constructor. It accepts at least two params, 
        the first one is the <span class="negrita">context</span> , that is where and who is going to call the function. The second one is the <span class="negrita">destination activity class</span> .</p>
    <section><pre><code class="language-kotlin">val intent = Intent(this, Activity2::class.java)</code></pre>
    </section><br><br>
    

    <p>Then in the MainActivity.kt we should add a listener for the button that starts the new activity with the created Intent</p>
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin"> override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener{ openActivity2() }
}

private fun openActivity2() {
    val intent = Intent(this, Activity2::class.java)
    startActivity(intent)
}</code></pre>
            </section><br><br>
    </section>

    <p>Now is Actitity2's turn, so let's make the listener for the back button. To return to the previous activity we have mainly two options:</p>
    <p><ol>
        <li>Implement a similar method that in MainActivity.
            <section><pre><code class="language-kotlin">binding.btnBack.setOnClickListener{
    val intent = Intent(this, MainActivity::class.java)
    startActivity(intent)
}</code></pre>
            </section><br><br>
        </li>
        <li>Simply close current Activity. By default, when you start an activity goes to the top of the task stack, if you start another activity, 
            the last one opened goes to the top. If you close the last activity, the previous activity goes to the top, that means this is the one is running
        <section><pre><code class="language-kotlin">binding.btnBack.setOnClickListener{
        finish()
    }</code></pre>
        </section><br><br>
    </ol></p>
    <p>The two options above are distincs, let's see why. The thing is that if you call again <span class="r-word">startActivity</span>  function you creates a new Instance</p>
    <p>Activity Task Stack using startActivity again in the Activity2:
        <ol>
            <li>Empty</li>
            <li>Empty &lt;- MainActivity: Starts the app</li>
            <li>Empty &lt;- MainActivity &lt;- Activity2: startActivity "Acitvity2"</li>
            <li>Empty &lt;- MainActivity &lt;- Activity2 &lt;- MainActivity: startActivity "MainActivity"</li>
            <li>Empty &lt;- MainActivity &lt;- Activity2: push mobile back button</li>
            <li>Empty &lt;- MainActivity: push mobile back button</li>
            <li>Empty: push mobile back button (Exit app)</li>            
        </ol>
    </p>
    <figure><img src="imagenes/ud4_startActivity.gif" /><br><figcaption>Using startActivity to return</figcaption></figure>
    <br>
    
    <p>Activity Task Stack using finish:
        <ol>
            <li>Empty</li>
            <li>Empty &lt;- MainActivity: Starts the app</li>
            <li>Empty &lt;- MainActivity &lt;- Activity2: startActivity "Acitvity2"</li>
            <li>Empty &lt;- MainActivity : finish</li>
            <li>Empty &lt;- MainActivity: push mobile back button</li>
            <li>Empty: push mobile back button (Exit app)</li>            
        </ol>
    </p>
    <figure><img src="imagenes/ud4_finish.gif" /><br><figcaption>Using finish to return</figcaption></figure>
    <br>
    
    
    <h3>Sending data between activities</h3>
    <p>So far we have opened and closed activities, from our application, but ... what if we want the activities to communicate with each other, that is, pass information from one to another?</p>
    <p>In this section we will see how to pass simple data to another activity through <span class="d-word">bundles</span> (<span class="d-word">extras</span>)and pass full <span class="d-word">parcelable</span>  objects.</p>
    <p class="sub-section">Bundle extra</p>
    <p>Let's imagine that our <span class="negrita">MainActivity</span>  was a <span class="cursiva">Login screen</span> , and we want to pass the username and surname to <span class="negrita">Activity2</span>.
        In this case username and surname will be a <span class="cursiva">String</span>.</p>
    <p>We will add this data to the <span class="r-word">Intent</span> </p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">private val userName:String = "Carlos"
private val surName:String = "Tarazona"
companion object{ //A companion objects acts like an static class in Java
    val KEY_EXTRA_NAME:String ="MY_KEY_EXTRA_NAME"
    val KEY_EXTRA_SURNAME:String ="MY_KEY_EXTRA_SURNAME"
}
private fun openActivity2() {
    val intent = Intent(this, Activity2::class.java)
    val bundle = Bundle()
    bundle.putString(KEY_EXTRA_NAME,userName)        
    intent.putExtras(bundle)
    
    //or directly
    intent.putExtra(KEY_EXTRA_SURNAME, surName)
    
    startActivity(intent,bundle)
}</code></pre>
            </section><br><br>
    </section>

    <p>Or even better, using Kotlin operator <span class="r-word">Apply</span> </p>
    <section><pre><code class="language-kotlin">private fun openActivity2() {
    val intent = Intent(this, Activity2::class.java).apply {
        putExtra(KEY_EXTRA_NAME, userName)
        putExtra(KEY_EXTRA_SURNAME, surName)
    }     
    
    startActivity(intent)
}</code></pre>
    </section><br><br>
    
    <p>Now in the other activity (<span class="cursiva">Activity2</span> ), we check for extras and retrieve them</p>
    
    <section><pre><code class="language-kotlin"> override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = Activity2Binding.inflate(layoutInflater)
    setContentView(binding.root)

    var myText:String? = null

    if(intent.hasExtra(KEY_EXTRA_NAME))
        myText = "${intent.getStringExtra(KEY_EXTRA_NAME).toString()}"

    if(intent.hasExtra(KEY_EXTRA_SURNAME))
        myText = "${myText?:""} ${intent.getStringExtra(KEY_EXTRA_SURNAME).toString()}"

    binding.tvTop.text = myText?:"No user"
    //......
}</code></pre>
</section><br><br>

<p>Now we are going to make the called activity return data, we could do as in the previous one and put it in the Intent and call <span class="r-word">startActivity()</span> ,
        but as we've seen before, this push more activities into the task stack. To perform this type of actions we use <span class="r-word">registerForActivityResult()</span></p>

<section class="marco-t warn">
    <span class="icono warning"> </span>Traditional <span class="r-word">startActivityForResult()</span> method  is deprecated
    </section>
<section class="marco-b">
        
</section>

<p>So, to start another activity waiting for a result we should use <span class="negrita">registerForActivityResult</span> </p>

<section><pre><code class="language-kotlin">var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
    if (result.resultCode == Activity.RESULT_OK) {
        //Here we have the result of Activity2
        val data: Intent? = result.data
        //We use the extra included in the returned intent
        binding.tvGreeting.text = "Hello ${data?.getStringExtra(KEY_EXTRA_RESULT)?:"No return"}"
    }
}</code></pre>
</section><br><br>

<p>As you would have noticed, <span class="r-word">registerForActivityResult</span> takes two parameters. 
    The first defines the type of action/interaction needed (ActivityResultContracts) and the second is a callback function where we receive the result.</p>

<p>And for launching that activity we use:</p>
<section><pre><code class="language-kotlin">val intent = Intent(this, Activity2::class.java)
resultLauncher.launch(intent)</code></pre>
</section><br><br>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
    </section>
<section class="marco-b">
    <section><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {
    private lateinit var binding:ActivityMainBinding

    private val userName:String = "Carlos"
    private val surName:String = "Tarazona"

    companion object{
        val KEY_EXTRA_NAME:String ="MY_KEY_EXTRA_NAME"
        val KEY_EXTRA_SURNAME:String ="MY_KEY_EXTRA_SURNAME"
        val KEY_EXTRA_RESULT:String ="MY_KEY_EXTRA_RESULT"
    }



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)




        binding.button.setOnClickListener{ openSomeActivityForResult() }
    }

    var resultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val data: Intent? = result.data
            binding.tvGreeting.text = "Hello ${data?.getStringExtra(KEY_EXTRA_RESULT)?:"No return"}"
        }
    }



    fun openSomeActivityForResult() {
        val intent = Intent(this, Activity2::class.java)
        resultLauncher.launch(intent)
    }
}</code></pre>
    </section><br><br>
</section>

<p>But, how can we return data from called activity (<span class="negrita">Activity2</span>)?. We just have call <span class="r-word">seResult</span> method, that takes two 
    params, the first one is the <span class="d-word">resultCode</span> and the last one the intent with data </p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">Activity2.kt</span>
    </section>
<section class="marco-b">
     <section><pre><code class="language-kotlin">binding.btnBack.setOnClickListener{

    val text = binding.etName.text.toString()
    val returnIntent = Intent().apply {
        putExtra(KEY_EXTRA_RESULT, text)
    }   //Creates a new Intent with editText content as extra

    if(text != "")
        setResult(RESULT_OK, returnIntent) //The action went ok.
    else
        setResult(RESULT_CANCELED, returnIntent)

    finish() //Finish and close this activity

}</code></pre>
     </section><br><br>   
</section>

<figure><img src="imagenes/ud4-sampleReturnData.gif"/><br><figcaption></figcaption></figure>
<br>


<p class="sub-section">Parcelable objects</p>

<p><span class="negrita">What is Parcelable?</span> </p>
<p>It is an interface whose purpose is to <span class="subrayado">allow a quick way to pass objects between the various components that Android has</span>. 
    This process is lighter and faster than using <span class="cursiva">serializable</span> .</p>

<p>The first thing we will do is create a data class called <span class="negrita">Person</span>  and I will make it implement <span class="r-word">Parcelable</span>. 
    The good news is that Kotlin allows us to implement implementations in this particular type of class.</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">Person.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">package com.cartatar.intentactivitysameapp

import android.os.Parcel
import android.os.Parcelable

data class Person(val name: String?, val surname: String?):Parcelable {
    constructor(parcel: Parcel) : this(
        parcel.readString(),//name
        parcel.readString()//surname, the parameters have to have same order that writeToParcel
    ) {
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeString(surname)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator<Person> {
        override fun createFromParcel(parcel: Parcel): Person {
            return Person(parcel)
        }

        override fun newArray(size: Int): Array<Person?> {
            return arrayOfNulls(size)
        }
    }
}</code></pre>
</section><br><br>
</section>

<p>And now, we simply have to pass this object through the intent with an extra.</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
    </section>
<section class="marco-b">
<section><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener{ sendParcelablePerson() }
}

private fun sendParcelablePerson() {
    val person = Person("Carlos", "Tarazona")
    val intent = Intent(this, Activity2::class.java).apply {
        putExtra(KEY_EXTRA_RESULT_PARCELABLE, person)
    }

    startActivity(intent)
}</code></pre>
</section><br><br>
</section>

<p>Receiving the data class in <span class="negrita">Activity2</span>  is quite similar to receiving other data</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">Activity2.kt</span>
    </section>
<section class="marco-b">
    <section><pre><code class="language-kotlin">var myText:String? = null

if(intent.hasExtra(KEY_EXTRA_RESULT_PARCELABLE)){
    val person = intent.getParcelableExtra<Person>(KEY_EXTRA_RESULT_PARCELABLE)
    person.let{person ->
        myText = "${person?.name} ${person?.surname}"
    }
}

binding.tvTop.text = myText?:"No user"</code></pre>
        </section><br><br>     
</section>




<h3>Allowing Other Apps to Start Your Activity</h3>
    <p>If your app can perform an action that might be useful from another app, your app should be prepared to respond to action requests by specifying the appropriate <span class="d-word">intent filter</span> in your activity.</p>
    <p>For example, if you build a social app that can share messages or photos with the user's friends, you should support the <span class="r-word">ACTION_SEND</span> intent. 
        Then, when users initiate a "share" action from another app, your app appears as an option in the chooser dialog (also known as the "disambiguation dialog"), 
        as shown in figure</p>
    
    <figure><img src="imagenes/ud4-2021-10-04-11-25-17.png" /><br><figcaption>Disambiguation dialog</figcaption></figure>
    <br>
    
    <p>To allow other apps to start your activity in this way, you need to add an <span class="r-word">&lt;intent-filter></span> element in your manifest file for 
        the corresponding <span class="r-word">&lt;activity></span>  element.</p>
    <p>When your app is installed on a device, the system identifies your intent filters and adds the information to an internal catalog of intents supported by all installed apps. When an app calls <span class="r-word">startActivity()</span> 
         or <span class="r-word">startActivityForResult()</span> , with an implicit intent, the system finds which activity (or activities) can respond to the intent.</p>
    
<p class="sub-section">Add an Intent Filter</p>
<p>In order to properly define which intents your activity can handle, each <span class="negrita">intent filter</span> you add should be as specific as possible 
    in terms of the type of action and data the activity accepts.</p>

    <p>The system may send a given <span class="r-word">Intent</span>  to an activity if that activity has an intent filter fulfills the following criteria of the <span class="r-word">Intent</span> object:</p>
    <p>

        <ul>
            <li><span class="negrita">Action</span> 
                <p>A string naming the action to perform. Usually one of the platform-defined values such as <span class="r-word">ACTION_SEND</span>  or <span class="r-word">ACTION_VIEW</span> .</p>
                    
                <p>Specify this in your intent filter with the <span class="d-word">&lt;action></span>  element. 
                    The value you specify in this element must be the full string name for the action, instead of the API constant.</p>
            </li>
            <li><span class="negrita">Data</span> 
                <p>A description of the data associated with the intent.</p>
                <p>Specify this in your intent filter with the <span class="d-word">&lt;data></span>  element. Using one or more attributes in this element, 
                    you can specify just the MIME type, just a URI prefix, just a URI scheme, or a combination of these and others that indicate the data type accepted.</p>
            </li>
            <li><span class="negrita">Category</span> 
                <p>Provides an additional way to characterize the activity handling the intent, usually related to the user gesture or location from which it's started. 
                    There are several different categories supported by the system, but most are rarely used. 
                    However, all implicit intents are defined with <span class="r-word">CATEGORY_DEFAULT</span>  by default.</p>
                <p>Specify this in your intent filter with the <span class="r-word">&lt;category></span> element.</p>
            </li>
        </ul>
    </p>

    <p>In your intent filter, you can declare which criteria your activity accepts by declaring each of them with corresponding XML elements nested in the 
        <span class="d-word">&lt;intent-filter></span>  element.</p>

    <p>For example, here's an activity with an intent filter that handles the ACTION_SEND intent when the data type is either text or an image:</p>

    <section><pre><code class="language-xml">&lt;activity android:name="ShareActivity">
    &lt;intent-filter>
        &lt;action android:name="android.intent.action.SEND"/>
        &lt;category android:name="android.intent.category.DEFAULT"/>
        &lt;data android:mimeType="text/plain"/>
        &lt;data android:mimeType="image/*"/>
    &lt;/intent-filter>
&lt;/activity></code></pre>
    </section><br><br>

    <p>We are going to show an example using the application we created earlier. Basically we will make our App send a defined text to another App
        called SharedActivities, it will take the text, convert it to capital letters and when pressing the button it will return that text to the initial application. In the image below you can see how it works</p>

    <figure><img src="./imagenes/ud4-activities_dif_apps_com.gif" /><br><figcaption>Running sample</figcaption></figure>
    <br>
    
    <p>So, let's code</p>

    <p>First we are going to create an application, which converts a text into capital letters, it is a silly application but it serves as an example.</p>
    <p>In addition, this application will have 2 activities <span class="cursiva">MainActivity</span>, which will not do anything it is only for
         academic purpose, and <span class="cursiva">SharedActivity</span> , which will receive a text, and pass it to uppercase, it will also 
         have a button to return the text in uppercase to the application that called it.</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">SharedActivities app -> activity_main.xml</span>
        </section>
    <section class="marco-b">
        <p>Nothing special</p>
<section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    &lt;TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
</section><br><br>
    </section>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">SharedActivities app -> activity_shared.xml</span>
        </section>
    <section class="marco-b">
        <p>Nothing special</p>
<section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
    &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".SharedActivity">
    
        &lt;TextView
            android:id="@+id/tvShared"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/orange"
            android:textSize="30sp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:text="TextView" />
    
    
        &lt;Button
            android:id="@+id/btnSendBack"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="40dp"
            android:text="Send back"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@id/tvShared" />
    &lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
</section><br><br>
    </section>

    <p>Then we have to add <span class="r-word">&lt;intent-filter></span>  in the AndroidManifest file to indicate to the 
        system that this activity is capable of resolving this request </p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">AndroidManifest.xml</span>
        </section>
    <section class="marco-b">
<section><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.cartatar.sharedactivities">

    &lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.SharedActivities">
        &lt;activity android:name="SharedActivity"
            android:exported="true">
            &lt;intent-filter>
                &lt;action android:name="android.intent.action.SEND"/>
                &lt;category android:name="android.intent.category.DEFAULT"/>
                &lt;data android:mimeType="text/plain"/>
            &lt;/intent-filter>
        &lt;/activity>
        &lt;activity
            android:name=".MainActivity"
            android:exported="true">
            &lt;intent-filter>
                &lt;action android:name="android.intent.action.MAIN" />

                &lt;category android:name="android.intent.category.LAUNCHER" />
            &lt;/intent-filter>
        &lt;/activity>
    &lt;/application>

&lt;/manifest></code></pre>
</section><br><br>
    </section>

    
    <p>To call <span class="d-word">SharedActivities</span>  app from our app responding to click event. Pay atention in <span class="r-word">Intent.createChooser()</span>  method, that allows us choose destination App</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">var myResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
    if (result.resultCode == Activity.RESULT_OK) {
        val data: Intent? = result.data

        //When data go back we put it in the text view
        binding.tvGreeting.text = "${data?.getStringExtra(Intent.EXTRA_RETURN_RESULT)}"
    }
}

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)

    binding.button.setOnClickListener{ sendShared() }
}



private fun sendShared() {
    val sendIntent: Intent = Intent().apply {
        action = Intent.ACTION_SEND
        putExtra(Intent.EXTRA_TEXT, "Hi there! pass that to uppercase and send back.")
        type = "text/plain"
    }

    val shareIntent = Intent.createChooser(//Selector that allow us choose destination app according the action and intent-filter
        sendIntent,
        "Hey choose an app to uppercase") //Title of selector window
    myResultLauncher.launch(shareIntent)
}</code></pre>
            </section><br><br>
    </section>


    <p>And now, in <span class="negrita">SharedActivity</span>  of <span class="cursiva">SharedActivities</span> app, we have to receive the data</p>


    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">SharedActivity.kt</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-kotlin">class SharedActivity : AppCompatActivity() {

    private lateinit var binding: ActivitySharedBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_shared)
        binding = ActivitySharedBinding.inflate(layoutInflater)
        setContentView(binding.root)


        val data = intent
        var text:String? = null

        data?.let{
            if(data.hasExtra(Intent.EXTRA_TEXT))
                text = data.getStringExtra(Intent.EXTRA_TEXT).toString().uppercase()
            binding.tvShared.text = text
        }


        binding.btnSendBack.setOnClickListener {
            val intent = Intent().apply {
                putExtra(Intent.EXTRA_RETURN_RESULT, text?:"No text")
            }

            setResult(RESULT_OK,intent)
            finish()
        }
    }
}</code></pre>
        </section><br><br>
    </section>

    <p class="sub-section">Some examples of common intents</p>

       
    
    <p>Next snippets show you how to implement some common functions</p>

    <section class="marco-t warn">
        <span class="icono warning"> </span>  Warning 
        </section>
    <section class="marco-b">
        <p>If there are no apps on the device that can receive the implicit intent, your app <span class="subrayado">will crash</span>  when it calls <span class="r-word">startActivity()</span>.
        To first verify that an app exists to receive the intent, call <span class="r-word">resolveActivity()</span> on your Intent object. 
        If the result is <span class="negrita">non-null</span> , there is at least one app that can handle the intent and it's safe to call <span class="r-word">startActivity()</span>.
        If the result is <span class="negrita">null</span> , you should not use the intent and, if possible, you should disable the feature that invokes the intent.</p>
        
    </section>

    <p><span class="negrita">Make a phone call</span></p>
    <section><pre><code class="language-kotlin">fun dialPhoneNumber(phoneNumber: String) {
    val intent = Intent(Intent.ACTION_DIAL).apply {
        data = Uri.parse("tel:$phoneNumber")
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>
    <section class="marco-t inf">
        <span class="icono info"> </span> Do not forget give <span class="r-word">CALL_PHONE</span>  permission
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;uses-permission android:name="android.permission.CALL_PHONE" /></code></pre>
            </section><br><br>
    </section>

    <p><span class="negrita">Create an Alarm</span> </p>
    <section><pre><code class="language-kotlin">fun createAlarm(message: String, hour: Int, minutes: Int) {
    val intent = Intent(AlarmClock.ACTION_SET_ALARM).apply {
        putExtra(AlarmClock.EXTRA_MESSAGE, message)
        putExtra(AlarmClock.EXTRA_HOUR, hour)
        putExtra(AlarmClock.EXTRA_MINUTES, minutes)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>   
        

    <section class="marco-t inf">
        <span class="icono info"> </span> Remember give your app permission
        </section>
    <section class="marco-b">
        <section><pre><code class="language-xml">&lt;uses-permission android:name="com.android.alarm.permission.SET_ALARM" /></code></pre>
        </section><br><br>
    </section>
        
    <p><span class="negrita">Add a calendar event</span> </p>
    <section><pre><code class="language-kotlin">fun addEvent(title: String, location: String, begin: Long, end: Long) {
    val intent = Intent(Intent.ACTION_INSERT).apply {
        data = Events.CONTENT_URI
        putExtra(Events.TITLE, title)
        putExtra(Events.EVENT_LOCATION, location)
        putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin)
        putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Capture a picture or video and return it</span> </p>
    <section><pre><code class="language-kotlin">const val REQUEST_IMAGE_CAPTURE = 1
val locationForPhotos: Uri = ...

fun capturePhoto(targetFilename: String) {
    val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {
        putExtra(MediaStore.EXTRA_OUTPUT, Uri.withAppendedPath(locationForPhotos, targetFilename))
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivityForResult(intent, REQUEST_IMAGE_CAPTURE)
    }
}

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) {
    if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {
        val thumbnail: Bitmap = data.getParcelableExtra("data")
        // Do other work with full size photo saved in locationForPhotos
        ...
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Email</span></p>
    <section><pre><code class="language-kotlin">fun composeEmail(addresses: Array<String>, subject: String, attachment: Uri) {
    val intent = Intent(Intent.ACTION_SEND).apply {
        type = "*/*"
        putExtra(Intent.EXTRA_EMAIL, addresses)
        putExtra(Intent.EXTRA_SUBJECT, subject)
        putExtra(Intent.EXTRA_STREAM, attachment)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">New note</span> </p>
    <section><pre><code class="language-kotlin">fun createNote(subject: String, text: String) {
    val intent = Intent(NoteIntents.ACTION_CREATE_NOTE).apply {
        putExtra(NoteIntents.EXTRA_NAME, subject)
        putExtra(NoteIntents.EXTRA_TEXT, text)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Web search</span></p>
    <section><pre><code class="language-kotlin">fun searchWeb(query: String) {
    val intent = Intent(Intent.ACTION_WEB_SEARCH).apply {
        putExtra(SearchManager.QUERY, query)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Show a location on a map</span></p>
    <section><pre><code class="language-kotlin">fun showMap(geoLocation: Uri) { //example "geo:0,0?q=39.4295152,-0.4660814(Treasure)"
    val intent = Intent(Intent.ACTION_VIEW).apply {
        data = geoLocation
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Open Wifi Settings</span> </p>
    <section><pre><code class="language-kotlin">fun openWifiSettings() {
    val intent = Intent(Settings.ACTION_WIFI_SETTINGS)
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Text message</span> </p>
    <section><pre><code class="language-kotlin">fun composeMmsMessage(message: String, attachment: Uri) {
    val intent = Intent(Intent.ACTION_SENDTO).apply {
        type = HTTP.PLAIN_TEXT_TYPE
        putExtra("sms_body", message)
        putExtra(Intent.EXTRA_STREAM, attachment)
    }
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
    </section><br><br>

    <p><span class="negrita">Web browser</span> </p>
<section><pre><code class="language-kotlin">fun openWebPage(url: String) {
    val webpage: Uri = Uri.parse(url)
    val intent = Intent(Intent.ACTION_VIEW, webpage)
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    }
}</code></pre>
</section><br><br>


    <div class="tarea">Test Activity Lifecycle
        <p>Build a two activities app and catch all states of both activities according activity life cycle, onResume, onStart, onCreate, onDestroy, onRestart, onStop... in each one just call super and add a Log.i("ACTIVITYNAME", "STATE (onResume, onStart...)")</p>
        <p>Once done, start the App, navigate between activities, hide the app, and study which callbacks are running and in what order</p>
    </div> 
    
    
    </section><!-- End section -->
    
    
    <!--*********************************************************Fragments***********************************************************-->
    <section class="apartado">
    <a name="sFragments"></a>
    <h2>Fragments</h2>

    <h3>What's a fragment?</h3>
    
    <p><span class="cursiva">Fragments</span>  represent a basic component when developing an app. Until now we know the activities, which we explained in chapter above. 
        Now let's imagine that the fragment is a variant of the activity but with less power, but more manageable, that is, its behavior 
        is very similar (<span class="subrayado">they have a layout and a class to program</span> ) but <span class="negrita">they have to be inside an activity</span>.
        The difference is that this component is more reusable, and can be added together with more fragments in the same activity.
    </p>

    <p>Its popularity began with the fashion of <span class="cursiva">tablets</span> , they were very large screens that allowed you to take more advantage 
        of the fragments by adding several in a single activity, showing more information than on a mobile.
    </p>

    <figure><img src="imagenes/ud4-2021-10-05-11-30-18.png" /><br><figcaption>Master/detail app</figcaption></figure>
    <br>
    <p>They are available from API 11 (Android 3.0) and since then three different versions have been released.</p>

    <figure><img src="imagenes/ud4-2021-10-05-11-34-31.png" /><br><figcaption>Fragment versions</figcaption></figure>
    <br>
    
    <p>If we look at the previous table, we see that the first library is the native one (the fragments that came out in API 11), 
        although they are perfectly functional, they are deprecated. That is, Google thinks that its code is no longer optimized for the new versions, 
        and that is why it put the new Fragments in the <span class="negrita">Support Library</span> , which will be the one we will use. 
        We finished with Android X, which belongs to the new Google libraries but we will see them later, although if you want to learn more you can do it <a class="enlace" target="_blank" href="https://developer.android.com/jetpack?hl=es-419">here</a> . 
        We finish the table with the package, which means the type of import that we have to do in our class for it to detect it.</p>

    <p>Although they are not used so often, they are still essential for various components that you see in the day-to-day of your favorite applications, 
        so it is very necessary to fully understand their operation for advanced view design.</p>
    
    
    <h3>Fragment Example</h3>
    <p>We are going to create a new project called <span class="d-word">FragmentExample</span>. 
        The idea of ​​this app will be very simple. In our main <span class="cursiva">activity</span>  we will include two <span class="cursiva">fragments</span> 
        that will occupy half of the screen respectively. Each one will have a button that will contact the activity to display a message.</p>
    
    <p>Once we have created our project, we will go to the path where the <span class="negrita">MainActivity</span> class is and in the package 
        (name of Your Package/fragmentexample) we will right click and select <span class="d-word">New</span> > <span class="d-word">Fragment</span> > <span class="d-word">Fragment (Blank)</span>.</p>

    <figure><img src="./imagenes/ud4-newFragement.gif" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Then a confirmation screen will appear that will allow us to add the name. We will call it <span class="d-word">RedFragment</span>.</p>
    <p>Now we have two new files <span class="inline-file">RedFragment.kt</span> and <span class="inline-file">fragment_red.xml</span>, for the class fragment and its layout</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">RedFragment.kt</span>
        </section>
    <section class="marco-b">
        <p>As you can see it already has code from a template</p>
        <section><pre><code class="language-kotlin">class RedFragment : Fragment() {
    // TODO: Rename and change types of parameters
    private var param1: String? = null
    private var param2: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.fragment_red, container, false)
    }

    companion object {
        /**
         * Use this factory method to create a new instance of
         * this fragment using the provided parameters.
         *
         * @param param1 Parameter 1.
         * @param param2 Parameter 2.
         * @return A new instance of fragment RedFragment.
         */
        // TODO: Rename and change types and number of parameters
        @JvmStatic
        fun newInstance(param1: String, param2: String) =
            RedFragment().apply {
                arguments = Bundle().apply {
                    putString(ARG_PARAM1, param1)
                    putString(ARG_PARAM2, param2)
                }
            }
    }
}</code></pre>
        </section><br><br>
    </section>

    <p>and</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">fragment_red.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".RedFragment">

    &lt;!-- TODO: Update blank fragment layout -->
    &lt;TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="@string/hello_blank_fragment" />

&lt;/FrameLayout></code></pre>
            </section><br><br>
    </section>
    

    <p>The first thing we will do is give it a very simple design. We will define the <span class="negrita">two colors</span>  that we will use in the app. 
        We will go to <span class="inline-file"> app/res/values​​/colors.xml</span>. If it does not exist we will create it by right clicking on values
         ​​(<span class="negrita">new > Values ​​resource file</span>). Inside we will see seven (depending on the version) colors created, do not delete them, since the system will always
         need those three to paint the app. We will add two more, <span class="cursiva">red</span>  and <span class="cursiva">blue</span>.</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">colors.xml</span>
        </section>
    <section class="marco-b">
<section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;resources>
    ........
    &lt;color name="red">#FF80AB&lt;/color>
    &lt;color name="blue">#80D8FF&lt;/color>

&lt;/resources></code></pre>
</section><br><br>
    </section>


    <p>If you have not worked with resources, this is nothing more than a "shortcut" to define the colors that we will use in the app. 
        It is about defining a name (in this case red and blue) and assigning them a hexadecimal color code. If you want to try other colors, 
        just click on the color box that appears at the beginning of the line and play with the visual editor.</p>

    
    <p>Now we go back to the fragment and access its layout, which is called <span class="inline-file">fragment_red.xml</span>.</p>
    <p>The design will be very simple, with a red background and a blue button in the center.</p>
    <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/red">
    &lt;Button
        android:id="@+id/btnPlus"
        android:text="+1"
        android:layout_gravity="center"
        android:background="@color/blue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
&lt;/FrameLayout></code></pre>
    </section><br><br>

    <figure><img src="imagenes/ud4-2021-10-05-13-21-55.png" /><br><figcaption>Red fragment UI</figcaption></figure>
    <br>
    
    <p>Now we will repeat the process, we will create another fragment called <span class="d-word">BlueFragment</span>  that will have an opposite design, 
        that is, the color of the background will be blue and that of the button red.</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">fragment_blue.xml</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/blue">
    &lt;Button
        android:id="@+id/btnPlus"
        android:text="+1"
        android:layout_gravity="center"
        android:background="@color/red"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>

&lt;/FrameLayout></code></pre>
        </section><br><br>    
    </section><br><br>

    <p>Now that we have the two fragments created we are going to go back to our <span class="d-word">MainActivity</span> 
         and go to its layout, called <span class="negrita">activity_main</span>. Once inside we edit it and leave it like that.</p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    &lt;fragment android:name="com.cartatar.fragmentexample.RedFragment"
        android:id="@+id/first"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="match_parent" />
    &lt;fragment android:name="com.cartatar.fragmentexample.BlueFragment"
        android:id="@+id/second"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="match_parent" />
&lt;/LinearLayout></code></pre>
            </section><br><br>
    </section>
    
    <p>Let's analyze the code above. The first thing has been to create a <span class="r-word">linearLayout</span>  that allows you to place components horizontally or
        vertically depending on the value that we put in the <span class="r-word">android: orientation</span> property. Then we have created two fragment 
        components that contain a name attribute where we must set the path of our fragment, a unique id to refer to each of the fragments.</p>

    <p>The <span class="r-word">layout_height</span>  and <span class="r-word">layout_width</span> attributes, as we know, are mandatory, 
        but in this case we have put 0dp in the <span class="negrita">width</span> . This is because a <span class="d-word">linearLayout</span> property is 
        that if we set a width or height to 0dp and set the <span class="r-word">layout_weight</span>  property, we can divide the available size into a percentage. 
        That is, if we put <span class="r-word">layout_weight = 1</span>  to each of the linearLayout components, both will occupy an exact percentage of the screen 
        (in this case 50%). If we change and put a weight of 2 in one of the components, it will occupy 66.6% while the other will occupy the remaining 33.3% and so on.</p>

    <p>If we run our app right now, we would see something like this.</p>

    <figure><img src="imagenes/ud4-2021-10-05-13-35-06.png" /><br><figcaption>Running app</figcaption></figure>
    <br>
    
    <p>Very nice, but right now the app won't do anything. In order to continue we must enter and understand more about the functioning of the fragments.</p>

    
    
    
    <!-------------------------------------------Fragment lifecycle------------------------------------------>

    <h3>Fragment's lifecycle</h3>

    <figure><img src="../imagenes/underconstruction.gif" /><br><figcaption>underconstruction</figcaption></figure><br><br>
    <p>The <span class="negrita">life cycle</span>  of a fragment is nothing more than the methods through which it passes <span class="subrayado">from when it is created until it is destroyed</span>,
        as a simile our life cycle if they were functions would be to be born (), grow (), reproduce () and die(). Well, it's basically the same.</p>

    <figure><img src="imagenes/ud4-2021-10-05-11-51-04.png" /><br><figcaption>Fragment's lifecycle</figcaption></figure>
    <br>

    <p>In the image above, we will see the <span class="negrita">life cycle</span>. Before explaining it, we must understand that our fragment extends from a higher class 
        called <span class="r-word">Fragment</span> , therefore, although we do not see these methods within our class, they are being executed from behind.
        In addition, <span class="subrayado">we can overwrite them and modify their behavior</span> to do what we need.
    </p>
     
    <p>Another Image with Activities' lifecycle</p>    
    

    <figure><img src="imagenes/ud4-2021-10-05-10-21-45.png" /><br><figcaption>Fragment's lifecycle</figcaption></figure>
    <br>

    <p class="sub-section">Creation states</p>
    <p>The first thing we have to do to start the life cycle is to <span class="negrita">add the fragment</span>. 
        In the above example, this event is reproduced when executing the <span class="d-word">MainAcitivity</span>, because in its layout, it contains two fragments. 
        It is at that moment when the cycle begins, the next step will be the <span class="r-word">onAttach()</span> function, in other words, it will "bind" our activity
        to our fragment, giving them the opportunity to communicate. We move to <span class="r-word">onCreate()</span>  which will be called when we have created the 
        fragment instance, that is, we are "building" it.
    </p>

    <p>Then we will get to <span class="r-word">onCreateView()</span>, that if we look at our fragments, this method will appear with a keyword at the beginning (<span class="r-word">override</span>),
        this tells the system that it is going to do what it should do as a general rule, but then we will to modify its behavior by adding extra functionalities, 
        in this case we are returning the view that will contain this fragment. When the view has finished creating, we will arrive at <span class="r-word">onActivityCreated()</span>,
        which notice us that everything is available. This is a good place to add <span class="r-word">onClick()</span>  functions or initialize fragment variables.</p><br>

    <p><span class="negrita">Creation State</span></p>
    <p>The <span class="r-word">onStart()</span>  method will be launched almost right after the previous method, and it will notify us when we can work with the fragment.</p><br>

    <p><span class="negrita">Resume State</span></p>
    <p>The following is basically the same, <span class="r-word">onResume()</span>  will act in a similar way but it will be called more times, 
        for example if we minimize the application on the mobile and reopen it, the <span class="r-word">onResume()</span>  function will be called 
        again, but <span class="r-word">onStart()</span> will not.
    </p><br>

    <p><span class="negrita">Pause State</span></p>
    
    <p>When a new <span class="negrita">activity</span>  is placed on top of the one that hosts the <span class="negrita">fragment</span>, 
        but this first activity does not fully cover the fragment's view, the onPause() method starts, but even in this state the information that is in the <span class="cursiva">fragment</span>  
        is preserved.</p><br>

    <p><span class="negrita">Stop State</span></p>

    <p>If the previous process is repeated, but the screen is completely covered or the <span class="negrita">fragment</span> has been removed from the activity,
         it changes to the <span class="r-word">onStop()</span> state. The stopped <span class="negrita">fragment</span> is still active, 
         but will be destroyed if its containing acitivity is destroyed.</p><br>

    <p><span class="negrita">Destroy State</span></p>

    <p>It contains three different functions that will be called sequentially once the processes are ending. 
        The first will be <span class="r-word">onDestroyView()</span> that will be called when the view is going to be destroyed, when it ends it will go through 
        <span class="r-word">onDestroy()</span> that will end the life of the fragment, ending with <span class="r-word">onDetach()</span>,
        which will do the opposite of the <span class="r-word">onAttach()</span> function that we saw before, basically detach the activity with the fragment.</p>

    <p>If we basically look at a create and destroy loop, but we need to understand what each of these functions does to see the next step.</p><br>



    <h3>Communication activity – fragment</h3>

    <p>There are times, like in this example, that we need our activity to do something, either to control and centralize the logic or because there 
        are different functions that fragments cannot do. Therefore, we must understand that the simplest way we have to do this is through <span class="negrita">listeners</span>.</p>

    <p>To do this, the first thing we will do is go to the directory where we have our activity and fragments and with the right button on the directory, go to <span class="d-word">new > Kotlin File Class</span> 
         and a dialog will appear to configure our file. We will call it <span class="d-word">OnFragmentActionsListener</span>  and in kind we will select <span class="negrita">interface</span>.</p>

    <figure><img src="imagenes/ud4-2021-10-05-13-47-52.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Our <span class="cursiva">interface</span> establishes a contract between those who use them, if we add it to our activity, all the methods that are in the interface must be added to this activity.
        We will create a function in the <span class="cursiva">interface</span> , but unlike the classes we will work with, we will only define the function
         with its input or output parameters if they have one, but not the logic (body), since it has to be implemented wherever we implement the 
         <span class="cursiva">interface</span>.</p>

    <section><pre><code class="language-kotlin">interface OnFragmentActionsListener {
    fun onClickFragmentButton()
}</code></pre>
    </section><br><br>


    <p>We have added a function called <span class="d-word">onClickFragmentButton()</span>  that does not take parameters or return anything. 
        Now we will implement this interface in the <span class="d-word">MainActivity</span>  class. For this we will add it in the first line, leaving our activity like this.
    </p>

    <section><pre><code class="language-kotlin">class MainActivity : AppCompatActivity(), OnFragmentActionsListener {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}</code></pre>
    </section><br><br>

    <p>If we try to compile now it will not let us, because if you look under the class name it will have a red line that warns us of an error.</p>

    <figure><img src="imagenes/ud4-2021-10-05-15-06-51.png" /><br><figcaption>Error, method not implemented</figcaption></figure>
    <br>
    
    <p>This <span class="negrita">error</span>  is telling us that we have implemented an interface but we have not added its methods, 
        for this we will do the following, we will go to the top <span class="d-word">menu > Code > Implement methods</span> and we will get a dialog with all
         the methods that we must implement, in this case it is only one .         
    </p>
        
    <figure><img src="imagenes/ud4-2021-10-05-15-08-58.png" /><br><figcaption>Implement methods</figcaption></figure>
    <br>
    
    <p>Once we have accepted, we see how a new function is added to our class.</p>
    
    <section><pre><code class="language-kotlin">override fun onClickFragmentButton() {
    TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
}</code></pre>
    </section><br><br>

    <p>As we have already talked about before, this function has the <span class="r-word">override</span>  reserved word before it, and inside it has a <span class="r-word">TODO</span> 
         that is nothing more than a reminder that we must do something with it, so we can delete that line.</p>
    
    <p>Within this method we will add a <span class="r-word">Toast</span> , which is a message that will appear at the bottom of the screen when the method is called.</p>

    <section><pre><code class="language-kotlin">override fun onClickFragmentButton() {
    Toast.makeText(this, "Button has been pushed", Toast.LENGTH_SHORT).show()    
}</code></pre>
    </section><br><br>

    <p>With this we would not have to do anything else in the activity. We go back to the fragments, going to <span class="d-word">BlueFragment</span>.</p>
    <p>The first thing we will do is add our listener to the fragment, for this we will start by declaring a listener variable, which is the same type as the interface.</p>
    <section><pre><code class="language-kotlin">private var listener: OnFragmentActionsListener? = null</code></pre>
    </section><br><br>

    <p>We will put this variable at the beginning of the class, and it can be <span class="negrita"><span class="cursiva">null</span> </span>, so we force ourselves to check its content before 
        trying to execute any action.</p>
    <p>Then to initialize it we will use one of the methods that we saw in the <span class="negrita">life cycle</span> , the <span class="r-word">onAttach()</span>  function.</p>
    

    <section><pre><code class="language-kotlin">override fun onAttach(context: Context) {
    super.onAttach(context)
    if (context is OnFragmentActionsListener) {
        listener = context
    }
}</code></pre>
    </section><br><br>

    <p>Let's analyze the above function. The first line calls the <span class="r-word">super()</span>  function, which is nothing more than the way we
        tell the system that, although we want it to do more things, it executes the code that has to be executed when calling this function. 
        That is, we want to add things but not remove what that method would normally do.</p>
    
    <p>Then we find an <span class="r-word">if()</span>, which will check if the context that reaches the <span class="r-word">onAttach()</span> 
        function has the interface we have created implemented. In this case, the context will be <span class="d-word">MainActivity</span>, 
        since it is the class that creates the fragment. To finish we match the <span class="cursiva">listener</span> 
        that we have declared at the top of the class to the context.</p>

    <p>The last step will be that we will disconnect the <span class="cursiva">fragment</span>  from the <span class="cursiva">activity</span> when it is going to die,
        so we will use another method of the <span class="negrita">life cycle</span> </p>
    
    <section><pre><code class="language-kotlin">override fun onDetach() {
    super.onDetach()
    listener = null
}</code></pre>
    </section><br><br>

    <p>When the <span class="r-word">onDetach()</span>  function is called, we will <span class="negrita">nullify</span>  the <span class="cursiva">listener</span> 
         again to make sure there is no miscommunication error. Now yes, we have our <span class="cursiva">listener</span>  working.</p>


    <p>The next question would be... How do we run the <span class="cursiva">listener</span>? For this we will do the usual, we will create an 
        <span class="r-word">onClickListener()</span>  so that when the button of the <span class="cursiva">fragment</span>  is executed it will call it.</p>

    <p>If we look at the <span class="cursiva">layout</span>  that we created earlier we will see that the name of its id is <span class="d-word">btnPlus</span>, 
        so we will assign the <span class="r-word">onClick</span>  in the <span class="r-word">onViewCreated</span>  method which,
        as you will see, is also part of the <span class="negrita">life cycle</span>.</p>

    <section><pre><code class="language-kotlin">override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    val myButton: Button = view.findViewById(R.id.btnPlus)

    myButton.setOnClickListener { listener?.onClickFragmentButton() }
}</code></pre>
    </section><br><br>

    <p>We have made that when the button is clicked, it calls the <span class="r-word">onClickFragmentButton()</span> function of the interface, 
        which will make our activity launch the toast. Our complete fragment would be as follows.</p>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">BlueFragment.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">package com.cartatar.fragmentexample

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button

// TODO: Rename parameter arguments, choose names that match
// the fragment initialization parameters, e.g. ARG_ITEM_NUMBER
private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

/**
 * A simple [Fragment] subclass.
 * Use the [BlueFragment.newInstance] factory method to
 * create an instance of this fragment.
 */
class BlueFragment : Fragment() {
    // TODO: Rename and change types of parameters
    private var param1: String? = null
    private var param2: String? = null

    private var listener: OnFragmentActionsListener? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.fragment_blue, container, false)
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnFragmentActionsListener) {
            listener = context
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val myButton: Button = view.findViewById(R.id.btnPlus)

        myButton.setOnClickListener { listener?.onClickFragmentButton() }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        /**
         * Use this factory method to create a new instance of
         * this fragment using the provided parameters.
         *
         * @param param1 Parameter 1.
         * @param param2 Parameter 2.
         * @return A new instance of fragment BlueFragment.
         */
        // TODO: Rename and change types and number of parameters
        @JvmStatic
        fun newInstance(param1: String, param2: String) =
            BlueFragment().apply {
                arguments = Bundle().apply {
                    putString(ARG_PARAM1, param1)
                    putString(ARG_PARAM2, param2)
                }
            }
    }
}</code></pre>
            </section><br><br>
    </section>

    <p>We have to do the same with <span class="d-word">RedFragment</span> </p>
    
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">RedFragment.kt</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-kotlin">package com.cartatar.fragmentexample

import android.content.Context
import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button

// TODO: Rename parameter arguments, choose names that match
// the fragment initialization parameters, e.g. ARG_ITEM_NUMBER
private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

/**
 * A simple [Fragment] subclass.
 * Use the [RedFragment.newInstance] factory method to
 * create an instance of this fragment.
 */
class RedFragment : Fragment() {
    // TODO: Rename and change types of parameters
    private var param1: String? = null
    private var param2: String? = null

    private var listener: OnFragmentActionsListener? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.fragment_red, container, false)
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnFragmentActionsListener) {
            listener = context
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val myButton: Button = view.findViewById(R.id.btnPlus)

        myButton.setOnClickListener { listener?.onClickFragmentButton() }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    companion object {
        /**
         * Use this factory method to create a new instance of
         * this fragment using the provided parameters.
         *
         * @param param1 Parameter 1.
         * @param param2 Parameter 2.
         * @return A new instance of fragment RedFragment.
         */
        // TODO: Rename and change types and number of parameters
        @JvmStatic
        fun newInstance(param1: String, param2: String) =
            RedFragment().apply {
                arguments = Bundle().apply {
                    putString(ARG_PARAM1, param1)
                    putString(ARG_PARAM2, param2)
                }
            }
    }
}</code></pre>
            </section><br><br>
    </section>


<figure><img src="./imagenes/ud4-fragment_layout.gif" /><br><figcaption></figcaption></figure>
<br>
<br>
<a class="enlace" target="_blank" href="https://github.com/sdram58/PMDM2021/tree/master/FragmentExample">https://github.com/sdram58/PMDM2021/tree/master/FragmentExample</a> 

    <h3>Using fragments programmatically</h3>
    <p>With the previous example we have managed to add <span class="cursiva">fragments</span>  with the xml layout, 
        which allows us to add them easily and quickly. Let's complicate things a bit now and see how we can add a <span class="cursiva">fragment</span> 
        programmatically (for example by pressing a button) or even replace it and change it depending on the user's selection.
    </p>

    <p>For this we will modify the <span class="negrita">xml</span>  of our <span class="d-word">MainActivity</span>  class.</p>

    <!--activity_main.xml-->
    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
        <section><pre><code class="language-kotlin">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/purple"
    android:orientation="vertical">

    &lt;Button
        android:id="@+id/btnRed"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:padding="8dp"
        android:layout_margin="5dp"
        android:background="@color/red"
        android:text="Fragment rojo" />

    &lt;Button
        android:id="@+id/btnBlue"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="8dp"
        android:layout_gravity="center_horizontal"
        android:layout_margin="5dp"
        android:background="@color/blue"
        android:text="Fragment azul" />

    &lt;FrameLayout
        android:id="@+id/fragmentContainer"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
&lt;/LinearLayout>
        </code></pre></section><br><br>
    </section>

    

    <p>We have added two buttons in the main activity that will be responsible for changing the fragment through code and 
        we have also added a <span class="r-word">FrameLayout</span>  that will be the <span class="negrita">container</span>  for said <span class="cursiva">fragments</span> .</p>

    <p>Surely the XML gives us an error, because I have added a new color, we go to <span class="d-word">Res > Values > Colors</span>  and add the violet.</p>
    
    <section><pre><code class="language-xml">&lt;color name="purple">#673AB7&lt;/color></code></pre></section><br><br>

    <p>Let's go to the <span class="d-word">ActivityMain</span>  class and create a method called <span class="r-word">loadFragment(fragment: Fragment)</span> 
    </p>

    <section><pre><code class="language-kotlin">private fun loadFragment(fragment:Fragment) {
    val fragmentTransaction = supportFragmentManager.beginTransaction()
    fragmentTransaction.add(R.id.fragmentContainer, fragment)
    fragmentTransaction.<span class="r-word">commit()</span> 
}
    </code></pre></section><br><br>

    <p>This function receives a <span class="cursiva">fragment</span>  that will be the one we want to load in our <span class="r-word">FrameLayout</span> 
         of the xml. First we create a <span class="r-word">fragmentTransaction</span>  object, this object is created with <span class="r-word">supportFragmentManager</span> 
         which is the one in charge of managing the <span class="r-word">fragments</span>  and has most of the methods we need in the management.</p>

    <p>To load a <span class="cursiva">fragment</span>  we will always do the same, <span class="subrayado">we need to notify the system that we are going 
        to make a change</span> , add it and save that change. That is exactly what our previous function does. 
        We start notifying the change with <span class="r-word">beginTransaction()</span> , then we call the <span class="r-word">add()</span> 
         function of the <span class="r-word">fragmentTransaction</span>  and close it with <span class="r-word">commit()</span> .</p>

    <p>To finish we need to add the <span class="r-word">onClickListener()</span>  function to our buttons to add the fragments.</p>


    <section><pre><code class="language-kotlin">binding.btnRed.setOnClickListener { loadFragment(RedFragment()) }
binding.btnBlue.setOnClickListener { loadFragment(BlueFragment()) }</code></pre></section><br><br>

<p>In the previous example we saw how to add <span class="cursiva">fragments</span> , but if you look closely, every time we add one, 
    the previous one will die. Now let's think that we are mkaing a workflow and there are two screens, in the first one the user has 
    to enter their personal data and in the second their address. If we work with fragments we have the possibility of 
    emulating the operation of the activities, that is, we can press back (both in the toolbar and the mobile button) 
    and return to the previous one.
</p>

<p>For this we will have to make two changes in the <span class="r-word">loadFragment()</span>  method.</p>

<section><pre><code class="language-kotlin">private fun replaceFragment(fragment: Fragment){
    val fragmentTransaction = supportFragmentManager.beginTransaction()
    fragmentTransaction.replace(R.id.fragmentContainer, fragment)
    fragmentTransaction.addToBackStack(null)
    fragmentTransaction.commit()
}
</code></pre></section><br><br>

<p>The first thing we have done is to rename it, since it no longer adds <span class="cursiva">fragments</span> , but replaces them. 
    This time the <span class="r-word">fragmentTransaction</span>  object does not call the <span class="r-word">add()</span>  
    function, but rather <span class="r-word">replace()</span>. To finish before doing the <span class="r-word">commit()</span>,
    we have added <span class="r-word">addToBackStack(null)</span> , which this we're telling the system to allow going back in the stack.
</p>

<p>If we run the complete example above and open a couple of <span class="cursiva">fragments</span> , pressing return will take us to the <span class="cursiva">previous fragment</span> .</p>

<figure><img src="./imagenes/ud4-fragment_prog.gif" /><br><figcaption></figcaption></figure>
<br>
<br>
<a class="enlace" target="_blank" href="https://github.com/sdram58/PMDM2021/tree/master/FragmentsProgrammatically">https://github.com/sdram58/PMDM2021/tree/master/FragmentsProgrammatically</a> 








    <!----------------------------------------------Master/detail. RecyclerView------------------------------------------------------>

    <h3>Master/detail. RecyclerView</h3> 

    <p>In this section we are going to see an example of how to implement Master / Detail type applications. Normally, in this type of application we have a list with a series of elements.</p>
    <p>We will implement the list through a RecyclerView.</p>

    <p>These applications are usually designed in two different ways depending on what device it is viewed on. If it is a mobile in portrait, there are usually two different screens, one for the list and one for the detail. For wide devices, both screens are seen in one. </p><p>Look at the image below.</p>


    <figure><img src="imagenes/ud4-2021-10-11-16-57-46.png" /><br><figcaption>Primary/Detal App</figcaption></figure>
    <br>

    <p>Instead of implementing according to the width of the device, because we do not have to install more emulators, we will do it depending on 
        whether the mobile is portrait or landscape. </p>
    <p>In this way, with the vertical mobile we will have an activity that will load the Fragment of the list or the Fragment of the detail. On the other hand, in the Landscape view, 
        the same Activity will contain the two Fragments, the one from the list and the one from the detail. So we will have a single Activity and 
        two Fragments, depending on the orientation we will load one or both. We will start by designing the Layout of the MainActivity, 
        we will create two versions, one for the Portrait version and the other for the Landscape version.</p>


    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    tools:context=".MainActivity">
    &lt;FrameLayout
        android:id="@+id/containerList"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

&lt;/LinearLayout></code></pre>
            </section><br><br>
    </section>
    <br><br>

    <p>We see that it contains a single container for Fragments, to which we put an ID to be able to reference it. </p>
    <p>Now it's time to create the Landscape version. We can do it in several ways, but the easiest is from the editor itself in design view. 
        We press the rotate view button <img style="vertical-align: baseline"  src="imagenes/ud4-2021-10-11-17-08-23.png" /> and select the option to create a Landscape variant. You could also create a version for a tablet, etc ...</p>


    <figure><img src="./imagenes/ud4-landscape.gif" /><br><figcaption></figcaption></figure>
    <br>

   <p>Notice that it has created the activity_main directory, with the two layouts. The suffix (land) has been added to Landscape</p>

    <figure><img src="imagenes/ud4-2021-10-11-17-10-16.png" /><br><figcaption></figcaption></figure>
    <br>

    <section class="marco-t file-">
        <span class="icono file"> </span> <span class="negrita">activity_main.xml (land)</span>
        </section>
    <section class="marco-b">
            <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    tools:context=".MainActivity">
    &lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/containerList"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight=".4"
        tools:context=".MainActivity">

    &lt;/FrameLayout>
    &lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/containerDetail"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight=".6"
        tools:context=".MainActivity">

    &lt;/FrameLayout>

&lt;/LinearLayout></code></pre>
            </section><br><br>
    </section>
    <br><br>

   
<p>The Landscape version will have two containers, the one for the list and the other for the detail.</p>
<p>Now we are going to create two blank <span class="negrita">Fragments</span> , one for the list and other for the detail. Their names could be <span class="d-word">ListFragment</span> 
     and <span class="d-word">DetailFragment</span></p>

<p>Let's go with their Layout.</p>

   <section class="marco-t file-">
       <span class="icono file"> </span> <span class="negrita">fragment_list.xml</span>
       </section>
   <section class="marco-b">
           <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.recyclerview.widget.RecyclerView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/list"
    android:name="com.cartatar.masterdetailrecyclerview.ItemFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_marginLeft="16dp"
    android:layout_marginRight="16dp"
    app:layoutManager="LinearLayoutManager"
    tools:context=".ListFragment"
    tools:listitem="@layout/fragment_item" /></code></pre>
           </section><br><br>
   </section>

   
    <p>We can see that it only contains one <span class="d-word">RecyclerView</span> , which will occupy all of its parent.</p>
    <p>Now we go to the detail.</p>

   <section class="marco-t file-">
       <span class="icono file"> </span> <span class="negrita">fragment_detail.xml</span>
       </section>
   <section class="marco-b">
           <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    &lt;ImageView
        android:id="@+id/ivPoster"
        android:layout_width="0dp"
        android:layout_height="130dp"
        android:scaleType="fitCenter"
        android:background="@color/black"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        tools:srcCompat="@tools:sample/avatars" />

    &lt;TextView
        android:id="@+id/tvSuperhero"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_marginTop="32dp"
        android:textSize="20sp"
        android:textStyle="bold"
        android:gravity="center"
        app:layout_constraintTop_toBottomOf="@+id/ivPoster"
        tools:layout_editor_absoluteX="2dp"
        tools:text="SuperHero Name" />

    &lt;TextView
        android:id="@+id/tvRealName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@+id/tvSuperhero"
        android:gravity="center"
        android:layout_marginTop="24dp"
        app:layout_constraintTop_toBottomOf="@+id/tvSuperhero"
        tools:layout_editor_absoluteX="2dp"
        tools:text="Real Name" />

    &lt;ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/tvRealName"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintRight_toRightOf="parent">
        &lt;TextView
            android:id="@+id/tvDescription"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="TextView"
            android:layout_margin="10dp"

            />

    &lt;/ScrollView>


&lt;/androidx.constraintlayout.widget.ConstraintLayout></code></pre>
           </section><br><br>
   </section>
   
<br><br>

<p>As we see in the layout above, we will have an ImageView that will contain the image and three TexViews, one for the name, another for the real name and the last one for the description.</p>
<p>The description is inside a ScrollView, to be able to scroll if the description grows a lot.</p>

<p>The data that our application will handle will be SuperHeroes, with your name, alter ego, description, and photo. Below we see the class that contains your information.</p>


<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">SuperHero.kt</span>
    </section>
<section class="marco-b">
        <section class="marco-t inf">
            <span class="icono info"> </span> <span class="negrita">Create the file inside the model folder</span>
            </section>
        <section class="marco-b">
                
        </section>
        <section><pre><code class="language-kotlin">data class Superhero(
    var id:Int,
    var superhero:String,
    var publisher:String,
    var realName:String,
    var photo:String,
    var description:String
){
    companion object{
        var listSuper:MutableList<Superhero> = ArrayList()
        fun getSuperheros(): MutableList<Superhero>{
            listSuper.clear()
            listSuper.add(Superhero(1,"Spiderman", "Marvel", "Peter Parker", "spiderman.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(2,"Daredevil", "Marvel", "Matthew Michael Murdock", "daredevil.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(3,"Wolverine", "Marvel", "James Howlett", "logan.jpeg",LoremIpsum().values.first()))
            listSuper.add(Superhero(4,"Batman", "DC", "Bruce Wayne", "batman.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(5,"Thor", "Marvel", "Thor Odinson", "thor.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(6,"Flash", "DC", "Jay Garrick", "flash.png",LoremIpsum().values.first()))
            listSuper.add(Superhero(7,"Superman", "DC", "Clark Kent", "superman.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(8,"Iron Man", "DC", "Tonny Stark", "ironman.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(9,"Green Lantern", "DC", "Alan Scott", "green_lantern.jpg",LoremIpsum().values.first()))
            listSuper.add(Superhero(10,"Wonder Woman", "DC", "Princess Diana", "wonder_woman.jpg",LoremIpsum().values.first()))
            return listSuper
        }

        fun getSuperHeroById(mId: Int?):Superhero?{
            val superhero = getSuperheros().filter { superHero ->
                superHero.id==mId
            }

            return  superhero[0]?:null
        }

        fun getFirstID():Int{
            return getSuperheros()[0].id
        }
    }
}
        </code></pre></section><br><br>
            
</section>

<p>Pay special attention to the <span class="r-word">Companion object</span> , which will act as the source of our data, in a real application the data would be obtained from the Internet or from other sources such as Databases.
    Access methods have also been created.</p>


<p>The next thing we will do is save the images in our project. For this we are going to create the <span class="d-word">RAW</span> folder within res folder. This folder is used to store images, videos, audios, that is, raw files.</p>

<figure><img src="./imagenes/ud4-raw_folder.gif" /><br><figcaption>Creating RAW resources</figcaption></figure>
<br>


<p>In this folder we paste the images, we can do it directly from the explorer</p>

<figure><img src="imagenes/ud4-2021-10-11-21-10-10.png" /><br><figcaption></figcaption></figure>
<br>

<figure><img src="imagenes/ud4-2021-10-11-21-11-08.png" /><br><figcaption></figcaption></figure>
<br>


<p>You can get images from <a class="enlace" target="_blank" href="./UD4/RecyclerViewAssets/SuperHeros.zip">here</a> </p>

<section class="marco-t warn">
    <span class="icono warning"> </span> <span class="negrita">Files' name in RAW directory must be specific.</span>
    </section>
<section class="marco-b">
    <ul>
        <li>It cannot have special characters other than the underscore "_".</li>
        <li>Capitalization is not possible.</li>
        <li>It cannot start with a number.</li>
    </ul>        
</section>

<p>To access these images from code and put them in an <span class="r-word">ImageView</span>  we first get the <span class="negrita">resource</span>.
     Note that <span class="subrayado">it is the name of the image without an extension</span> </p> 
<section><pre><code class="language-kotlin">val inputStream =context.resources.openRawResource(R.raw.batman)
//Get an inputStream por batman.jpg in RAW folder.
</code></pre></section><br><br>

<p>Then with <span class="r-word">BitmapFactory</span>  and the <span class="d-word">inputStream</span>  we get the <span class="negrita">bitmap</span> .</p>
<section><pre><code class="language-kotlin">val image = BitmapFactory.decodeStream(inputStream)
</code></pre></section><br><br>

<p>Finally we assign that <span class="d-word">Bitmap</span>  to the <span class="r-word">ImageView</span>  through its method <span class="d-word">setImageBitmap(bitmap: Bitmap)</span> </p>

<section><pre><code class="language-kotlin">ivPoster.setImageBitmap(image)
</code></pre></section><br><br>

<p>The code would look something like this:</p>
<section><pre><code class="language-kotlin">val inputStream =context.resources.openRawResource(R.raw.batman)
val image = BitmapFactory.decodeStream(inputStream)
ivPoster.setImageBitmap(image)
</code></pre></section><br><br>

<p>But of course, in this case we obtain the name of the image of a <span class="negrita">SuperHero</span>  type object in its "<span class="cursiva">photo</span>" attribute. 
    How do we obtain the <span class="d-word">RAW</span>  resource of a <span class="cursiva">String</span>?</p>
<p>One solution is using the <span class="d-word">getIdentifier(String, resType, package)</span> method. Suppose we have in the variable "<span class="negrita">imageName</span>"
     the string of the image (<span class="subrayado">remember without the extension</span>).</p>
    <p>Let's see an example:</p>

<section><pre><code class="language-kotlin">val context: Context = ivPoster.context
val id = context.resources.getIdentifier(
    imageName, //Something like "batman"
    "raw",
    context.packageName
)

val inputStream =context.resources.openRawResource(id)

//........
</code></pre></section><br><br>

<p>The <span class="d-word">context</span> can be obtained from the <span class="r-word">ImageView</span> itself.</p>

<p>Now it is necessary to create one more <span class="negrita">layout</span>. This will be the layout that will be used for <span class="subrayado">each of the elements in the list</span>.
    So we are going to create a layout type resource, called <span class = "inline-file">list_item.xml </span>
    
    <p>As already mentioned, this file will be the one that shapes each element of the list. That is, how each item will look</p>

<figure><img src="imagenes/ud4-2021-10-12-00-40-42.png" /><br><figcaption>list_item</figcaption></figure>
<br>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">list_item.xml</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?>
&lt;androidx.cardview.widget.CardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    app:cardElevation="5dp"
    android:layout_width="match_parent"
    android:layout_margin="9dp"
    app:cardCornerRadius="8dp"
    android:layout_height="wrap_content">
    &lt;androidx.constraintlayout.widget.ConstraintLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="10dp">

        &lt;ImageView
            android:id="@+id/ivPoster"
            android:layout_width="100dp"
            android:layout_height="100dp"
            android:scaleType="centerCrop"
            android:src="@mipmap/ic_launcher"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

        &lt;TextView
            android:id="@+id/tvSuperhero"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentTop="true"
            android:layout_marginStart="28dp"
            android:layout_toEndOf="@+id/ivPoster"
            android:layout_toRightOf="@+id/ivPoster"
            android:textSize="20sp"
            android:textStyle="bold"
            app:layout_constraintStart_toEndOf="@+id/ivPoster"
            app:layout_constraintTop_toTopOf="parent"
            tools:text="dadawdawdwd" />

        &lt;TextView
            android:id="@+id/tvRealName"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@+id/tvSuperhero"
            android:layout_marginTop="12dp"
            android:layout_toEndOf="@+id/ivPoster"
            android:layout_toRightOf="@+id/ivPoster"
            android:textSize="15sp"
            app:layout_constraintStart_toStartOf="@+id/tvSuperhero"
            app:layout_constraintTop_toBottomOf="@+id/tvSuperhero"
            tools:text="wdawd" />

        &lt;TextView
            android:id="@+id/tvPublisher"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentEnd="true"
            android:layout_alignParentRight="true"
            android:layout_alignParentBottom="true"
            android:layout_marginEnd="3dp"
            android:textStyle="italic"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            tools:text="DC" />
    &lt;/androidx.constraintlayout.widget.ConstraintLayout>
&lt;/androidx.cardview.widget.CardView></code></pre>
        </section><br><br>
</section>

<p>Notice how we use a <span class="r-word">CardView</span>  that allows us to give an <span class="cursiva">elevation</span>  effect and <span class="cursiva">border radius</span> .</p>
<br>
<p>Before continuing, let's create an <span class="d-word">OnItemClick</span>  interface, which will have an <span class="d-word">onItemClick (hero: SuperHero)</span> method. 
    We will use it as a <span class="negrita">callback</span>  to communicate the <span class="d-word">MainActivity</span>  with the <span class="d-word">DetailFragment</span> </p>

<br>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">OnItemClick.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">interface OnItemClick {
    fun onItemClick(hero:Superhero)
}</code></pre>
        </section><br><br>
</section>

<p>Now we are going to implement the code of the <span class="negrita">Fragments</span> . Let's start with <span class = "inline-file"> ListFragment.kt </span></p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">ListFragment.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">class ListFragment() : Fragment() {

    //property that indicates if we want to view a single item list or grid list. Used on onCreateView
    private var columnCount = 2
    
    //Listener is our callback
    var listener:OnItemClick? = null


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        //When fragment is created, "search" on its arguments a bundle with Key ARG_COLUMN_COUNT and set the property above
        arguments?.let {
            columnCount = it.getInt(ARG_COLUMN_COUNT)
        }

    }

    //When fragment is attaching to an activity, the context is the activity. Remember MainActivity Implements OnItemclick
    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnItemClick) {
            listener = context
        }
    }

    //Detach the listener. Set it to null
    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        //inflate creates a View variable from a layout resource, in this case fragment_list which is just a RecyclerView 
        val view = inflater.inflate(R.layout.fragment_list, container, false)

        // Set the adapter and the LayoutManager of the recyclerView
        if (view is RecyclerView) { //smart cast
            with(view) {
                layoutManager = when {
                    columnCount &lt;= 1 -> LinearLayoutManager(context)
                    else -> GridLayoutManager(context, columnCount)
                }
                adapter = MyItemRecyclerViewAdapter(Superhero.getSuperheros(),listener)
            }
        }
        return view
    }

    //Creating an static method to simulate factory pattern. Creates a new ListFragment, and sets countColumn param through bundle.
    companion object {
        const val ARG_COLUMN_COUNT = "column-count"

        @JvmStatic
        fun newInstance(columnCount: Int) =
            ListFragment().apply {
                arguments = Bundle().apply {
                    putInt(ARG_COLUMN_COUNT, columnCount)
                }
            }
    }

}</code></pre>
        </section><br><br>
</section>


<section><pre><code class="language-kotlin">adapter = MyItemRecyclerViewAdapter(Superhero.getSuperheros(),listener)</code></pre>
</section><br><br>

<p>
    Nothing different from other Fragments, except for the <span class="r-word">onCreateView</span>  method. This method <span class="cursiva">inflates</span> 
     the view (<span class="negrita">R.layout.fragment_list</span> )
     remembering that it is a Recyclerview. Then based on the <span class="negrita">columnCount</span>  parameters that we have passed when creating it, 
     will put a <span class="d-word">LayourManager</span>  or another in the <span class="r-word">Recyclerview</span> . <span class="r-word">LinearLayoutManager</span> 
     for a single item per row and <span class="r-word">GridLayoutManager</span> for more than one item per row.</p>
<p>Another important element of the <span class="r-word">RecyclerView</span>  are the <span class="d-word">adapters</span> . The <span class="d-word">adapters</span> 
    are the classes in charge of putting the data (usually a list) each one in its element.</p>
    <p>We must assign one. In this case one of ours (<span class="d-word">MyItemRecyclerViewAdapter</span> ).</p>
</p>
<p>This class (<span class="d-word">MyItemRecyclerViewAdapter</span> ) will be the one that uses the data from the <span class="negrita">SuperHero</span>  List and creates a new item for each item in the list, 
    and will create the indicated layout, in this case <span class="inline-file">list_item.xml</span></p>

<p>Let's see the MyItemRecyclerViewAdapter.kt class</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MyItemRecyclerViewAdapter.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">class MyItemRecyclerViewAdapter(
    private val superHeroList: List<Superhero>,
    private val listener:OnItemClick?
) : RecyclerView.Adapter&lt;MyItemRecyclerViewAdapter.ViewHolder>() {

    //Creates a ViewHolder for every item of the list (superHeroList)
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {

        return ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )

    }

    //In this function customize our ViewHolder with its data depending on the position 
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        
        val superhero = superHeroList[position]
        holder.tvSuperhero.text = superhero.superhero
        holder.tvRealName.text = superhero.realName
        holder.tvPublisher.text = superhero.publisher


        //We are using an extension toBipmap
        holder.ivPoster.setImageBitmap(superhero.photo.toBitmap(holder.ivPoster.context))

        //We set the tag with superhero data, in order to obtain its data in the listener
        holder.itemView.tag = superhero
        
        holder.itemView.setOnClickListener(holder) //Our ViewHolder implements OnClickListener
    }

    //We need to know the length of the list. It will be the size of out data list
    override fun getItemCount(): Int = superHeroList.size

    //This inner class contains all view of each item on list_item.xml
    inner class ViewHolder(binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root), View.OnClickListener {
        val tvSuperhero: TextView = binding.tvSuperhero
        val tvRealName: TextView = binding.tvRealName
        val tvPublisher: TextView = binding.tvPublisher
        val ivPoster: ImageView = binding.ivPoster

        override fun toString(): String {
            return super.toString() + " ${tvRealName.text} is ${tvSuperhero.text} from ${tvPublisher.text}"
        }

        override fun onClick(v: View?) {
            
            //First we recovery de superHero through the tag. Remember we have set it before (onBindViewHolder)
            val superHero = v?.tag as Superhero
            
            //later we call our callback with the SuperHero param to inform ListFragment, and then MainActivity
            listener?.onItemClick(superHero)
        }
    }

}</code></pre>
        </section><br><br>
</section>

<section class="marco-t warn">
    <span class="icono warning"> </span> We have made an extension in order of implementing toBipmap method in <span class="inline-file">Extensions.kt</span>.
    </section>
<section class="marco-b">
       <section><pre><code class="language-kotlin">//This function pass an string like "batman.jpg" that is in raw folder to an Bitmap
fun String.toBitmap(context:Context):Bitmap{
    val imageName = this.split(".")[0]
     val id = context.resources.getIdentifier(
         imageName,
        "raw",
        context.packageName
    )

    val inputStream =context.resources.openRawResource(id)
    return  BitmapFactory.decodeStream(inputStream)
}</code></pre>
       </section><br><br> 
</section>


<p>First we see that two objects are passed to the constructor, the data list (<span class="negrita">SuperHero</span> ) and the <span class="r-word">OnItemClick</span>  callback, to communicate with the activity when clicking on an element.</p>
<p>We also see, that the class extends from <span class="d-word">RecyclerView.Adapter&lt;MyItemRecyclerViewAdapter.ViewHolder> ()</span> </p>


<br><br><br>
<p>Now take a look to <span class="inline-file">DetailFragment.kt</span></p>
<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">DetailFragment.kt</span>
    </section>
<section class="marco-b">
        
    <section><pre><code class="language-kotlin">class DetailFragment : Fragment() {
        private var superHeroId: Int? = null
        private var superHero: Superhero? = null
    
    
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            arguments?.let {
                superHeroId = it.getInt(ARG_HERO,-1)
                superHero = Superhero.getSuperHeroById(superHeroId)
            }
        }
    
        override fun onCreateView(
            inflater: LayoutInflater, container: ViewGroup?,
            savedInstanceState: Bundle?
        ): View? {
            // Inflate the layout for this fragment
            return  inflater.inflate(R.layout.fragment_detail, container, false)
        }
    
        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
    
            view.findViewById&lt;TextView>(R.id.tvSuperhero).text = superHero?.superhero
            view.findViewById&lt;TextView>(R.id.tvRealName).text  = superHero?.realName
            view.findViewById&lt;TextView>(R.id.tvDescription).text  = superHero?.description
    
            view.findViewById&lt;ImageView>(R.id.ivPoster).setImageBitmap(superHero?.photo?.toBitmap(view.context))
    
        }
    
    
    
    
        companion object {
            @JvmStatic
            fun newInstance(heroId: Int) =
                DetailFragment().apply {
                    arguments = Bundle().apply {
                        putInt(ARG_HERO, heroId)
                    }
                }
        }
    }</code></pre>
    </section><br><br>
</section>

<p>This fragment receives an Int param which is the <span class="negrita">ID</span>  of a <span class="negrita">SuperHero</span> , 
    then on <span class="d-word">onCreate</span>  method we search the <span class="negrita">hero</span>  that corresponds to this ID</p>

    <section><pre><code class="language-kotlin">superHeroId = it.getInt(ARG_HERO,-1) //Get the incoming param
superHero = Superhero.getSuperHeroById(superHeroId)</code></pre>
    </section><br><br>

<br><br><br>


<p>Now, let's see through some images the arrangement of elements of how the different elements are going to be positioned.</p>

<figure><img src="imagenes/ud4-2021-10-12-01-16-30.png" /><br><figcaption>Layouts portrait List</figcaption></figure>
<br>
<p>First we have the <span class="d-word">MainActiviy</span>  in <span class="negrita">Portrait</span>  whose layout only has one container (<span class="cursiva">listContainer</span>), 
    in this container we will load the <span class="d-word">ListFragment</span>  or <span class="d-word">DetailFragment</span>  as the case may be.</p>
    <p>Initially we will load <span class="d-word">ListFragment</span> , and once we click on an element we will load <span class="d-word">DetailFragment</span>  with the element's data in the same <span class="cursiva">listContainer</span> .</p>

<figure><img src="imagenes/ud4-2021-10-12-01-24-03.png" /><br><figcaption>Layout potrait Detail</figcaption></figure>
<br>

<p>In the case of <span class="cursiva">landscape</span> , as the <span class="d-word">MainActivity</span>  has 2 containers (<span class="subrayado">listContainer and detailContainer</span>),
     we will load <span class="d-word">ListFragment</span>  and <span class="d-word">DetailFragment</span>  in their respective containers. 
     When starting the <span class="d-word">DetailFragment</span>  it will contain the data of the first SuperHero in the list.</p>

<figure><img src="imagenes/ud4-2021-10-12-01-21-29.png" /><br><figcaption>Layouts landscape</figcaption></figure>
<br>


<p>Finally let's see MainActivity.kt code</p>

<section class="marco-t file-">
    <span class="icono file"> </span> <span class="negrita">MainActivity.kt</span>
    </section>
<section class="marco-b">
        <section><pre><code class="language-kotlin">class MainActivity : AppCompatActivity(),OnItemClick {
    private val layoutList:FrameLayout by lazy { findViewById(R.id.containerList) }
    private val layoutDetail:FrameLayout? by lazy { findViewById(R.id.containerDetail) }
    
    
    
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)
    
            //Load ListFragment on its container. (layoutList)
            loadRecyclerView()
    
            //In the case we were in landscape we load also the DetailFragment in its container. (layoutDetail)
            if (isLandScape()){
                //We load first SuperHero
                loadDetailFragment(true, Superhero.getFirstID())
            }
        }
    
    
        private fun loadRecyclerView() {
            supportFragmentManager.beginTransaction()
                .replace(layoutList.id, ListFragment.newInstance(1))
                .addToBackStack(null)
                .commit()
        }
    
    
        /*Work around that let  us to know if we're un landscape mode*/
        private fun isLandScape():Boolean {
            return layoutDetail != null
        }
    
        
        private fun loadDetailFragment(twoPane:Boolean, heroID:Int){
            //If layoutDetail is null (we're in portrait mode) then we load DetailFragment in layoutList
            val id = layoutDetail?.id?:layoutList.id
    
            supportFragmentManager.beginTransaction()
                .replace(id, DetailFragment.newInstance(heroID))
                .addToBackStack(null)
                .commit()
        }
    
        //Callback implementation
        override fun onItemClick(hero: Superhero) {
            //We don't nee to use snackbar, which is such as an enhanced Toast where you can implement actions.
            //But I wanted to introduce it to you
            Snackbar.make(layoutList, "You have clicked on ${hero.superhero}", Snackbar.LENGTH_LONG)
                .setAction("Open"){
    
                    loadDetailFragment(isLandScape(), hero.id)
    
                }
                .show()
        }
    }</code></pre>
</section><br><br>
</section>

<p>Here some running samples</p>
<figure><img src="./imagenes/ud4-recycler_portrait.gif" /><br><figcaption>Portrait Version</figcaption></figure>
<br>

<figure><img src="./imagenes/ud4-recycler_landscape.gif" /><br><figcaption>Landscape Version</figcaption></figure>
<br>
<p>
<a class="enlace" target="_blank" href="https://github.com/sdram58/PMDM2021/tree/master/MasterDetailRecyclerView">Github link</a> 
</p>













    

    

    






    <!----------------------------------------------NavGraph------------------------------------------------------>

    <h3>Navgraph</h3>

    

    <figure><img src="./UD4/NavGraph/images/UD4-Nav_graph_creation.gif" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="./UD4/NavGraph/images/UD4-Creating_login_fragment.gif" /><br><figcaption></figcaption></figure>
    <br>
    
    
    
    
    
    </section><!-- End section -->
    

    <!--*********************************************************Navigation***********************************************************-->
    <section class="apartado">
    <a name="sNavigation"></a>
    <h2>Navigation</h2>
    
    <figure><img src="../imagenes/underconstruction.gif" /><br><figcaption>underconstruction</figcaption></figure><br><br>

    
    

    <h3>Safe args</h3>
    
    
    
    </section><!-- End section -->


    <!--*********************************************************Bonus track: Splash Screen***********************************************************-->
    <section class="apartado">
    <a name="s"></a>
    <h2>Bonus track: Splash Screen</h2>
    
    <figure><img src="../imagenes/underconstruction.gif" /><br><figcaption>underconstruction</figcaption></figure>
    <br>
    
    
    </section><!-- End section -->


    <!--*********************************************************Webgraphy***********************************************************-->
    <section class="apartado">
    <a name="sWebgrafia"></a>
    <h2>Webgraphy</h2>

    <ul>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/guide/components/activities/intro-activities">https://developer.android.com/guide/components/activities/intro-activities</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/guide/components/activities/activity-lifecycle">https://developer.android.com/guide/components/activities/activity-lifecycle</a> </li>
        <li><a class="enlace" target="_blank" href="https://medium.com/kotlin-dev-reactor/android-parcelable-en-kotlin-5514314f15e">https://medium.com/kotlin-dev-reactor/android-parcelable-en-kotlin-5514314f15e</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/training/basics/intents/filters">https://developer.android.com/training/basics/intents/filters</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/guide/components/intents-common">https://developer.android.com/guide/components/intents-common</a> </li>
        <li><a class="enlace" target="_blank" href="https://developer.android.com/guide/fragments">https://developer.android.com/guide/fragments</a> </li>
    </ul>
    
    
    
    </section><!-- End section -->

    

    <script src="../script/prism.js"></script>
</body>
</html>
