<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD1.-Kotlin's basics</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>
<body class="line-numbers">
  <h1>UD1.-Kotlin's basics</h1>
  
  <div class="main-menu">
    <a href="#s1">Why Kotlin?</a><a 
       href="#s1_1">Packets</a><a 
       href="#s2">Variable Declaration</a><a 
       href="#s3">Conditionals</a><a 
       href="#sloops">Loops</a><a 
       href="#s5">UD5.- Model-View-View-Model</a><a 
       href="#s6">UD6.- Kotlin's basics</a><a 
       href="#s7">UD7.- Kotlin's basics</a><a 
       href="#s8">UD8.- Kotlin's basics</a><a 
       href="#s9">UD9.- Kotlin's basics</a><a 
       href="#s10">UD10.- Kotlin's basics</a><a 
       class="oculto" href="./unidades/underconstruction.html">UD11.- Kotlin's basics</a>
</div>


<a name="s1"><a>
<h2>Why Kotlin?</h2>
<p>Kotlin is a modern programming language than make developers happier…</p>

<img style="width:100%" src="./imagenes/ud1/Imagen1.png" alt="Kotlin's uses" title="Kotlin's uses" />
<br><br>
<a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> 

<a name="s1_1"><a>
<h2>Packets</h2>
<p>As in Java, in Kotlin the packages are placed at the top of the file:</p>
<section><pre><code class="language-kotlin">
package com.example

import com.example.*

// ...
</code></pre></section><br><br>

<!--**********************Variable declaration **************************************-->
<a name="s2"><a>
<h2>Variable declaration</h2>

<p>
  Kotlin uses two different keywords to declare variables: <span class="r-word">val</span> and <span class="r-word">var</span> 
  <ul>
    <li>Use <span class="r-word">val</span>  for a variable whose value never changes. You <span class="negrita">can't</span>  reassign a value to a variable that was declared using val.</li>
    <li>Use <span class="r-word">var</span>  for a variable whose value can change.</li>
  </ul>
</p>

<p>In the example below, count is a variable of type Int that is assigned an initial value of 10:</p>

<section><pre><code class="language-kotlin">
var count: Int = 10
</code></pre></section>

<p><span class="r-word">Int</span>  is a type that represents an integer, one of the many numerical types that can be represented in Kotlin. Similar to other languages, you can also use Byte, Short, Long, Float, and Double depending on your numerical data.</p>

<p>The <span class="cursiva">var</span>   keyword means that you can reassign values to count as needed. For example, you can change the value of <span class="cursiva">count</span>  from 10 to 15:</p>

<section><pre><code class="language-kotlin">
var count: Int = 10
count = 15
</code></pre></section>

<br>
<p>Some values are not meant to be changed, though. Consider a String called <span class="cursiva">languageName</span>  . If you want to ensure that <span class="cursiva">languageName</span>  always holds a value of "Kotlin", then you can declare <span class="cursiva">languageName</span>  using the <span class="d-word">val</span>  keyword:</p>

<section><pre><code class="language-kotlin">
val languageName: String = "Kotlin"
</code></pre></section><br><br>

<p>These keywords allow you to be explicit about what can be changed. Use them to your advantage as needed. If a variable reference must be reassignable, then declare it as a <span class="cursiva">var</span> . Otherwise, use <span class="cursiva">val</span> .</p>

<h3>Type Inference</h3>

<br>
<p>Continuing the previous example, when you assign an initial value to <span class="cursiva">languageName</span> , the Kotlin compiler can infer the type based on the type of the assigned value.
  <br>Since the value of "Kotlin" is of type String, the compiler infers that <span class="cursiva">languageName</span>  is also a String. Note that Kotlin is a <span class="negrita">statically-typed</span>  language. This means that the type is resolved at compile time and never changes.
  <br>In the following example, <span class="cursiva">languageName</span>  is inferred as a String, so you can't call any functions that aren't part of the String class:
  </p>

  <section><pre><code class="language-kotlin">
  val languageName = "Kotlin"
  val upperCaseName = languageName.toUpperCase()
  </code></pre></section><br><br>


  <section class="marco-t err">
    <span class="icono error"> </span> <span class="negrita">Error</span>
    </section>
  <section class="marco-b">
      <section><pre><code class="language-kotlin">
  // Fails to compile
  languageName.inc()
      </code></pre></section><br><br>
  </section>
  

  <p><span class="cursiva">toUpperCase()</span>  is a function that can only be called on variables of type <span class="cursiva">String</span> . Because the Kotlin compiler has inferred <span class="cursiva">languageName</span>  as a String, you can safely call <span class="cursiva">toUpperCase(). inc()</span> , however, is an <span class="r-word">Int</span>  operator function, so it can’t be called on a <span class="cursiva">String</span> . Kotlin’s approach to type inference gives you both conciseness and type-safety.</p>


  <h3>Null Safety</h3>

  <br><br>
  <p>In some languages, a reference type variable can be declared without providing an initial explicit value. In these cases, the variables usually contain a null value. Kotlin variables can't hold null values by default. This means that the following snippet is invalid:</p>

  <section class="marco-t err">
    <span class="icono error"> </span> <span class="negrita">Error</span>
    </section>
  <section class="marco-b">
      <section><pre><code class="language-kotlin">val languageName: String? = null
      </code></pre></section><br><br>
  </section>

  <p>For a variable to hold a null value, it must be of a nullable type. You can specify a variable as being nullable by suffixing its type with <span class="d-word">?</span> , as shown in the following example:</p>

  <section><pre><code class="language-kotlin">
  val languageName: String? = null
  </code></pre></section><br><br>


  <p>With a <span class="cursiva">String?</span>  type, you can assign either a String value or null to <span class="cursiva">languageName</span>. <br> 
    You must handle nullable variables carefully or risk a dreaded <span class="cursiva">NullPointerException</span> . In Java, for example, if you attempt to invoke a method on a null value, your program crashes. <br>
    Kotlin provides a number of mechanisms for safely working with nullable variables</p>

    <a name="s3"><a>
    <h2>Conditionals</h2>

    <h3>If-else statements</h3>

    <p>Kotlin features several mechanisms for implementing conditional logic. The most common of these <span class="cursiva">is</span>  an <span class="cursiva">if-else</span>  statement. If an expression wrapped in parentheses next to an if keyword evaluates to <span class="cursiva">true</span> , then code within that branch (i.e. the immediately-following code that is wrapped in curly braces) is executed. Otherwise, the code within the <span class="cursiva">else</span>  branch is executed.</p>

    <section><pre><code class="language-kotlin">
if (count == 42) {
  println("I have the answer.")
} else {
  println("The answer eludes me.")
}
    </code></pre></section><br><br>

    <p>You can represent multiple conditions using <span class="cursiva">else if</span> . This lets you represent more granular, complex logic within a single conditional statement, as shown in the following example:</p>

    <section><pre><code class="language-kotlin">
if (count == 42) {
    println("I have the answer.")
} else if (count > 35) {
    println("The answer is close.")
} else {
    println("The answer eludes me.")
}
    </code></pre></section><br><br>


    <p>Conditional statements are useful for representing stateful logic, but you may find that you repeat yourself when writing them. In the example above, you simply print a <span class="cursiva">String</span>  in each branch. To avoid this repetition, Kotlin offers <span class="cursiva">conditional expressions</span> . The last example can be rewritten as follows:</p>

    <section><pre><code class="language-kotlin">
val answerString: String = if (count == 42) {
    "I have the answer."
} else if (count > 35) {
    "The answer is close."
} else {
    "The answer eludes me."
}

println(answerString)
    </code></pre></section><br><br>

    <h3>When</h3>

    <p><span class="r-word">when</span>  defines a conditional expression with multiple branches. It is similar to the <span class="cursiva">switch</span>  statement in C-like languages. Its simple form looks like this.</p>

    <section><pre><code class="language-kotlin">
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> { // Note the block
      print("x is neither 1 nor 2")
  }
}
    </code></pre></section><br><br>

  <p><span class="r-word">when</span> matches its argument against all branches sequentially until some branch condition is satisfied.</p> 

  <p><span class="r-word">when</span> can be used either as an expression or as a statement. If it is used as an expression, the value of the first matching branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Just like with if, each branch can be a block, and its value is the value of the last expression in the block.</p>

  <p>The <span class="cursiva">else</span>  branch is evaluated if none of the other branch conditions are satisfied. If when is used as an expression, the <span class="cursiva">else</span>  branch is <span class="negrita">mandatory</span> , unless the compiler can prove that all possible cases are covered with branch conditions, for example, with <span class="d-word">enum</span>  class entries and <span class="cursiva">sealed</span>  class subtypes).</p>

  <p>To define a common behavior for multiple cases, combine their conditions in a single line with a comma:</p>

  <section><pre><code class="language-kotlin">
  when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
  }
  </code></pre></section><br><br>


  <p>You can use arbitrary expressions (not only constants) as branch conditions</p>
  <section><pre><code class="language-kotlin">
  when (x) {
    parseInt(s) -> print("s encodes x")
    else -> print("s does not encode x")
}
  </code></pre></section><br><br>

  <p>You can also check a value for being <span class="d-word">in</span>  or <span class="d-word">!in</span>  a range or a collection:</p>

  <section><pre><code class="language-kotlin">
  when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
  </code></pre></section><br><br>

  <p>Another option is checking that a value <span class="d-word">is</span>  or <span class="d-word">!is</span>  of a particular type. Note that, due to smart casts, you can access the methods and properties of the type without any extra checks.</p>
  <section><pre><code class="language-kotlin">
  fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
  }
  </code></pre></section><br><br>

  <p><span class="r-word">when</span>  can also be used as a replacement for an <span class="cursiva">if</span> - <span class="cursiva">else if</span>  chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</p>

  <section><pre><code class="language-kotlin">
  when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
  }
  </code></pre></section><br><br>

  <p>You can capture <span class="cursiva">when</span>  subject in a variable using following syntax:</p>

  <section><pre><code class="language-kotlin">
  var x:Int = 100
    var b = when(x){
        in 1..10 -> true
        else -> false
    }
    
    println("b es $b")
  </code></pre></section><br><br>


  <!--**********************LOOPS**************************************-->
  <a name="sloops"><a>
  <h2>Loops</h2>

  <p>Kotlin's syntax for loops differs a bit from Java's.</p>

  <h3>For loops</h3>
  
  <p>Kotlin intervals would be the classic <span class="cursiva">for</span>  loops with <span class="cursiva">i</span>  in Java.</p>
  

  <section><pre><code class="language-kotlin">
  for (i in 1..3) {
    print("$i ") // "1 2 3"
  }
  </code></pre></section><br><br>

  <section><pre><code class="language-kotlin">
  for (i in 10 downTo 0 step 2) {
    print("$i ") // "10 8 6 4 2 0"
  }
  </code></pre></section><br><br>

  <p>The <span class="cursiva">for</span>  loop iterates through anything that provides an iterator. This is equivalent to the <span class="cursiva">foreach</span>  loop in languages like C#. The syntax of for is the following:</p>

  <section><pre><code class="language-kotlin">
  for (item in collection) print(item)
  </code></pre></section><br><br>

  <p>The body of <span class="cursiva">for</span>  can be a block.</p>
  <section><pre><code class="language-kotlin">
  for (item: Int in ints) {
    // ...
  }
  </code></pre></section><br><br>

  <p>A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object.</p>

  <section><pre><code class="language-kotlin">
  for (i in array.indices) {
    println(array[i])
  }
  </code></pre></section><br><br>


  <p>Alternatively, you can use the <span class="d-word">withIndex</span>  library function:</p>

  <section><pre><code class="language-kotlin">
  for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
  }
  </code></pre></section><br><br>


  <h3>While Loops</h3>

  <p><span class="cursiva">while</span>  and <span class="cursiva">do-while</span>  loops execute their body continuously while their condition is satisfied. The difference between them is the condition checking time:</p>

  <p>
    <ul>
      <li><span class="d-word">while</span> checks the condition and, if it's satisfied, executes the body and then returns to the condition check.</li>
      <li><span class="d-word">do-while</span> executes the body and then checks the condition. If it's satisfied, the loop repeats. So, the body of do-while executes at least once regardless of the condition.</li>
    </ul>
  </p>

  <section><pre><code class="language-kotlin">
  while (x > 0) {
    //Some code here
    x--    
  }

  do {
    val y = retrieveData()
  } while (y != null) // y is visible here!
  </code></pre></section><br><br>

  <h3>Break and continue in loops</h3>

  <p>Kotlin supports traditional break and continue operators in loops</p>



































  <script src="../script/prism.js"></script>
</body>
</html>
