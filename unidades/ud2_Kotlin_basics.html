<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD2.-Kotlin's basics</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>
<body class="line-numbers">
  <h1>UD2.-Kotlin's basics</h1>
  
  <div class="main-menu">
    <a href="#s1">Why Kotlin?</a><a 
       href="#s1_1">Packets</a><a 
       href="#s2">Variable Declaration</a><a 
       href="#s3">Conditionals</a><a 
       href="#sloops">Loops</a><a 
       href="#sFunciones">Functions</a><a 
       href="#sClasses">Classes and Objects</a><a 
       class="oculto" href="#s6">UD6.- Kotlin's basics</a><a 
       class="oculto" href="#s7">UD7.- Kotlin's basics</a><a 
       class="oculto" href="#s8">UD8.- Kotlin's basics</a><a 
       class="oculto" href="#s9">UD9.- Kotlin's basics</a><a 
       class="oculto" href="#s10">UD10.- Kotlin's basics</a><a 
       class="oculto" href="./unidades/underconstruction.html">UD11.- Kotlin's basics</a>
</div>


<a name="s1"><a>
<h2>Why Kotlin?</h2>
<p>Kotlin is a modern programming language than make developers happier…</p>

<img style="width:100%" src="./imagenes/ud1/Imagen1.png" alt="Kotlin's uses" title="Kotlin's uses" />
<br><br>
<a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> 

<a name="s1_1"><a>
<h2>Packets</h2>
<p>As in Java, in Kotlin the packages are placed at the top of the file:</p>
<section><pre><code class="language-kotlin">
package com.example

import com.example.*

// ...
</code></pre></section><br><br>

<!--**********************Variable declaration **************************************-->
<a name="s2"><a>
<h2>Variable declaration</h2>

<p>
  Kotlin uses two different keywords to declare variables: <span class="r-word">val</span> and <span class="r-word">var</span> 
  <ul>
    <li>Use <span class="r-word">val</span>  for a variable whose value never changes. You <span class="negrita">can't</span>  reassign a value to a variable that was declared using val.</li>
    <li>Use <span class="r-word">var</span>  for a variable whose value can change.</li>
  </ul>
</p>

<p>In the example below, count is a variable of type Int that is assigned an initial value of 10:</p>

<section><pre><code class="language-kotlin">
var count: Int = 10
</code></pre></section>

<p><span class="r-word">Int</span>  is a type that represents an integer, one of the many numerical types that can be represented in Kotlin. Similar to other languages, you can also use Byte, Short, Long, Float, and Double depending on your numerical data.</p>

<p>The <span class="cursiva">var</span>   keyword means that you can reassign values to count as needed. For example, you can change the value of <span class="cursiva">count</span>  from 10 to 15:</p>

<section><pre><code class="language-kotlin">
var count: Int = 10
count = 15
</code></pre></section>

<br>
<p>Some values are not meant to be changed, though. Consider a String called <span class="cursiva">languageName</span>  . If you want to ensure that <span class="cursiva">languageName</span>  always holds a value of "Kotlin", then you can declare <span class="cursiva">languageName</span>  using the <span class="d-word">val</span>  keyword:</p>

<section><pre><code class="language-kotlin">
val languageName: String = "Kotlin"
</code></pre></section><br><br>

<p>These keywords allow you to be explicit about what can be changed. Use them to your advantage as needed. If a variable reference must be reassignable, then declare it as a <span class="cursiva">var</span> . Otherwise, use <span class="cursiva">val</span> .</p>

<h3>Type Inference</h3>

<br>
<p>Continuing the previous example, when you assign an initial value to <span class="cursiva">languageName</span> , the Kotlin compiler can infer the type based on the type of the assigned value.
  <br>Since the value of "Kotlin" is of type String, the compiler infers that <span class="cursiva">languageName</span>  is also a String. Note that Kotlin is a <span class="negrita">statically-typed</span>  language. This means that the type is resolved at compile time and never changes.
  <br>In the following example, <span class="cursiva">languageName</span>  is inferred as a String, so you can't call any functions that aren't part of the String class:
  </p>

  <section><pre><code class="language-kotlin">
  val languageName = "Kotlin"
  val upperCaseName = languageName.toUpperCase()
  </code></pre></section><br><br>


  <section class="marco-t err">
    <span class="icono error"> </span> <span class="negrita">Error</span>
    </section>
  <section class="marco-b">
      <section><pre><code class="language-kotlin">
  // Fails to compile
  languageName.inc()
      </code></pre></section><br><br>
  </section>
  

  <p><span class="cursiva">toUpperCase()</span>  is a function that can only be called on variables of type <span class="cursiva">String</span> . Because the Kotlin compiler has inferred <span class="cursiva">languageName</span>  as a String, you can safely call <span class="cursiva">toUpperCase(). inc()</span> , however, is an <span class="r-word">Int</span>  operator function, so it can’t be called on a <span class="cursiva">String</span> . Kotlin’s approach to type inference gives you both conciseness and type-safety.</p>


  <h3>Null Safety</h3>

  <br><br>
  <p>In some languages, a reference type variable can be declared without providing an initial explicit value. In these cases, the variables usually contain a null value. Kotlin variables can't hold null values by default. This means that the following snippet is invalid:</p>

  <section class="marco-t err">
    <span class="icono error"> </span> <span class="negrita">Error</span>
    </section>
  <section class="marco-b">
      <section><pre><code class="language-kotlin">val languageName: String? = null
      </code></pre></section><br><br>
  </section>

  <p>For a variable to hold a null value, it must be of a nullable type. You can specify a variable as being nullable by suffixing its type with <span class="d-word">?</span> , as shown in the following example:</p>

  <section><pre><code class="language-kotlin">
  val languageName: String? = null
  </code></pre></section><br><br>


  <p>With a <span class="cursiva">String?</span>  type, you can assign either a String value or null to <span class="cursiva">languageName</span>. <br> 
    You must handle nullable variables carefully or risk a dreaded <span class="cursiva">NullPointerException</span> . In Java, for example, if you attempt to invoke a method on a null value, your program crashes. <br>
    Kotlin provides a number of mechanisms for safely working with nullable variables</p>

    <a name="s3"><a>
    <h2>Conditionals</h2>

    <h3>If-else statements</h3>

    <p>Kotlin features several mechanisms for implementing conditional logic. The most common of these <span class="cursiva">is</span>  an <span class="cursiva">if-else</span>  statement. If an expression wrapped in parentheses next to an if keyword evaluates to <span class="cursiva">true</span> , then code within that branch (i.e. the immediately-following code that is wrapped in curly braces) is executed. Otherwise, the code within the <span class="cursiva">else</span>  branch is executed.</p>

    <section><pre><code class="language-kotlin">
if (count == 42) {
  println("I have the answer.")
} else {
  println("The answer eludes me.")
}
    </code></pre></section><br><br>

    <p>You can represent multiple conditions using <span class="cursiva">else if</span> . This lets you represent more granular, complex logic within a single conditional statement, as shown in the following example:</p>

    <section><pre><code class="language-kotlin">
if (count == 42) {
    println("I have the answer.")
} else if (count > 35) {
    println("The answer is close.")
} else {
    println("The answer eludes me.")
}
    </code></pre></section><br><br>


    <p>Conditional statements are useful for representing stateful logic, but you may find that you repeat yourself when writing them. In the example above, you simply print a <span class="cursiva">String</span>  in each branch. To avoid this repetition, Kotlin offers <span class="cursiva">conditional expressions</span> . The last example can be rewritten as follows:</p>

    <section><pre><code class="language-kotlin">
val answerString: String = if (count == 42) {
    "I have the answer."
} else if (count > 35) {
    "The answer is close."
} else {
    "The answer eludes me."
}

println(answerString)
    </code></pre></section><br><br>

    <h3>When</h3>

    <p><span class="r-word">when</span>  defines a conditional expression with multiple branches. It is similar to the <span class="cursiva">switch</span>  statement in C-like languages. Its simple form looks like this.</p>

    <section><pre><code class="language-kotlin">
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> { // Note the block
      print("x is neither 1 nor 2")
  }
}
    </code></pre></section><br><br>

  <p><span class="r-word">when</span> matches its argument against all branches sequentially until some branch condition is satisfied.</p> 

  <p><span class="r-word">when</span> can be used either as an expression or as a statement. If it is used as an expression, the value of the first matching branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Just like with if, each branch can be a block, and its value is the value of the last expression in the block.</p>

  <p>The <span class="cursiva">else</span>  branch is evaluated if none of the other branch conditions are satisfied. If when is used as an expression, the <span class="cursiva">else</span>  branch is <span class="negrita">mandatory</span> , unless the compiler can prove that all possible cases are covered with branch conditions, for example, with <span class="d-word">enum</span>  class entries and <span class="cursiva">sealed</span>  class subtypes).</p>

  <p>To define a common behavior for multiple cases, combine their conditions in a single line with a comma:</p>

  <section><pre><code class="language-kotlin">
  when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
  }
  </code></pre></section><br><br>


  <p>You can use arbitrary expressions (not only constants) as branch conditions</p>
  <section><pre><code class="language-kotlin">
  when (x) {
    parseInt(s) -> print("s encodes x")
    else -> print("s does not encode x")
}
  </code></pre></section><br><br>

  <p>You can also check a value for being <span class="d-word">in</span>  or <span class="d-word">!in</span>  a range or a collection:</p>

  <section><pre><code class="language-kotlin">
  when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
  </code></pre></section><br><br>

  <p>Another option is checking that a value <span class="d-word">is</span>  or <span class="d-word">!is</span>  of a particular type. Note that, due to smart casts, you can access the methods and properties of the type without any extra checks.</p>
  <section><pre><code class="language-kotlin">
  fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
  }
  </code></pre></section><br><br>

  <p><span class="r-word">when</span>  can also be used as a replacement for an <span class="cursiva">if</span> - <span class="cursiva">else if</span>  chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</p>

  <section><pre><code class="language-kotlin">
  when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
  }
  </code></pre></section><br><br>

  <p>You can capture <span class="cursiva">when</span>  subject in a variable using following syntax:</p>

  <section><pre><code class="language-kotlin">
  var x:Int = 100
    var b = when(x){
        in 1..10 -> true
        else -> false
    }
    
    println("b es $b")
  </code></pre></section><br><br>


  <!--**********************LOOPS**************************************-->
  <a name="sloops"><a>
  <h2>Loops</h2>

  <p>Kotlin's syntax for loops differs a bit from Java's.</p>

  <h3>For loops</h3>
  
  <p>Kotlin intervals would be the classic <span class="cursiva">for</span>  loops with <span class="cursiva">i</span>  in Java.</p>
  

  <section><pre><code class="language-kotlin">
  for (i in 1..3) {
    print("$i ") // "1 2 3"
  }
  </code></pre></section><br><br>

  <section><pre><code class="language-kotlin">
  for (i in 10 downTo 0 step 2) {
    print("$i ") // "10 8 6 4 2 0"
  }
  </code></pre></section><br><br>

  <p>The <span class="cursiva">for</span>  loop iterates through anything that provides an iterator. This is equivalent to the <span class="cursiva">foreach</span>  loop in languages like C#. The syntax of for is the following:</p>

  <section><pre><code class="language-kotlin">
  for (item in collection) print(item)
  </code></pre></section><br><br>

  <p>The body of <span class="cursiva">for</span>  can be a block.</p>
  <section><pre><code class="language-kotlin">
  for (item: Int in ints) {
    // ...
  }
  </code></pre></section><br><br>

  <p>A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object.</p>

  <section><pre><code class="language-kotlin">
  for (i in array.indices) {
    println(array[i])
  }
  </code></pre></section><br><br>


  <p>Alternatively, you can use the <span class="d-word">withIndex</span>  library function:</p>

  <section><pre><code class="language-kotlin">
  for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
  }
  </code></pre></section><br><br>


  <h3>While Loops</h3>

  <p><span class="cursiva">while</span>  and <span class="cursiva">do-while</span>  loops execute their body continuously while their condition is satisfied. The difference between them is the condition checking time:</p>

  <p>
    <ul>
      <li><span class="d-word">while</span> checks the condition and, if it's satisfied, executes the body and then returns to the condition check.</li>
      <li><span class="d-word">do-while</span> executes the body and then checks the condition. If it's satisfied, the loop repeats. So, the body of do-while executes at least once regardless of the condition.</li>
    </ul>
  </p>

  <section><pre><code class="language-kotlin">
  while (x > 0) {
    //Some code here
    x--    
  }

  do {
    val y = retrieveData()
  } while (y != null) // y is visible here!
  </code></pre></section><br><br>

  <h3>Repeat</h3>
  <p>The <span class="d-word">repeat()</span>  statement starts with the word <span class="negrita">repeat</span> , followed by <span class="negrita">()</span>.</p>
  <ul>
    <li>Inside the parentheses <span class="d-word">()</span>  is the number of repetitions,</li>
    <li>followed by curly braces <span class="d-word">{}</span> ,</li>
    <li>and inside the curly braces <span class="d-word">{}</span> , is the code to repeat.</li>
  </ul>

  <section><pre><code class="language-kotlin">
  fun main() {
    repeat(5){
        println("Hello World")
    }
  }
  </code></pre></section><br><br>

  <figure><img src="imagenes/ud2-2021-09-14-11-59-27.png" /><br><figcaption>Repeat Hello World 5 times</figcaption></figure>
  <br>
  <br>


  


  <h3>Break and continue in loops</h3>

  <p>Kotlin supports traditional break and continue operators in loops.</p>
  <p>Kotlin has three structural jump expressions</p>
  <ul>
    <li><span class="d-word">return</span>  by default returns from the nearest enclosing function or <span class="negrita">anonymous function</span> </li>
    <li><span class="d-word">break</span>  terminates the nearest enclosing loop</li>
    <li><span class="d-word">continue</span>  proceeds to the next step of the nearest enclosing loop</li>
  </ul>
  <p>All of these expressions can be used as part of larger expressions:</p>

  <section><pre><code class="language-kotlin">
  val s = person.name ?: return
  </code></pre></section><br><br>

  <p>The type of these expressions is the <a class="enlace" target="_blank" href="https://kotlinlang.org/docs/exceptions.html#the-nothing-type">Nothing type</a> .</p>

  <p class="sub-section">Break and continue labels</p>
  
  <p>Any expression in Kotlin may be marked with a label. Labels have the form of an identifier followed by the <span class="d-word">@</span>  sign, for example: <span class="cursiva">abc@, fooBar@</span>. 
    To label an expression, just add a label in front of it.</p>

<section><pre><code class="language-kotlin">
loop@ for (i in 1..100) {
    // ...
}
</code></pre></section><br><br>

<p>Now, we can qualify a <span class="d-word">break</span>  or a <span class="d-word">continue</span>  with a label:</p>

<section><pre><code class="language-kotlin">
  fun main() {
    

    loop@ for (i in 1..10) {
          for (j in 1..5) {
              if (i%2==0 && j==2) break@loop
              println("${i} - ${j}")
          }
      }
      //Prints
      //1 - 1
      //1 - 2
      //1- 3
      //1 - 4
      //1 - 5
      //2 - 1
      
  }
</code></pre></section><br><br>

<p>A <span class="d-word">break</span>  qualified with a label jumps to the execution point right after the loop marked with that label. 
  A <span class="d-word">continue</span>  proceeds to the next iteration of that loop.</p>

<p class="sub-section">Return at labels</p>
<p>With function literals, local functions and object expressions, functions can be nested in Kotlin. 
  Qualified <span class="d-word">return</span> allow us to return from an outer function. 
  The most important use case is returning from a lambda expression. Recall that when we write this:</p>

<section><pre><code class="language-kotlin">
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // non-local return directly to the caller of foo()
        print(it)
    }
    println("this point is unreachable")
}
</code></pre></section><br><br>

<p>The <span class="d-word">return</span>  -expression returns from the nearest enclosing function - foo. 
  Note that such non-local returns are <span class="negrita">supported only for lambda expressions</span>  passed to inline functions. 
  To return from a lambda expression, label it and qualify the return:</p>

<section><pre><code class="language-kotlin">
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with explicit label")
}
</code></pre></section><br><br>

<p>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use <span class="cursiva">implicit labels</span>: 
  such a label has the same name as the function to which the lambda is passed.</p>

<section><pre><code class="language-kotlin">
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with implicit label")
}
</code></pre></section><br><br>

<p>Alternatively, you can replace the lambda expression with an anonymous function. A <span class="d-word">return</span> 
  statement in an anonymous function will return from the anonymous function itself.</p>

<section><pre><code class="language-kotlin">
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // local return to the caller of the anonymous function - the forEach loop
        print(value)
    })
    print(" done with anonymous function")
}
</code></pre></section><br><br>

<p>Note that the use of local returns in previous three examples is similar to the use of <span class="d-word">continue</span>  in regular loops. 
  There is no direct equivalent for <span class="d-word">break</span> , but it can be simulated by adding another 
  nesting lambda and non-locally returning from it:</p>

<section><pre><code class="language-kotlin">
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // non-local return from the lambda passed to run
            print(it)
        }
    }
    print(" done with nested loop")
}
</code></pre></section><br><br>

<p>
  When returning a value, the parser gives preference to the qualified return:

<section><pre><code class="language-kotlin">
return@a 1
</code></pre></section><br><br>

This means "return <span class="d-word">1</span>  at label <span class="d-word"> @a</span> " and not "return a labeled expression (@a 1)".
</p>

<!--************************Functions**************************-->
<a name="sFunciones"><a>
<h2>Functions</h2>

<p>Kotlin functions are declared using the <span class="d-word">fun</span> keyword:</p>

<section><pre><code class="language-kotlin">
fun double(x: Int): Int {
    return 2 * x
}
</code></pre></section><br><br>

<h3>Function Usage</h3>

<p>Functions are called using the standard approach:</p>

<section><pre><code class="language-kotlin">
val result = double(2)
</code></pre></section><br><br>

<p>Calling member functions uses dot notation:</p>

<section><pre><code class="language-kotlin">
Stream().read() // create instance of class Stream and call read()
</code></pre></section><br><br>

<h3>Parameters</h3>

<p>Function parameters are defined using <span class="cursiva">Pascal</span>  notation - name: <span class="cursiva">type</span> . 
  Parameters are separated using commas, and each parameter must be explicitly typed:</p>

<section><pre><code class="language-kotlin">
fun powerOf(number: Int, exponent: Int): Int { /*...*/ }
</code></pre></section><br><br>

<p>You can use a trailing comma when you declare function parameters:</p>

<section><pre><code class="language-kotlin">
fun powerOf(
    number: Int,
    exponent: Int, // trailing comma
) { /*...*/ }
</code></pre></section><br><br>

<h3>Default arguments</h3>

<p>Function parameters can have default values, which are used when you skip the corresponding argument. 
  This reduces the number of overloads:</p>

<section><pre><code class="language-kotlin">
fun read(
    b: ByteArray,
    off: Int = 0,
    len: Int = b.size,
) { /*...*/ }
</code></pre></section><br><br>

<p>A default value is defined using = after the type.</p>

<p>Overriding methods always use the same default parameter values as the base method. 
  When overriding a method that has default parameter values, the default parameter values must be omitted from the signature:</p>

<section><pre><code class="language-kotlin">
open class A {
    open fun foo(i: Int = 10) { /*...*/ }
}

class B : A() {
    override fun foo(i: Int) { /*...*/ }  // No default value is allowed.
}
</code></pre></section><br><br>

<p>if a default parameter precedes a parameter with no default value, 
  the default value can only be used by calling the function with named arguments:</p>

<section><pre><code class="language-kotlin">
fun foo(
    bar: Int = 0,
    baz: Int,
) { /*...*/ }

foo(baz = 1) // The default value bar = 0 is used
</code></pre></section><br><br>

<p>If the last argument after default parameters is a lambda, you can pass it either as a named argument or outside the parentheses:</p>

<section><pre><code class="language-kotlin">
fun foo(
    bar: Int = 0,
    baz: Int = 1,
    qux: () -> Unit,
) { /*...*/ }

foo(1) { println("hello") }     // Uses the default value baz = 1
foo(qux = { println("hello") }) // Uses both default values bar = 0 and baz = 1
foo { println("hello") }        // Uses both default values bar = 0 and baz = 1
</code></pre></section><br><br>

<h3>Named Arguments</h3>
<p>When calling a function, you can name one or more of its arguments. 
  This can be helpful when a function has many arguments and it's difficult to associate a value with an argument, 
  especially if it's a boolean or <span class="d-word">null</span>  value.</p>

<p>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values, 
  you can just leave these arguments out altogether.</p>

<p>Consider the following function, <span class="d-word">reformat()</span> , which has 4 arguments with default values.</p>

<section><pre><code class="language-kotlin">
fun reformat(
    str: String,
    normalizeCase: Boolean = true,
    upperCaseFirstLetter: Boolean = true,
    divideByCamelHumps: Boolean = false,
    wordSeparator: Char = ' ',
) { /*...*/ }
</code></pre></section><br><br>

<p>When calling this function, you don’t have to name all its arguments:</p>

reformat(
    "String!",
    false,
    upperCaseFirstLetter = false,
    divideByCamelHumps = true,
    '_'
)

<p>You can skip all the ones with default values:</p>

<section><pre><code class="language-kotlin">
reformat("This is a long String!")
</code></pre></section><br><br>

<p>You are also able to skip specific arguments with default values, rather than omitting them all. 
  However, after the first skipped argument, you must name all subsequent arguments:</p>

<section><pre><code class="language-kotlin">
reformat("This is a short String!", upperCaseFirstLetter = false, wordSeparator = '_')
</code></pre></section><br><br>

<h3>Unit-returning functions</h3>

<p>If a function does not return a useful value, its return type is <span class="d-word">Unit</span> . <span class="d-word">Unit</span> 
   is a type with only one value - <span class="d-word">Unit</span> . This value does not have to be returned explicitly:</p>

<section><pre><code class="language-kotlin">
fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello $name")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
</code></pre></section><br><br>

<p>The <span class="d-word">Unit</span>  return type declaration is also optional. The above code is equivalent to:</p>

<section><pre><code class="language-kotlin">
fun printHello(name: String?) { ... }
</code></pre></section><br><br>


<h3>Single-expression functions</h3>

<p>When a function returns a single expression, the curly braces can be omitted and the body is specified after a <span class="d-word">=</span>  symbol:</p>

<section><pre><code class="language-kotlin">
fun double(x: Int): Int = x * 2
</code></pre></section><br><br>

<p>Explicitly declaring the return type is optional when this can be inferred by the compiler:</p>

<section><pre><code class="language-kotlin">
fun double(x: Int) = x * 2
</code></pre></section><br><br>

<h3>Variable number of arguments (varargs)</h3>

<p>You can mark a parameter of a function (usually the last one) with the vararg modifier:</p>

<section><pre><code class="language-kotlin">
fun &lt;T&gt; asList(vararg ts: T): List&lt;T> {
    val result = ArrayList&lt;T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
</code></pre></section><br><br>

<p>In this case, you can pass a variable number of arguments to the function:</p>

<section><pre><code class="language-kotlin">
val list = asList(1, 2, 3)
</code></pre></section><br><br>

<p>Inside a function, a <span class="d-word">vararg</span>  -parameter of type <span class="d-word">T</span> 
  is visible as an array of <span class="d-word">T</span> , as in the example above, where the ts variable has type <span class="d-word">Array&lt;out T></span> .</p>

  <p>Only one parameter can be marked as <span class="d-word">vararg</span> . If a <span class="d-word">vararg</span>  parameter is not the last one in the list, 
    values for the subsequent parameters can be passed using named argument syntax, or, if the parameter has a function type, 
    by passing a lambda outside the parentheses.</p>

  <p>When you call a <span class="d-word">vararg</span>-function, you can pass arguments individually, 
    for example <span class="d-word">asList(1, 2, 3)</span> . If you already have an array and want to pass its contents to the function, 
    use the spread operator (prefix the array with <span class="d-word">*</span> ):</p>
  
<section><pre><code class="language-kotlin">
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
</code></pre></section><br><br>

<h3>Function scope</h3>

<p>Kotlin functions can be declared at the top level in a file, meaning you do not need to create a class to hold a function, 
  which you are required to do in languages such as Java, C#, and Scala. 
  In addition to top level functions, Kotlin functions can also be declared locally as <span class="negrita">member</span>  functions and <span class="negrita">extension</span>  functions.</p>


<p class="sub-section">Local functions</p>

<p>Kotlin supports local functions, which are functions <span class="negrita">inside</span> other functions:</p>

<section><pre><code class="language-kotlin">
fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
</code></pre></section><br><br>

<p>A local function can access local variables of outer functions (the closure). In the case above, visited can be a local variable:</p>

<section><pre><code class="language-kotlin">
fun dfs(graph: Graph) {
    val visited = HashSet<Vertex>()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
</code></pre></section><br><br>

<p class="sub-section">Member functions</p>

<p>A member function is a function that is defined inside a class or object:</p>

<section><pre><code class="language-kotlin">
class Sample {
    fun foo() { print("Foo") }
}
</code></pre></section><br><br>

<p>Member functions are called with dot notation:</p>

<section><pre><code class="language-kotlin">
Sample().foo() // creates instance of class Sample and calls foo
</code></pre></section><br><br>


<h3>Generic functions</h3>

<p>Functions can have generic parameters, which are specified using angle brackets before the function name:</p>

<section><pre><code class="language-kotlin">
fun &lt;T> singletonList(item: T): List&lt;T> { /*...*/ }
</code></pre></section><br><br>

<h3>Tail recursive functions</h3>
<p>Kotlin supports a style of functional programming known as <span class="cursiva">tail recursion</span>. 
  For some algorithms that would normally use loops, you can use a recursive function instead without the risk of stack overflow. 
  When a function is marked with the <span class="d-word">tailrec</span>  modifier and meets the required formal conditions, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</p>

<section><pre><code class="language-kotlin">
val eps = 1E-10 // "good enough", could be 10^-15

tailrec fun findFixPoint(x: Double = 1.0): Double =
    if (Math.abs(x - Math.cos(x)) &lt; eps) x else findFixPoint(Math.cos(x))
</code></pre></section><br><br>


<p>This code calculates the <span class="d-word">fixpoint</span>  of cosine, which is a mathematical constant. 
  It simply calls <span class="d-word">Math.cos</span>  repeatedly starting at 1.0 until the result no longer changes, yielding a 
  result of <span class="d-word">0.7390851332151611</span>  for the specified <span class="d-word">eps</span>  precision. 
  The resulting code is equivalent to this more traditional style:</p>

<section><pre><code class="language-kotlin">
val eps = 1E-10 // "good enough", could be 10^-15

private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (Math.abs(x - y) < eps) return x
        x = Math.cos(x)
    }
}
</code></pre></section><br><br>

<p>To be eligible for the <span class="d-word">tailrec</span>  modifier, a function must call itself as the last operation it performs. 
  You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within <span class="d-word">try/ catch/ finally</span>  blocks. Currently, tail recursion is supported by Kotlin for the JVM and Kotlin/Native.</p>


<h3>High-order functions and lambdas</h3>

<p>Kotlin functions are <span class="cursiva">first-class</span> , which means they can be stored in <span class="negrita">variables</span>  and <span class="negrita">data structures</span> 
  , and can be passed as arguments to and returned from other <span class="d-word">higher-order</span>  functions. 
  You can perform any operations on functions that are possible for other non-function values.</p>

<p>To facilitate this, Kotlin, as a statically typed programming language, uses a family of function types to represent functions, 
  and provides a set of specialized language constructs, such as lambda expressions.</p>

<p class="sub-section">Higher-order functions</p>

<p>A <span class="d-word">higher-order</span> function is a function that takes functions as parameters, or returns a function.</p>



<p class="sub-section">Function Types</p>

<p>Kotlin uses function types, such as <span class="d-word">(Int) -> String</span> , for declarations that deal with functions: 
  <span class="d-word">val onClick: () -> Unit = ....</span> </p>

<p>These types have a special notation that corresponds to the signatures of the functions - their parameters and return values:</p>

<p>All function types have a parenthesized list of parameter types and a return type: <span class="d-word">(A, B) -> C</span>  denotes a 
  type that represents functions that take two arguments of types <span class="d-word">A</span>  and <span class="d-word">B</span>  and return a value of type <span class="d-word">C</span> . 
  The list of parameter types may be empty, as in <span class="d-word">() -> A</span> . The <span class="d-word">Unit</span>  return type cannot be omitted.</p>

<p>Function types can optionally have an additional receiver type, which is specified before the dot in the notation: the type <span class="d-word">A.(B) -> C</span> 
  represents functions that can be called on a receiver object <span class="d-word">A</span>  with a parameter <span class="d-word">B</span>  and return a value <span class="d-word">C</span> . Function literals with receiver are often used along with these types.</p>

<p>Suspending functions belong to a special kind of function type that have a suspend modifier in their notation, 
  such as suspend <span class="d-word">() -> Unit</span>  or suspend <span class="d-word">A.(B) -> C</span> .</p>










<!--************************Classes and objects**************************-->
<a name="sClasses"><a>
<h2>Classes and objects</h2>

<h3>Classes</h3>

<p>Classes in Kotlin are declared using the keyword <span class="d-word">class</span> :</p>

<section><pre><code class="language-kotlin">
class Person { /*...*/ }
</code></pre></section><br><br>

The <span class="cursiva">class</span>  declaration consists of the class name, the class header (specifying its type parameters, the primary constructor, and some other things), 
and the class body surrounded by curly braces. Both the header and the body are optional; if the class has no body, the curly braces can be omitted.

<section><pre><code class="language-kotlin">
class Empty
</code></pre></section><br><br>

<h3>Constructors</h3>

<p>A <span class="cursiva">class</span>  in Kotlin can have a primary constructor and one or more secondary constructors. 
  <span class="negrita">The primary constructor</span>  is a part of the class header, and it goes after the class name and optional type parameters.</p>

<section><pre><code class="language-kotlin">
class Person constructor(firstName: String) { /*...*/ }
</code></pre></section><br><br>

If the primary constructor does not have any annotations or visibility modifiers, the constructor keyword <span class="negrita">can be omitted</span> :

<section><pre><code class="language-kotlin">
class Person(firstName: String) { /*...*/ }
</code></pre></section><br><br>

<p>The primary constructor cannot contain any code. Initialization code can be placed in <span class="cursiva">initializer blocks</span>  prefixed with the <span class="d-word">init</span>  keyword.</p>

<p>During the initialization of an instance, the initializer blocks are executed in the same order as they appear in the class body, 
  interleaved with the property initializers:</p>
<section><pre><code class="language-kotlin">
class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}
</code></pre></section><br><br>

<p>Primary constructor parameters can be used in the initializer blocks. They can also be used in property initializers declared in the class body:</p>

<section><pre><code class="language-kotlin">
class Customer(name: String) {
    val customerKey = name.uppercase()
}
</code></pre></section><br><br>

<p>Kotlin has a concise syntax for declaring properties and initializing them from the primary constructor:</p>

<section><pre><code class="language-kotlin">
class Person(val firstName: String, val lastName: String, var age: Int)
</code></pre></section><br><br>

<p>Such declarations can also include default values of the class properties:</p>

<section><pre><code class="language-kotlin">
class Person(val firstName: String, val lastName: String, var isEmployed: Boolean = true)
</code></pre></section><br><br>

<p>You can use a trailing comma when you declare class properties:</p>

<section><pre><code class="language-kotlin">
class Person(
    val firstName: String,
    val lastName: String,
    var age: Int, // trailing comma
) { /*...*/ }
</code></pre></section><br><br>

<p>Much like regular properties, properties declared in the primary constructor can be mutable (<span class="d-word">var</span>) or read-only (<span class="d-word">val</span>).</p>

If the <span class="cursiva">constructor</span> has annotations or visibility modifiers, the <span class="d-word">constructor</span>  keyword is required and the modifiers go before it:

<section><pre><code class="language-kotlin">
class Customer public @Inject constructor(name: String) { /*...*/ }
</code></pre></section><br><br>

<p class="sub-section">Secondary constructors</p>

<p>A class can also declare <span class="cursiva">secondary constructors</span> , which are prefixed with constructor:</p>

<section><pre><code class="language-kotlin">
class Person(val pets: MutableList<Pet> = mutableListOf())

class Pet {
    constructor(owner: Person) {
        owner.pets.add(this) // adds this pet to the list of its owner's pets
    }
}
</code></pre></section><br><br>

<p>If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, 
  either directly or indirectly through another secondary constructor(s). 
  Delegation to another constructor of the same class is done using the <span class="d-word">this</span>  keyword:</p>

<section><pre><code class="language-kotlin">
class Person(val name: String) {
    var children: MutableList<Person> = mutableListOf()
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
</code></pre></section><br><br>

<p>Code in initializer blocks effectively becomes part of the primary constructor. 
  Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and 
  property initializers is executed before the body of the secondary constructor.</p>

<p>Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</p>

<section><pre><code class="language-kotlin">
class Constructors {
    init {
        println("Init block")
    }
​
    constructor(i: Int) {
        println("Constructor $i")
    }
}
</code></pre></section><br><br>

<p>If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be <span class="negrita">public</span> .</p>


If you don't want your class to have a public constructor, declare an empty primary constructor with non-default visibility:

<section><pre><code class="language-kotlin">
class DontCreateMe private constructor () { /*...*/ }
</code></pre></section><br><br>

<p class="sub-section">Creating instances of classes</p>

<p>To create an instance of a class, call the constructor as if it were a regular function:</p>

<section><pre><code class="language-kotlin">
val invoice = Invoice()

val customer = Customer("Joe Smith")
</code></pre></section><br><br>

<section class="marco-t inf">
  <span class="icono info"> </span> <span class="negrita">Kotlin does not have a <span class="d-word">new</span> keyword.</span>
  </section>
<section class="marco-b">
    
</section>

<p class="sub-section">Class members</p>

<p>Classes can contain:</p>
<ul>
    <li>Constructors and initializer blocks</li>
    <li>Functions</li>
    <li>Properties</li>
    <li>Nested and inner classes</li>
    <li>Object declarations</li>
</ul>

<p class="sub-section">Abstract classes</p>

<p>A class may be declared <span class="d-word">abstract</span> , along with some or all of its members.
  An abstract member does not have an implementation in its class.</p>

<section><pre><code class="language-kotlin">
abstract class Polygon {
    abstract fun draw()
}

class Rectangle : Polygon() {
    override fun draw() {
        // draw the rectangle
    }
}
</code></pre></section><br><br>

<p>You can override a <span class="cursiva">non-abstract</span>  <span class="d-word">open</span>  member with an abstract one.</p>

<section><pre><code class="language-kotlin">
open class Polygon {
    open fun draw() {
        // some default polygon drawing method
    }
}

abstract class WildShape : Polygon() {
    // Classes that inherit WildShape need to provide their own
    // draw method instead of using the default on Polygon
    abstract override fun draw()
}
</code></pre></section><br><br>

<h3>Inheritance</h3>

<p>All classes in Kotlin have a common superclass, <span class="d-word">Any</span> , which is the default superclass for a class with no supertypes declared:</p>

<section><pre><code class="language-kotlin">
class Example // Implicitly inherits from Any
</code></pre></section><br><br>

<p>Any has three methods: <span class="d-word"> equals()</span> , <span class="d-word">hashCode()</span> , and <span class="d-word">toString()</span> . 
  Thus, these methods are defined for all Kotlin classes.</p>

<p>By default, <span class="negrita">Kotlin classes are final</span>  – they can’t be inherited. To make a class inheritable, mark it with the <span class="d-word">open</span>  keyword:</p>

<section><pre><code class="language-kotlin">
open class Base // Class is open for inheritance
</code></pre></section><br><br>

<p>To declare an explicit supertype, place the type after a colon in the class header:</p>

<section><pre><code class="language-kotlin">
open class Base(p: Int)

class Derived(p: Int) : Base(p
</code></pre></section><br><br>)

<p>If the derived class has a primary constructor, the base class can (and must) be initialized in that primary constructor according to its parameters.</p>

<p>if derived class has no primary constructor, then each secondary constructor has to initialize the base type using the <span class="d-word">super</span>  keyword
   or it has to delegate to another constructor which does. Note that in this case different secondary constructors can call different constructors of the base type:</p>

<section><pre><code class="language-kotlin">
class MyView : View {
    constructor(ctx: Context) : super(ctx)

    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
</code></pre></section><br><br>

<p class="sub-section">Overriding methods</p>

<p>Kotlin requires explicit modifiers for overridable members and overrides:</p>

<section><pre><code class="language-kotlin">
open class Shape {
  open fun draw() { /*...*/ }
  fun fill() { /*...*/ }
}

class Circle() : Shape() {
  override fun draw() { /*...*/ }
}
</code></pre></section><br><br>

<p>The <span class="d-word">override</span>  modifier is required for <span class="d-word"> Circle.draw()</span>. If it were missing, the compiler would complain. 
  If there is no open modifier on a function, like <span class="d-word">Shape.fill()</span> , declaring a method with the same signature in a subclass is 
  <span class="negrita">not allowed</span> , either with <span class="d-word">override</span>  or without it. The <span class="d-word">open</span>  modifier has no effect when added to members of a final class – a class without an open modifier.</p>

<p>A member marked <span class="d-word">override</span>  is itself open, so it may be overridden in subclasses. If you want to prohibit re-overriding, use <span class="d-word">final</span> :</p>

<section><pre><code class="language-kotlin">
open class Rectangle() : Shape() {
    final override fun draw() { /*...*/ }
}
</code></pre></section><br><br>


<p class="sub-section">Overriding properties</p>

<p>The overriding mechanism works on properties in the same way that it does on methods. Properties declared on a superclass that are then redeclared 
  on a derived class must be prefaced with <span class="d-word">override</span> , and they must have a <span class="negrita">compatible type</span> . 
  Each declared property can be overridden by a property with an initializer or by a property with a <span class="d-word">get</span>  method:</p>


<section><pre><code class="language-kotlin">
open class Shape {
    open val vertexCount: Int = 0
}

class Rectangle : Shape() {
    override val vertexCount = 4
}
</code></pre></section><br><br>

<p>You can also override a <span class="d-word">val</span>  property with a <span class="d-word">var</span>  property, but not vice versa. 
  This is allowed because a <span class="d-word">val</span>  property essentially declares a <span class="d-word">get</span>  method, and overriding it 
  as a var additionally declares a <span class="d-word">set</span>  method in the derived class.</p>

<p>Note that you can use the <span class="d-word">override</span>  keyword as part of the property declaration in a <span class="cursiva">primary constructor</span> :</p>

<section><pre><code class="language-kotlin">
interface Shape {
    val vertexCount: Int
}

class Rectangle(override val vertexCount: Int = 4) : Shape // Always has 4 vertices

class Polygon : Shape {
    override var vertexCount: Int = 0  // Can be set to any number later
}
</code></pre></section><br><br>

<p class="sub-section">Derived class initialization order</p>

<p>During the construction of a new instance of a derived class, the base class initialization is done as the first step 
  (preceded only by evaluation of the arguments for the base class constructor), which means that it happens before the initialization logic of the derived class is run.</p>

  <section><pre><code class="language-kotlin">
open class Base(val name: String) {

    init { println("Initializing a base class") }

    open val size: Int = 
        name.length.also { println("Initializing size in the base class: $it") }
}

class Derived(
    name: String,
    val lastName: String,
) : Base(name.replaceFirstChar { it.uppercase() }.also { println("Argument for the base class: $it") }) {

    init { println("Initializing a derived class") }

    override val size: Int =
        (super.size + lastName.length).also { println("Initializing size in the derived class: $it") }
}
fun main() {
  println("Constructing the derived class(\"hello\", \"world\")")
  Derived("hello", "world")
}
  </code></pre></section><br><br>










  <script src="../script/prism.js"></script>
</body>
</html>
