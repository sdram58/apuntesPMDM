<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD2.-Kotlin's basics</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>
<body class="line-numbers">
  <h1>UD2.-Kotlin's basics</h1>
  
  <div class="main-menu">
    <a href="#s1">Why Kotlin?</a><a 
       href="#s1_1">Packets</a><a 
       href="#s2">Variable Declaration</a><a 
       href="#s3">Conditionals</a><a 
       href="#sloops">Loops</a><a 
       href="#sFunciones">Functions</a><a 
       href="#sClasses">Classes and Objects</a><a 
       href="#sLateinit">Initialization with lateinit vs lazy</a><a 
       href="#sModismos">Let, run, also, apply, with</a><a
       href="#sExercises">Interactive exercises from Kotlinlang</a>

</div>


<a name="s1"><a>
<h2>Why Kotlin?</h2>
<p>Kotlin is a modern programming language than make developers happier…</p>

<img style="width:100%" src="./imagenes/ud1/Imagen1.png" alt="Kotlin's uses" title="Kotlin's uses" />
<br><br>
<a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> 

<a name="s1_1"><a>
<h2>Packets</h2>
<p>As in Java, in Kotlin the packages are placed at the top of the file:</p>
<section><pre><code class="language-kotlin">package com.example

import com.example.*

// ...
</code></pre></section><br><br>

<!--**********************Variable declaration **************************************-->
<a name="s2"><a>
<h2>Variable declaration</h2>

<p>
  Kotlin uses two different keywords to declare variables: <span class="r-word">val</span> and <span class="r-word">var</span> 
  <ul>
    <li>Use <span class="r-word">val</span>  for a variable whose value never changes. You <span class="negrita">can't</span>  reassign a value to a variable that was declared using val.</li>
    <li>Use <span class="r-word">var</span>  for a variable whose value can change.</li>
  </ul>
</p>

<p>In the example below, count is a variable of type Int that is assigned an initial value of 10:</p>

<section><pre><code class="language-kotlin">var count: Int = 10
</code></pre></section>

<p><span class="r-word">Int</span>  is a type that represents an integer, one of the many numerical types that can be represented in Kotlin. Similar to other languages, you can also use Byte, Short, Long, Float, and Double depending on your numerical data.</p>

<p>The <span class="cursiva">var</span>   keyword means that you can reassign values to count as needed. For example, you can change the value of <span class="cursiva">count</span>  from 10 to 15:</p>

<section><pre><code class="language-kotlin">var count: Int = 10
count = 15
</code></pre></section>

<br>
<p>Some values are not meant to be changed, though. Consider a String called <span class="cursiva">languageName</span>  . If you want to ensure that <span class="cursiva">languageName</span>  always holds a value of "Kotlin", then you can declare <span class="cursiva">languageName</span>  using the <span class="d-word">val</span>  keyword:</p>

<section><pre><code class="language-kotlin">val languageName: String = "Kotlin"
</code></pre></section><br><br>

<p>These keywords allow you to be explicit about what can be changed. Use them to your advantage as needed. If a variable reference must be reassignable, then declare it as a <span class="cursiva">var</span> . Otherwise, use <span class="cursiva">val</span> .</p>

<h3>Type Inference</h3>

<br>
<p>Continuing the previous example, when you assign an initial value to <span class="cursiva">languageName</span> , the Kotlin compiler can infer the type based on the type of the assigned value.
  <br>Since the value of "Kotlin" is of type String, the compiler infers that <span class="cursiva">languageName</span>  is also a String. Note that Kotlin is a <span class="negrita">statically-typed</span>  language. This means that the type is resolved at compile time and never changes.
  <br>In the following example, <span class="cursiva">languageName</span>  is inferred as a String, so you can't call any functions that aren't part of the String class:
  </p>

  <section><pre><code class="language-kotlin">  val languageName = "Kotlin"
  val upperCaseName = languageName.toUpperCase()
  </code></pre></section><br><br>


  <section class="marco-t err">
    <span class="icono error"> </span> <span class="negrita">Error</span>
    </section>
  <section class="marco-b">
      <section><pre><code class="language-kotlin">  // Fails to compile
  languageName.inc()
      </code></pre></section><br><br>
  </section>
  

  <p><span class="cursiva">toUpperCase()</span>  is a function that can only be called on variables of type <span class="cursiva">String</span> . Because the Kotlin compiler has inferred <span class="cursiva">languageName</span>  as a String, you can safely call <span class="cursiva">toUpperCase(). inc()</span> , however, is an <span class="r-word">Int</span>  operator function, so it can’t be called on a <span class="cursiva">String</span> . Kotlin’s approach to type inference gives you both conciseness and type-safety.</p>

  <h3>Know values in compilation time</h3>

  <p>
    They can only be declared at the top level (outside of a class) or as a member of a class</p>
    <p>They can only be declared with primitive or String values</p>

    <section><pre><code class="language-kotlin">package com.cartatar.testkotlin

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

const val PI=3.1416
    </code></pre></section><br><br>


  <h3>Null Safety</h3>

  <br><br>

  <p>One of the most common mistakes in programming is the hated <span class="d-word">NullPointerException</span>. 
    It occurs when the programmer forgets to initialize an object or it has not been able to do so due to some kind of problem. 
    To try to minimize the appearance of this type of error, Kotlin incorporates a series of measures, which we will discuss in this section.
  </p>

<p>Kotlin supports <span class="d-word">null</span>  safetly natively, giving us the ability to define whether a variable can be <span class="d-word">null</span>  or not. 
  In this way, the compiler can catch potential <span class="d-word">NullPointerException</span>  errors at compile time,
   reducing the possibility of error in run time. <span class="negrita">By default, all variables in Kotlin are non-nullable</span>. 
   Thus, if we try to assign a <span class="d-word">null</span>  value to any variable, the compiler will throw an error:
</p>

<section><pre><code class="language-kotlin">var saludo: String = "Hola"
saludo = null // Compiling Error
</code></pre></section><br><br>

<section><pre><code class="language-kotlin">var saludoNullable: String? = "Hello"
saludoNullable = null //Compiles
</code></pre></section><br><br>

<p>As shown in the example above, if we want to allow a variable to be null, we will have to define it by adding <span class="d-word">?</span> to your data type.</p>

<p>Since <span class="d-word">NullPointerException</span> errors occur when we try to access a method or property of a <span class="d-word">null</span> 
  variable, Kotlin will avoid such errors by denying the call to the methods or access to the affected properties. 
  However, some times, it will be necessary to use these methods or properties. For this, we have several alternatives.</p>

<p class="sub-section">Adding a preflight</p>

<br>
<p>We can check if a variable is <span class="d-word">null</span>  before performing an operation, just as we did in <span class="d-word">Java</span> .</p>

<section><pre><code class="language-kotlin">val nameNullable: String? = "Juan"
if (nobreNullable != null) {
    println("Hola, ${nameNullable.toUpperCase()}.")
    println("Tu name tiene ${nameNullable.length} caracteres.")
} else {
    println("Hola, invitado")
} 
</code></pre></section><br><br>


<p>
  If we try to access a <span class="d-word">nullable</span>  variable without this check, a compilation error occurs. </p>
  <section><pre><code class="language-kotlin">val s: String? = "Hola"
print(s.length) // Compile Error 
  </code></pre></section><br><br>
  <p>For it to compile we have to use the code below.</p>

  <section><pre><code class="language-kotlin">if (s != null) {
   print(s.length) // compiles
} 
  </code></pre></section><br><br>


<p class="sub-section">Secure call with "?" operator.</p><br><br>
<p>The above check is simple, but requires a lot of code to do it. Kotlin offers us the <span class="d-word">?</span>  operator in order to reduce that code, 
  so that we can have the null check and the method call on the same line. Thus, the following code:</p>

<section><pre><code class="language-kotlin">name?.toUpperCase()

//it is equivalent to
	
if (name != null)
     name.toUpperCase()
else null
</code></pre></section><br><br>

<p>This operator will allow us multiple simultaneous checks:</p>

<section><pre><code class="language-kotlin">val currentCity: String? = user?.address?.ciudad 
</code></pre></section><br><br>

<p>In the example, <span class="cursiva">currentCity</span>  will be <span class="negrita">null</span>  if <span class="cursiva">user</span>,
   <span class="cursiva">address</span>  or <span class="cursiva">ciudad</span>  are null.</p>

<p></p>

<p class="sub-section">Elvis operator: "?:"</p>

<p>The Elvis operator <span class="d-word">?:</span>  is used to offer a default value when the variable to be validated contains <span class="negrita">null</span>. 
  For example, the following code:</p>

  <section><pre><code class="language-kotlin">name ?: "unknown"

  //Equivalent code 

if (name != null) name
else "unknown" 
  </code></pre></section><br><br>

  <p>One of the most common uses of this operator is to <span class="negrita">return a default value</span> distinct to <span class="d-word">null</span>  when a method or property is <span class="d-word">null</span> :</p>

<section><pre><code class="language-kotlin">val nameMayuscula = name?.toUpperCase() ?: "DESCONOCIDO"
val ciudadActual = usuario?.direccion?.ciudad ?: "desconocida"
</code></pre></section><br><br>

<p>The complexity of the expressions to the left of the Elvis operator can be even greater, as shown in the second example.</p>
<p>Also, we can use the right part of the operator to <span class="negrita">throw</span>  an exception or return a value. 
  This will be very useful to us when we evaluate the preconditions of a function.</p>

<section><pre><code class="language-kotlin">val n = nameNullable ?: throw IllegalArgumentException("Name is null") 
</code></pre></section><br><br>

<p>If, in addition to returning a value, we need to execute multiple operations to the right of the elvis operator, 
  it will be necessary to include them in a <span class="negrita">block</span>  of type <span class="d-word">run</span>.</p>

<section><pre><code class="language-kotlin">val a = b ?: run {
    val valorSiBEsNull = c.obtenValor()
    almacena(valorSiBEsNull)
    valorSiBEsNull //This is the return value
} 
</code></pre></section><br><br>

<p class="sub-section">The "!!" operator</p>

<p>Through the <span class="d-word">!!</span>  operator. We can skip the null check of a variable, so that an exception of the type <span class="d-word">NullPointerException</span> 
   will be thrown if the variable is null.
</p>

<section><pre><code class="language-kotlin">val name: String? = null
name!!.toUpperCase() // NullPointerException
</code></pre></section><br><br>

<p>It is used on those occasions when we as programmers <span class="negrita">are sure</span>  that a variable <span class="negrita">is not going to be null</span>
  , even though it may contain that value, and we reaffirm ourselves before the compiler. 
  Its appearance is quite common when we migrate <span class="d-word">Java</span>  code to <span class="d-word">Kotlin</span>, but Kotlin's philosophy is contrary to that, 
  so we must avoid its use as much as possible. Later, several alternatives are described to eliminate this operator in case of a migration from Java.
</p>

<p class="sub-section">The let operator in Kotlin</p>

<p>During application programming we will encounter the following situation on several occasions:
</p>

<section><pre><code class="language-kotlin">var propiedad: Int? = 42
fun unMetodo() {
    if (propiedad != null) {
        print(propiedad) // Error: even check null has been taken. Another thread is able to change the value to null
    }
} 
</code></pre></section><br><br>


<p>Since we are using a mutable variable (property), its value can be changed by another thread, just after having done the check.
  A quick alternative, which is used by the system when importing Java code, is to use the <span class="d-word">!!</span>  operator  but, as we have commented, 
  it is an operator that <span class="negrita">we should avoid</span>  as far as possible.
</p>
<p>Another possible solution would be to create a read-only copy of said variable:</p>
<section><pre><code class="language-kotlin">var propiedad: Int? = 42
fun unMetodo() {
    val copia = propiedad
    if (copia != null) {
        print(copia)
    }
} 
</code></pre></section><br><br>

<p>The previous code compiles, but one of the advantages of Kotlin is <span class="negrita">the reduction of unnecessary code</span>  (boilerplate code) 
  and this code does not fit with this philosophy, since all we do is add more lines of code.
</p>

<p>A more suitable alternative would be to use the <span class="d-word">let</span>  operator, which, internally, creates a copy of the variable 
  to be checked in a local immutable variable that will be used in the block defined below. 
  In this way, we could think of a possible solution like the following:
</p>
<section><pre><code class="language-kotlin">var propiedad: Int? = 42
fun unMetodo() {
    propiedad.let {
        print(it) //it is propiedad after not null check
    }
}  
</code></pre></section><br><br>

<p>In this example, the <span class="d-word">let</span>  function checks to see if property is <span class="d-word">null</span> .
   If not, make a copy of the property in it and run the <span class="d-word">Lambda</span> .</p>

<p>This solution is valid, but if inside the <span class="d-word">let</span>  block we need to call a function with its value, we may run into an error.
</p>

<section><pre><code class="language-kotlin">var propiedad: Int? = 42
fun unMetodo() {
    propiedad.let {
        imprimir(it) // error. imprimir function expects Int (not nullable) but gets it (propiedad) which is nullable, then ERROR.
    }
}
fun imprimir(int: Int) {
    print(int)
}  
</code></pre></section><br><br>

<p>In this case, our print function needs a value of type <span class="d-word">Int</span>  and receives a value of type <span class="d-word">Int ?</span>. 
  Luckily, this type of error is very easy to solve with the <span class="d-word">?</span>  Operator, which will allow us to call our <span class="d-word">let</span> 
   operator in a safe way.</p>

<section><pre><code class="language-kotlin">var propiedad: Int? = 42
fun unMetodo() {
    propiedad?.let {
        imprimir(it)
    }
}
fun imprimir(int: Int) {
    print(int)
}  
</code></pre></section><br><br>

<p>The <span class="d-word">let</span>  function is more complex. If we look at its implementation, we will see that, 
  in addition to the variable with which we call the function <span class="d-word">T,</span>  we have a return value <span class="d-word">R</span>.</p>

<section><pre><code class="language-kotlin">inline fun &lt;T, R> T.let(block: (T) -> R): R 
</code></pre></section><br><br>

<p>Let's see a more complete code where to show the interaction of our class with the rest of the code:</p>

<section><pre><code class="language-kotlin">class MiClase {
    var propiedad: Int? = 42

    fun unMetodo() {
        val valor = propiedad?.let {
            imprimir(it)
            "correcto"
        }
    }
    fun imprimir(i: Int) {
        print(i)
    }
} 
</code></pre></section><br><br>

<p>In this example, apart from printing the value of the variable, we <span class="negrita">return a text string</span>  indicating that the <span class="d-word">let</span> 
  block has been executed. But what happens in case property is <span class="cursiva">null</span>?
</p>
<p>It is a good programming practice to cover this route, for which we can use the <span class="d-word">Elvis operator</span> .
  In this way, if the variable exists we will capture it and use it, and if it is <span class="negrita">null</span>  we will <span class="negrita">show an error message</span>:
</p>

<section><pre><code class="language-kotlin">fun unMetodo() {
    propiedad?.let {
        imprimir(it)
    } ?: run {
        mostrarError()
    }
} 
</code></pre></section><br><br>

<p>In this way, we can use the value returned by the <span class="d-word">let block</span>  to inform the user, something that was not possible without the <span class="d-word">Elvis block</span> .</p>

<section><pre><code class="language-kotlin">class MiClase {
    var propiedad: Int? = 42
    fun unMetodo() {
        val valor = propiedad?.let {
            imprimir(it)
            "correcto"
        } ?: "sin Valor"
        imprimir(valor)
    }
    fun imprimir(i: Int) {
        print(i)
    }
    fun imprimir(string: String) {
        print(string)
    }
} 
</code></pre></section><br><br><br>



    <!--***********************************************************Conditionals***************************************************************** -->
    <a name="s3"><a>
    <h2>Conditionals</h2>

    <h3>If-else statements</h3>

    <p>Kotlin features several mechanisms for implementing conditional logic. The most common of these <span class="cursiva">is</span>  an <span class="cursiva">if-else</span>  statement. If an expression wrapped in parentheses next to an if keyword evaluates to <span class="cursiva">true</span> , then code within that branch (i.e. the immediately-following code that is wrapped in curly braces) is executed. Otherwise, the code within the <span class="cursiva">else</span>  branch is executed.</p>

    <section><pre><code class="language-kotlin">if (count == 42) {
  println("I have the answer.")
} else {
  println("The answer eludes me.")
}
    </code></pre></section><br><br>

    <p>You can represent multiple conditions using <span class="cursiva">else if</span> . This lets you represent more granular, complex logic within a single conditional statement, as shown in the following example:</p>

    <section><pre><code class="language-kotlin">if (count == 42) {
    println("I have the answer.")
} else if (count > 35) {
    println("The answer is close.")
} else {
    println("The answer eludes me.")
}
    </code></pre></section><br><br>


    <p>Conditional statements are useful for representing stateful logic, but you may find that you repeat yourself when writing them. In the example above, you simply print a <span class="cursiva">String</span>  in each branch. To avoid this repetition, Kotlin offers <span class="cursiva">conditional expressions</span> . The last example can be rewritten as follows:</p>

    <section><pre><code class="language-kotlin">val answerString: String = if (count == 42) {
    "I have the answer."
} else if (count > 35) {
    "The answer is close."
} else {
    "The answer eludes me."
}

println(answerString)
    </code></pre></section><br><br>

    <h3>When</h3>

    <p><span class="r-word">when</span>  defines a conditional expression with multiple branches. It is similar to the <span class="cursiva">switch</span>  statement in C-like languages. Its simple form looks like this.</p>

    <section><pre><code class="language-kotlin">when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> { // Note the block
      print("x is neither 1 nor 2")
  }
}
    </code></pre></section><br><br>

  <p><span class="r-word">when</span> matches its argument against all branches sequentially until some branch condition is satisfied.</p> 

  <p><span class="r-word">when</span> can be used either as an expression or as a statement. If it is used as an expression, the value of the first matching branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Just like with if, each branch can be a block, and its value is the value of the last expression in the block.</p>

  <p>The <span class="cursiva">else</span>  branch is evaluated if none of the other branch conditions are satisfied. If when is used as an expression, the <span class="cursiva">else</span>  branch is <span class="negrita">mandatory</span> , unless the compiler can prove that all possible cases are covered with branch conditions, for example, with <span class="d-word">enum</span>  class entries and <span class="cursiva">sealed</span>  class subtypes).</p>

  <p>To define a common behavior for multiple cases, combine their conditions in a single line with a comma:</p>

  <section><pre><code class="language-kotlin">  when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
  }
  </code></pre></section><br><br>


  <p>You can use arbitrary expressions (not only constants) as branch conditions</p>
  <section><pre><code class="language-kotlin">  when (x) {
    parseInt(s) -> print("s encodes x")
    else -> print("s does not encode x")
}
  </code></pre></section><br><br>

  <p>You can also check a value for being <span class="d-word">in</span>  or <span class="d-word">!in</span>  a range or a collection:</p>

  <section><pre><code class="language-kotlin">  when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
  </code></pre></section><br><br>

  <p>Another option is checking that a value <span class="d-word">is</span>  or <span class="d-word">!is</span>  of a particular type. Note that, due to smart casts, you can access the methods and properties of the type without any extra checks.</p>
  <section><pre><code class="language-kotlin">  fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
  }
  </code></pre></section><br><br>

  <p><span class="r-word">when</span>  can also be used as a replacement for an <span class="cursiva">if</span> - <span class="cursiva">else if</span>  chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</p>

  <section><pre><code class="language-kotlin">  when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
  }
  </code></pre></section><br><br>

  <p>You can capture <span class="cursiva">when</span>  subject in a variable using following syntax:</p>

  <section><pre><code class="language-kotlin">  var x:Int = 100
    var b = when(x){
        in 1..10 -> true
        else -> false
    }
    
    println("b es $b")
  </code></pre></section><br><br>


  <!--**********************LOOPS**************************************-->
  <a name="sloops"><a>
  <h2>Loops</h2>

  <p>Kotlin's syntax for loops differs a bit from Java's.</p>

  <h3>For loops</h3>
  
  <p>Kotlin intervals would be the classic <span class="cursiva">for</span>  loops with <span class="cursiva">i</span>  in Java.</p>
  

  <section><pre><code class="language-kotlin">for (i in 1..3) {
  print("$i ") // "1 2 3"
}
  </code></pre></section><br><br>

  <section><pre><code class="language-kotlin">for (i in 1 until 4) … //1,2,3 **4 not inculded**
  </code></pre></section><br><br>

  <section><pre><code class="language-kotlin">for (i in 10 downTo 0 step 2) {
    print("$i ") // "10 8 6 4 2 0"
  }
  </code></pre></section><br><br>

  <p>The <span class="cursiva">for</span>  loop iterates through anything that provides an iterator. This is equivalent to the <span class="cursiva">foreach</span>  loop in languages like C#. The syntax of for is the following:</p>

  <section><pre><code class="language-kotlin">for (item in collection) print(item)
  </code></pre></section><br><br>

  <p>The body of <span class="cursiva">for</span>  can be a block.</p>

  <section><pre><code class="language-kotlin">for (item: Int in ints) {
    // ...
  }
  </code></pre></section><br><br>

  <p>A for loop over a range or an array is compiled to an index-based loop that does not create an iterator object.</p>

  <section><pre><code class="language-kotlin">for (i in array.indices) {
    println(array[i])
  }
  </code></pre></section><br><br>


  <p>Alternatively, you can use the <span class="d-word">withIndex</span>  library function:</p>

  <section><pre><code class="language-kotlin">for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
  }
  </code></pre></section><br><br>


  <h3>While Loops</h3>

  <p><span class="cursiva">while</span>  and <span class="cursiva">do-while</span>  loops execute their body continuously while their condition is satisfied. The difference between them is the condition checking time:</p>

  <p>
    <ul>
      <li><span class="d-word">while</span> checks the condition and, if it's satisfied, executes the body and then returns to the condition check.</li>
      <li><span class="d-word">do-while</span> executes the body and then checks the condition. If it's satisfied, the loop repeats. So, the body of do-while executes at least once regardless of the condition.</li>
    </ul>
  </p>

  <section><pre><code class="language-kotlin">while (x > 0) {
    //Some code here
    x--    
  }

  do {
    val y = retrieveData()
  } while (y != null) // y is visible here!
  </code></pre></section><br><br>

  <h3>Repeat</h3>
  <p>The <span class="d-word">repeat()</span>  statement starts with the word <span class="negrita">repeat</span> , followed by <span class="negrita">()</span>.</p>
  <ul>
    <li>Inside the parentheses <span class="d-word">()</span>  is the number of repetitions,</li>
    <li>followed by curly braces <span class="d-word">{}</span> ,</li>
    <li>and inside the curly braces <span class="d-word">{}</span> , is the code to repeat.</li>
  </ul>

  <section><pre><code class="language-kotlin">  fun main() {
    repeat(5){
        println("Hello World")
    }
  }
  </code></pre></section><br><br>

  <figure><img src="imagenes/ud2-2021-09-14-11-59-27.png" /><br><figcaption>Repeat Hello World 5 times</figcaption></figure>
  <br>
  <br>


  


  <h3>Break and continue in loops</h3>

  <p>Kotlin supports traditional break and continue operators in loops.</p>
  <p>Kotlin has three structural jump expressions</p>
  <ul>
    <li><span class="d-word">return</span>  by default returns from the nearest enclosing function or <span class="negrita">anonymous function</span> </li>
    <li><span class="d-word">break</span>  terminates the nearest enclosing loop</li>
    <li><span class="d-word">continue</span>  proceeds to the next step of the nearest enclosing loop</li>
  </ul>
  <p>All of these expressions can be used as part of larger expressions:</p>

  <section><pre><code class="language-kotlin">  val s = person.name ?: return
  </code></pre></section><br><br>

  <p>The type of these expressions is the <a class="enlace" target="_blank" href="https://kotlinlang.org/docs/exceptions.html#the-nothing-type">Nothing type</a> .</p>

  <p class="sub-section">Break and continue labels</p>
  
  <p>Any expression in Kotlin may be marked with a label. Labels have the form of an identifier followed by the <span class="d-word">@</span>  sign, for example: <span class="cursiva">abc@, fooBar@</span>. 
    To label an expression, just add a label in front of it.</p>

<section><pre><code class="language-kotlin">loop@ for (i in 1..100) {
    // ...
}
</code></pre></section><br><br>

<p>Now, we can qualify a <span class="d-word">break</span>  or a <span class="d-word">continue</span>  with a label:</p>

<section><pre><code class="language-kotlin">  fun main() {
    

    loop@ for (i in 1..10) {
          for (j in 1..5) {
              if (i%2==0 && j==2) break@loop
              println("${i} - ${j}")
          }
      }
      //Prints
      //1 - 1
      //1 - 2
      //1- 3
      //1 - 4
      //1 - 5
      //2 - 1
      
  }
</code></pre></section><br><br>

<p>A <span class="d-word">break</span>  qualified with a label jumps to the execution point right after the loop marked with that label. 
  A <span class="d-word">continue</span>  proceeds to the next iteration of that loop.</p>

<p class="sub-section">Return at labels</p>
<p>With function literals, local functions and object expressions, functions can be nested in Kotlin. 
  Qualified <span class="d-word">return</span> allow us to return from an outer function. 
  The most important use case is returning from a lambda expression. Recall that when we write this:</p>

<section><pre><code class="language-kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // non-local return directly to the caller of foo()
        print(it)
    }
    println("this point is unreachable")
}
</code></pre></section><br><br>

<p>The <span class="d-word">return</span>  -expression returns from the nearest enclosing function - foo. 
  Note that such non-local returns are <span class="negrita">supported only for lambda expressions</span>  passed to inline functions. 
  To return from a lambda expression, label it and qualify the return:</p>

<section><pre><code class="language-kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with explicit label")
}
</code></pre></section><br><br>

<p>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use <span class="cursiva">implicit labels</span>: 
  such a label has the same name as the function to which the lambda is passed.</p>

<section><pre><code class="language-kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with implicit label")
}
</code></pre></section><br><br>

<p>Alternatively, you can replace the lambda expression with an anonymous function. A <span class="d-word">return</span> 
  statement in an anonymous function will return from the anonymous function itself.</p>

<section><pre><code class="language-kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // local return to the caller of the anonymous function - the forEach loop
        print(value)
    })
    print(" done with anonymous function")
}
</code></pre></section><br><br>

<p>Note that the use of local returns in previous three examples is similar to the use of <span class="d-word">continue</span>  in regular loops. 
  There is no direct equivalent for <span class="d-word">break</span> , but it can be simulated by adding another 
  nesting lambda and non-locally returning from it:</p>

<section><pre><code class="language-kotlin">fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // non-local return from the lambda passed to run
            print(it)
        }
    }
    print(" done with nested loop")
}
</code></pre></section><br><br>

<p>
  When returning a value, the parser gives preference to the qualified return:

<section><pre><code class="language-kotlin">return@a 1
</code></pre></section><br><br>

This means "return <span class="d-word">1</span>  at label <span class="d-word"> @a</span> " and not "return a labeled expression (@a 1)".
</p>

<!--************************Functions**************************-->
<a name="sFunciones"><a>
<h2>Functions</h2>

<p>Kotlin functions are declared using the <span class="d-word">fun</span> keyword:</p>

<section><pre><code class="language-kotlin">fun double(x: Int): Int {
    return 2 * x
}
</code></pre></section><br><br>

<h3>Function Usage</h3>

<p>Functions are called using the standard approach:</p>

<section><pre><code class="language-kotlin">val result = double(2)
</code></pre></section><br><br>

<p>Calling member functions uses dot notation:</p>

<section><pre><code class="language-kotlin">Stream().read() // create instance of class Stream and call read()
</code></pre></section><br><br>

<h3>Parameters</h3>

<p>Function parameters are defined using <span class="cursiva">Pascal</span>  notation - name: <span class="cursiva">type</span> . 
  Parameters are separated using commas, and each parameter must be explicitly typed:</p>

<section><pre><code class="language-kotlin">fun powerOf(number: Int, exponent: Int): Int { /*...*/ }
</code></pre></section><br><br>

<p>You can use a trailing comma when you declare function parameters:</p>

<section><pre><code class="language-kotlin">fun powerOf(
    number: Int,
    exponent: Int, // trailing comma
) { /*...*/ }
</code></pre></section><br><br>

<h3>Default arguments</h3>

<p>Function parameters can have default values, which are used when you skip the corresponding argument. 
  This reduces the number of overloads:</p>

<section><pre><code class="language-kotlin">fun read(
    b: ByteArray,
    off: Int = 0,
    len: Int = b.size,
) { /*...*/ }
</code></pre></section><br><br>

<p>A default value is defined using = after the type.</p>

<p>Overriding methods always use the same default parameter values as the base method. 
  When overriding a method that has default parameter values, the default parameter values must be omitted from the signature:</p>

<section><pre><code class="language-kotlin">open class A {
    open fun foo(i: Int = 10) { /*...*/ }
}

class B : A() {
    override fun foo(i: Int) { /*...*/ }  // No default value is allowed.
}
</code></pre></section><br><br>

<p>if a default parameter precedes a parameter with no default value, 
  the default value can only be used by calling the function with named arguments:</p>

<section><pre><code class="language-kotlin">fun foo(
    bar: Int = 0,
    baz: Int,
) { /*...*/ }

foo(baz = 1) // The default value bar = 0 is used
</code></pre></section><br><br>

<p>If the last argument after default parameters is a lambda, you can pass it either as a named argument or outside the parentheses:</p>

<section><pre><code class="language-kotlin">fun foo(
    bar: Int = 0,
    baz: Int = 1,
    qux: () -> Unit,
) { /*...*/ }

foo(1) { println("hello") }     // Uses the default value baz = 1
foo(qux = { println("hello") }) // Uses both default values bar = 0 and baz = 1
foo { println("hello") }        // Uses both default values bar = 0 and baz = 1
</code></pre></section><br><br>

<h3>Named Arguments</h3>
<p>When calling a function, you can name one or more of its arguments. 
  This can be helpful when a function has many arguments and it's difficult to associate a value with an argument, 
  especially if it's a boolean or <span class="d-word">null</span>  value.</p>

<p>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values, 
  you can just leave these arguments out altogether.</p>

<p>Consider the following function, <span class="d-word">reformat()</span> , which has 4 arguments with default values.</p>

<section><pre><code class="language-kotlin">fun reformat(
    str: String,
    normalizeCase: Boolean = true,
    upperCaseFirstLetter: Boolean = true,
    divideByCamelHumps: Boolean = false,
    wordSeparator: Char = ' ',
) { /*...*/ }
</code></pre></section><br><br>

<p>When calling this function, you don’t have to name all its arguments:</p>

<section class="marco-b"><pre><code class="language-kotlin">
reformat(
    "String!",
    false,
    upperCaseFirstLetter = false,
    divideByCamelHumps = true,
    '_'
)
</code></pre></section>

<p>You can skip all the ones with default values:</p>

<section><pre><code class="language-kotlin">reformat("This is a long String!")
</code></pre></section><br><br>

<p>You are also able to skip specific arguments with default values, rather than omitting them all. 
  However, after the first skipped argument, you must name all subsequent arguments:</p>

<section><pre><code class="language-kotlin">reformat("This is a short String!", upperCaseFirstLetter = false, wordSeparator = '_')
</code></pre></section><br><br>

<h3>Unit-returning functions</h3>

<p>If a function does not return a useful value, its return type is <span class="d-word">Unit</span> . <span class="d-word">Unit</span> 
   is a type with only one value - <span class="d-word">Unit</span> . This value does not have to be returned explicitly:</p>

<section><pre><code class="language-kotlin">fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello $name")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
</code></pre></section><br><br>

<p>The <span class="d-word">Unit</span>  return type declaration is also optional. The above code is equivalent to:</p>

<section><pre><code class="language-kotlin">fun printHello(name: String?) { ... }
</code></pre></section><br><br>


<h3>Single-expression functions</h3>

<p>When a function returns a single expression, the curly braces can be omitted and the body is specified after a <span class="d-word">=</span>  symbol:</p>

<section><pre><code class="language-kotlin">fun double(x: Int): Int = x * 2
</code></pre></section><br><br>

<p>Explicitly declaring the return type is optional when this can be inferred by the compiler:</p>

<section><pre><code class="language-kotlin">fun double(x: Int) = x * 2
</code></pre></section><br><br>

<h3>Variable number of arguments (varargs)</h3>

<p>You can mark a parameter of a function (usually the last one) with the <span class="d-word">vararg</span>  modifier:</p>

<section><pre><code class="language-kotlin">fun &lt;T&gt; asList(vararg ts: T): List&lt;T> {
    val result = ArrayList&lt;T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
</code></pre></section><br><br>

<p>In this case, you can pass a variable number of arguments to the function:</p>

<section><pre><code class="language-kotlin">val list = asList(1, 2, 3)
</code></pre></section><br><br>

<p>Inside a function, a <span class="d-word">vararg</span>  -parameter of type <span class="d-word">T</span> 
  is visible as an array of <span class="d-word">T</span> , as in the example above, where the ts variable has type <span class="d-word">Array&lt;out T></span> .</p>

  <p>Only one parameter can be marked as <span class="d-word">vararg</span> . If a <span class="d-word">vararg</span>  parameter is not the last one in the list, 
    values for the subsequent parameters can be passed using named argument syntax, or, if the parameter has a function type, 
    by passing a lambda outside the parentheses.</p>

  <p>When you call a <span class="d-word">vararg</span>-function, you can pass arguments individually, 
    for example <span class="d-word">asList(1, 2, 3)</span> . If you already have an array and want to pass its contents to the function, 
    use the spread operator (prefix the array with <span class="d-word">*</span> ):</p>
  
<section><pre><code class="language-kotlin">val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)
</code></pre></section><br><br>

<h3>Function scope</h3>

<p>Kotlin functions can be declared at the top level in a file, meaning you do not need to create a class to hold a function, 
  which you are required to do in languages such as Java, C#, and Scala. 
  In addition to top level functions, Kotlin functions can also be declared locally as <span class="negrita">member</span>  functions and <span class="negrita">extension</span>  functions.</p>


<p class="sub-section">Local functions</p>

<p>Kotlin supports local functions, which are functions <span class="negrita">inside</span> other functions:</p>

<section><pre><code class="language-kotlin">fun dfs(graph: Graph) {
    fun dfs(current: Vertex, visited: MutableSet<Vertex>) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v, visited)
    }

    dfs(graph.vertices[0], HashSet())
}
</code></pre></section><br><br>

<p>A local function can access local variables of outer functions (the closure). In the case above, visited can be a local variable:</p>

<section><pre><code class="language-kotlin">fun dfs(graph: Graph) {
    val visited = HashSet<Vertex>()
    fun dfs(current: Vertex) {
        if (!visited.add(current)) return
        for (v in current.neighbors)
            dfs(v)
    }

    dfs(graph.vertices[0])
}
</code></pre></section><br><br>

<p class="sub-section">Member functions</p>

<p>A member function is a function that is defined inside a class or object:</p>

<section><pre><code class="language-kotlin">class Sample {
    fun foo() { print("Foo") }
}
</code></pre></section><br><br>

<p>Member functions are called with dot notation:</p>

<section><pre><code class="language-kotlin">Sample().foo() // creates instance of class Sample and calls foo
</code></pre></section><br><br>


<h3>Generic functions</h3>

<p>Functions can have generic parameters, which are specified using angle brackets before the function name:</p>

<section><pre><code class="language-kotlin">fun &lt;T> singletonList(item: T): List&lt;T> { /*...*/ }
</code></pre></section><br><br>

<h3>Tail recursive functions</h3>
<p>Kotlin supports a style of functional programming known as <span class="cursiva">tail recursion</span>. 
  For some algorithms that would normally use loops, you can use a recursive function instead without the risk of stack overflow. 
  When a function is marked with the <span class="d-word">tailrec</span>  modifier and meets the required formal conditions, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</p>

<section><pre><code class="language-kotlin">val eps = 1E-10 // "good enough", could be 10^-15

tailrec fun findFixPoint(x: Double = 1.0): Double =
    if (Math.abs(x - Math.cos(x)) &lt; eps) x else findFixPoint(Math.cos(x))
</code></pre></section><br><br>


<p>This code calculates the <span class="d-word">fixpoint</span>  of cosine, which is a mathematical constant. 
  It simply calls <span class="d-word">Math.cos</span>  repeatedly starting at 1.0 until the result no longer changes, yielding a 
  result of <span class="d-word">0.7390851332151611</span>  for the specified <span class="d-word">eps</span>  precision. 
  The resulting code is equivalent to this more traditional style:</p>

<section><pre><code class="language-kotlin">val eps = 1E-10 // "good enough", could be 10^-15

private fun findFixPoint(): Double {
    var x = 1.0
    while (true) {
        val y = Math.cos(x)
        if (Math.abs(x - y) &lt; eps) return x
        x = Math.cos(x)
    }
}
</code></pre></section><br><br>

<p>To be eligible for the <span class="d-word">tailrec</span>  modifier, a function must call itself as the last operation it performs. 
  You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within <span class="d-word">try/ catch/ finally</span>  blocks. Currently, tail recursion is supported by Kotlin for the JVM and Kotlin/Native.</p>


<h3>High-order functions and lambdas</h3>

<p>Kotlin functions are <span class="cursiva">first-class</span> , which means they can be stored in <span class="negrita">variables</span>  and <span class="negrita">data structures</span> 
  , and can be passed as arguments to and returned from other <span class="d-word">higher-order</span>  functions. 
  You can perform any operations on functions that are possible for other non-function values.</p>

<p>To facilitate this, Kotlin, as a statically typed programming language, uses a family of function types to represent functions, 
  and provides a set of specialized language constructs, such as lambda expressions.</p>

<p class="sub-section">Higher-order functions</p>

<p>A <span class="d-word">higher-order</span> function is a function that takes functions as parameters, or returns a function.</p>

<!--*****************************************Lambdas and Variables function in Kotlin*******************************************-->
<h3>Lambdas and Variables function</h3>
<p>A <span class="d-word">Lambda</span>  expression is a subroutine of code that is not normally assigned an identifier.</p>
<p>A <span class="d-word">Lambda</span>  expression is usually passed as an argument to another function to parameterize its execution. 
  A function that receives a Lambda expression as a parameter is known as a <span class="d-word">higher-order function</span> .</p>

<p>Most modern languages ​​incorporate them. Java has <span class="d-word">Lambdas</span>  expressions since version 8.</p>
<p>A <span class="d-word">Lambda</span>  expression is always <span class="negrita">enclosed in braces</span>. 
  If you have parameters these are written at the beginning followed by <span class="d-word">-></span>.</p><p>Let's see some examples:</p>

<section><pre><code class="language-kotlin">{ toast("Message") }           //calls a function
{ x: Int, y: Int -> x + y }    //add two ints
{ x, y -> x + y }              //add two values
{ x -> x * 2 }                 //duplicates
{ it * 2 }                     //"it" can be used if there is an only param
{ x, _ -> x * 2 }              //"_" indicates a parameter that we do not use 
</code></pre></section><br><br>

<p>A <span class="d-word">Lambda</span>  expression can be passed as a parameter to a <span class="d-word">higher-order</span>  function. 
  Let's first look at an example of a <span class="d-word">higher-order</span>  function:</p>

<section><pre><code class="language-kotlin">fun opera(lista: List, valor: Int, funcion:(Int, Int)->Int ): List {
   val result = arrayListOf()
   for (item in lista)
      result.add(funcion(item, valor))
   return result
} 
</code></pre></section><br><br>

<p>The <span class="d-word">opera</span>  function has three parameters a <span class="cursiva">list, a value and a function</span> . 
  It is going to go through all the elements of the <span class="cursiva">list</span>  and it is going to use <span class="cursiva">funcion</span>, 
  to perform a calculation of each element of the <span class="cursiva">list</span>  and with value. The result obtained is stored in each position of the output list.
  To use <span class="cursiva">opera</span>  we could first <span class="negrita">declare function as a variable</span> :</p>
<section><pre><code class="language-kotlin">val funcion =  fun (x: Int, y:Int ):Int = x + y
lista = opera(lista, 2, funcion)  
</code></pre></section><br><br>

<p>We can also use an anonymous function, directly in the parameter</p>

<section><pre><code class="language-kotlin">lista = opera(lista, 2, fun (x, y):Int = x + y) 
</code></pre></section><br><br>

<p>Notice how in this case it is no longer necessary to indicate the types of x and y. These can be inferred from the parameter they are replacing.</p>
<p>This function can also be declared using a <span class="d-word">Lambda</span>  expression:</p>
<section><pre><code class="language-kotlin">val lambda =  { x: Int, y:Int -> x + y }
lista = opera(lista, 2, lambda)
</code></pre></section><br><br>

<p>But it is more readable if we use a <span class="d-word">Lambda</span>  expression:</p>

<section><pre><code class="language-kotlin">lista = opera(lista, 2, { x, y -> x + y }) 
</code></pre></section><br><br>

<p>When the <span class="negrita">last parameter</span>  for a function is a <span class="d-word">Lambda</span> , it can be specified outside of parentheses:</p>
<section><pre><code class="language-kotlin">lista = opera(lista, 2) { 
    x, y -> x + y
}  
</code></pre></section><br><br>

<p>As we have just seen, <span class="d-word">Lambda</span>  expressions have various utilities, but within the scope of Android they will 
  be very useful for writing the code for <span class="cursiva">event listeners</span>.</p>
<p>As you probably already know, writing a listener in Java is very laborious. An <span class="cursiva">anonymous object</span> 
   is usually created that implements an interface with all its methods. As you can see in the code on the right, with <span class="d-word">Kotlin</span>,
   it will be much simpler:</p>

<p>Java's code</p>
<section><pre><code class="language-kotlin">boton.setOnClickListener(
  new View.OnClickListener(){
    @Override
    public void onClick(View v){
       hazAlgo();
    }
});
</code></pre></section><br><br>

<p>Kotlin's code</p>
<section><pre><code class="language-kotlin">boton.setOnClickListener { hazAlgo() }
</code></pre></section><br><br>

<p>This is possible thanks to the fact that <span class="d-word">Kotlin</span>  does the following optimization on the Android Java library. 
  Every time it encounters a parameter whose type is an interface with a single function, the method is overloaded by replacing the parameter with a function:</p>

<section><pre><code class="language-kotlin">fun setOnClickListener( escuchador: (View) –> Unit )
</code></pre></section><br><br>

<section class="marco-t inf">
  <span class="icono info"> </span> <span class="negrita">
    <span class="cursiva">Note</span>  : <span class="d-word">Unit</span>  is a single-valued type, the unit object. <span class="negrita">Corresponds to void in Java</span> .</span>
  </section>
<section class="marco-b">
    
</section>

<p>the <span class="d-word">escuchador</span>  parameter must be replaced by a <span class="d-word">Lambda</span>  function or expression that has a <span class="d-word">View</span> 
   object as a parameter and does not return anything.</p>
<p>If we need to know the view that caused the event, we would write:</p>
  <section><pre><code class="language-kotlin">boton.setOnClickListener { vista -> hazAlgo(vista) }
  </code></pre></section><br><br>


<!--*****************************************Inline Functions*******************************************-->
<h3>Inline Functions</h3>
<p>In a normal function your code is stored once in memory. Each time it is invoked, the parameters are added to the stack and it is invoked.</p>
<p>In an inline function this invocation is not made, but the code of the function is inserted each time it is used.</p>
<p>In theory, an inline function has better performance compared to normal ones, 
  because they avoid using the stack to pass parameters and avoid jump and return instructions. 
  This statement will depend on how the code is compiled. For example, in the Java virtual machine, 
  it even uses the stack to execute instructions in machine code. Since the code has to be "copied" each time that function is called, 
  the size of the executable will increase as the size of the inline function grows.</p>

  <section><pre><code class="language-kotlin">inline fun suma(a:Int, b:Int) = a + b
val c = suma(2, 2) 
  </code></pre></section><br><br>
<p>The real advantage of <span class="d-word">inline</span>  functions appears when applied to higher-order functions. 
  Higher-order functions have some performance penalty (both in time and memory). 
  To call the Lambda parameter, a new object is created in memory that contains a method with the parameters indicated in the Lambda.</p>
  <p>For example, given the function:</p>

<section><pre><code class="language-kotlin">fun opera(l: List, v: Int, funcion: (Int, Int)->Int): List 
</code></pre></section><br><br>

<p>when compiling the following call:</p>
<section><pre><code class="language-kotlin">opera(l, v) { a, b -> a + b 
</code></pre></section><br><br>

<p>The resulting code would be something similar as if in Java we had written:</p>
<section><pre><code class="language-kotlin">opera(l, v, new Funcion() { 
   @Override public int funcion(int a, b) { return a + b; }
}); 
</code></pre></section><br><br>
<p>Which means the creation of a new anonymous object. But if, on the contrary, we had written:</p>

<section><pre><code class="language-kotlin">inline fun opera(l: List<Int>, v: Int, funcion: (Int, Int)->Int): List<Int> 
</code></pre></section><br><br>
<p>The <span class="d-word">inline</span>  will apply not only to <span class="d-word">opera</span>  but also to <span class="d-word">funcion</span>. 
  The final result will be to directly insert the <span class="d-word">opera</span>  code, and then within this code replace <span class="d-word">funcion</span>
   with its code. It would look like this:</p>
<section><pre><code class="language-kotlin">val result = arrayListOf<Int>()
for (item in lista)
   result.add(<del>funcion(item, valor)</del> item + valor)
return result 
</code></pre></section><br><br>


<p>In the case of a list of 100,000 items, we have avoided creating 100,000 objects. Which is a significant improvement. 
  Adding with the fact that we have avoided 100,000 calls to the function.</p>

  <a class="tarea" target="_blank" href="#"> In this exercise we are going to try to demonstrate the influence of using Lambdas
     on normal functions and on inline functions. We will look at both temporary performance and memory usage.
     <ol style="list-style-type: decimal !important;line-height: 1.2em; list-style-position: inside;">
       <li>Create a new project in Android Studio with the following data: <br>
      <pre>Application Name: Funciones Inline
        Package name: com.example.funcionesinline
        - Including Kotlin support
        - Phone and Tablet
           Minimum SDK: API 16: Android 4.1 (Jelly Bean)
        Basic Activity
      </pre><br>Leave the rest of the default values.</li>
       <li>
        Add the following function in <span class="d-word">MainActivity</span> 
        <section><pre><code class="language-kotlin">inline fun opera(l: IntArray, v: Int, funcion:(Int, Int)-&gt;Int): IntArray {
    val result = IntArray(l.size)
    for ((indice, item) in l.withIndex())
        result[indice] = (funcion(item, v))
    return result
}
        </code></pre></section><br><br>
      </li>
       <li>In the <span class="negrita">onCreate</span>  method add inside <span class="d-word">fab.setOnClickListener</span>:
        <section><pre><code class="language-kotlin">fab.setOnClickListener { view ->
    var lista = IntArray( 5, { 2 } )
    val ini = System.currentTimeMillis()
    for (n in 1..100_000) {
        opera(lista, 2) { a, b -> a+b }
    }
    val fin = System.currentTimeMillis()
    Snackbar.make(view, "Tiempo ${fin-ini}", Snackbar.LENGTH_LONG)
            .setAction("Action", null).show()
} 
        </code></pre></section><br><br>

        We start by initializing an array of integers of 5 elements and value 2. 
        Observe how the value with which we initialize the elements is indicated by a Lambda. 
        We write down the start time. We made 100,000 calls to <span class="negrita">opera</span>  and we wrote down the final time. 
        Finally we show the time spent in a Snackbar.</li>
       <li>
        Run the application and note the elapsed time.</li>
       <li>Remove the inline modifier from opera.</li>
       <li>Run the application again and note the elapsed time. This has to be significantly higher.</li>
       <li>For study of the memory used, click on the button: <br>
         <figure><img src="imagenes/ud2-2021-09-20-02-32-17.png" /><br><figcaption></figcaption></figure>
         <br>
         
       </li>
       <li>Click on the middle MEMORY.</li>
       <li>Press the Record Memory Alocation button<br>
         <figure><img src="imagenes/ud2-2021-09-20-02-33-05.png" /><br><figcaption></figcaption></figure>
         <br>
         
       </li>
       <li>
        Press the floating button of the application and when it shows the elapsed time, click on Stop Recording. <br>
        <figure><img src="imagenes/ud2-2021-09-20-02-34-17.png" /><br><figcaption></figcaption></figure>
        <br>
        
      </li>
       <li>Capture the screen for later analysis.</li>
       <li>Add the opera inline modifier.</li>
       <li>Repeat the process and compare the results Has there been a significant difference in memory usage? </li>
     </ol>
  </a> 





<!--************************Classes and objects**************************-->
<a name="sClasses"><a>
<h2>Classes and objects</h2>

<h3>Classes</h3>

<p>When we declare a <span class="r-word">class</span>  in <span class="d-word">Kotlin</span>  we can indicate parameters that are used to define a default <span class="d-word">constructor</span>.
  If we indicate <span class="d-word">var</span>  or <span class="d-word">val</span>  in these parameters, they will become part of the <span class="negrita">class properties</span> :</p>

<p><span class="negrita">Class</span>  in <span class="d-word">Java</span>  syntax</p>
<section><pre><code class="language-kotlin">public class Complejo {
   private double re, im;
   public Complejo(double re, 
                  double im) {
      this.re = re; this.im = im;
   }
   public void suma(Complejo v) {
      re = re + v.re;
      im = im + v.im;
   }
} 
</code></pre></section><br><br>

<p>The same <span class="negrita">class</span>  in <span class="d-word">Kotlin</span>  syntax</p>
<section><pre><code class="language-kotlin">class Complejo(var re: Double, 
               var im: Double=0.0){
     
   fun suma(v: Complejo) {
      re = re + v.re;
      im = im + v.im;
   }
}  
</code></pre></section><br><br>
<p>If not stated otherwise, a <span class="negrita">class</span>  extends from <span class="d-word">Any</span> , which is similar to <span class="d-word">Object</span>  in <span class="negrita">Java</span>.</p>
  <p><span class="negrita">Classes in Kotlin by default are <span class="d-word">public</span> </span> .</p>
<p>We can also declare properties and initialize them from parameters. The following class has three properties: <span class="cursiva">Name, Age, and PersonKey</span> :</p>

<section><pre><code class="language-kotlin">class Persona(name: String, var age: Int) {
   val personKey = name.toUpperCase()
}
</code></pre></section><br><br>
<p>If we need to add instructions to initialize the object we can use an <span class="d-word">init block</span> . 
  We could also add <span class="d-word">alternative constructors</span>  as long as they use different parameters</p>

<section><pre><code class="language-kotlin">class Persona(val name: String) {
   init {
      println("Inicialización objeto")
   }
   constructor(name: String, age: Int) : this(name) {
      println("Inicialización segundo constructor")
   }
}
</code></pre></section><br><br>

<p>You don't need to use <span class="d-word">new</span> to <span class="negrita">create objects</span>. Nor is it essential to indicate the <span class="negrita">type of the object</span>, 
  this is deduced from the <span class="d-word">constructor</span> .</p>

  <section><pre><code class="language-kotlin">//Java syntax
Persona p = new Persona("Ana"); 	

//Kotlin syntax
 val p = Persona("Ana") 
  </code></pre></section><br><br>

<p>To access the <span class="negrita">properties</span>  of an object it is no longer necessary to define <span class="d-word">getters</span>  and <span class="d-word">setters</span>. 
  They are created automatically:</p>

  <section><pre><code class="language-kotlin">//Java syntax
public class Persona {
   private String name;
   public String getname() {
      return name;
   }
   public void setname(String n){
      name = n;
   }
}

//Kotlin syntax
class Persona {
  var name: String = ""
} 
  </code></pre></section><br><br>
<p>Modifying the properties of an object is simpler in Kotlin, simply enter its name and Kotlin 
  will make the call to the <span class="d-word">getter</span>  or <span class="d-word">setter</span>. 
  Thanks to this, the <span class="negrita">code</span>  is much <span class="negrita">more readable</span> </p>

<section><pre><code class="language-kotlin">p.name = "Ana"
var s = p.name 
</code></pre></section><br><br>

<p>Kotlin also allows us to create our own <span class="d-word">getters</span>  and <span class="d-word">setters</span>.</p>

<section><pre><code class="language-kotlin">class Persona {
   var name: String = ""
      get() = field.toUpperCase()
      set(value) {
         if (value=="Carlos Tarazona") regalarJamon()
         field = value
      }  
} 
</code></pre></section><br><br>
<p>In a <span class="d-word">getter</span>  and <span class="d-word">setter</span>  we have to use <span class="r-word">field</span>  to access the property.</p>

<p>In Kotlin a property has no need to be stored in a backing variable. Let's see an example</p>

<section><pre><code class="language-kotlin">class Persona {
   var name: String = ""
   var longname: Int
      get() = name.size
}  
</code></pre></section><br><br>
<p>In the second property, a variable of type Int <span class="negrita">will not be created</span>. 
  This occurs as long as get or set is implemented and, furthermore, they do not refer to <span class="d-word">field</span>  (as in the previous example).
</p>
<p><span class="negrita">By default</span> , both the <span class="cursiva">class</span>  and its <span class="cursiva">properties</span> 
  and functions are <span class="d-word">public</span> . If we want something not to be accessible from outside the class, we will prepend with <span class="d-word">private</span> keyword.
  If we want only the <span class="d-word">getter</span>  or <span class="d-word">setter</span>  to be <span class="d-word">private</span>, we will indicate it as follows:
</p>

<section><pre><code class="language-kotlin">class Persona {
   private var edad: Int = 0
   var name: String = ""
      private set
}  
</code></pre></section><br><br>

<!-- ***********************Inheritance**************************-->
<h3>Inheritance</h3>

<p>Classes above cannot be used as a basis for creating new classes; by default they are <span class="d-word">closed</span> . (In Java a closed class is marked as <span class="r-word">final</span> .)
If we want to inherit from a class we have to prepend <span class="d-word">open</span>.</p>

<section><pre><code class="language-kotlin">open class Padre(p: Int) 
class Hijo(p: Int) : Padre(p) 
</code></pre></section><br><br>

<p>If the class does not have a parent <span class="d-word">constructor</span> , each child <span class="d-word">constructor</span>  has to initialize the base type with 
  the <span class="d-word">super</span>  keyword</p>

<section><pre><code class="language-kotlin">class MyView : View {
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}  
</code></pre></section><br><br>

<p>By default, the properties and methods of a class are <span class="d-word">closed</span> . (In Java marked as <span class="r-word">final</span>.) 
  To be able to overwrite them we have to indicate <span class="d-word">open</span> :</p>

<section><pre><code class="language-kotlin">open class Padre {
    open var name = "Soy padre"
    open fun abierto() {}
    fun cerrado() {}
}

class Hijo() : Padre() {
    override var name = "Soy hijo"
    final override fun abierto() {}
} 
</code></pre></section><br><br>
<p>A member marked with <span class="d-word">override</span>  <span class="negrita">continues to be opened</span> . To close it, you have to put <span class="d-word">final</span>  before it.</p>
<p>To access properties and methods of the parent class we will use <span class="d-word">super</span>.</p>
<section><pre><code class="language-kotlin">class Hijo() : Padre() {
    override var name = "hijo de ${super.name}"
    final override fun abierto() {
        super.abierto()
    }
} 
</code></pre></section><br><br>


<h3>Extensions</h3>
<p><span class="d-word">Extensions</span>  allow us to extend the functionality of a class without using <span class="negrita">inheritance</span>. 
  Kotlin supports extension <span class="cursiva">functions</span>  and extension <span class="cursiva">properties</span>. </p><p>Let's see an example:</p>

<section><pre><code class="language-kotlin">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponde con la lista
    this[index1] = this[index2]
    this[index2] = tmp
} 
</code></pre></section><br><br>
<p>From a syntactic point of view it is as if we have added a method to the MutableList class &lt;Int&gt; and all his descendants. 
  But the extension function does not modify the class, it is resolved statically.</p>
<p>In Java you will be used to using * <span class="cursiva">Utils</span>  classes, such as <span class="cursiva">FileUtils</span> ,
   <span class="cursiva">StringUtils</span>  or <span class="cursiva">java.util.Collections</span>. 
   These classes extend the functionality of others without using inheritance.
   The syntax is less readable than in Kotlin:</p>
<section><pre><code class="language-kotlin">//Wihout extension, swap function already exists in Collections
Collections.swap(lista, 2, 5); 	

//With extension, a new swap function is extended on Collections
lista.swap(2, 5) 
</code></pre></section><br><br>
<p>We can also extend a class with new properties. Let's see an example:</p>
<section><pre><code class="language-kotlin">val <Int> List<Int>.lastIndex: Int
    get() = size – 1 
</code></pre></section><br><br>








<h3>Data classes in Kotlin</h3>
<p>You are probably used to using <span class="d-word">POJO</span> ("Plain old Java Objects") classes in your projects. 
  They are very simple classes where the information necessary to represent an object is described, 
  but which interact with other classes or require external APIs.</p>

<p>Usually a <span class="d-word">POJO</span>  only provides us with a collection of fields. 
  Although we can also add functions that only involve objects of this class. 
  For example, the GeographicalPoint class could have longitude and latitude fields and a function that calculates the distance between two points.
</p>

<section><pre><code class="language-kotlin">data class Complejo(var real: Double, 
                    var imaginario: Double=0.0) 
</code></pre></section><br><br>
<p>All kinds of data include the following functions:</p>

<ul>
  <li><span class="d-word">equals()</span> : compares two objects.</li>
  <li><span class="d-word">hashCode()</span> : hash code of an object used by the previous method.</li>
  <li><span class="d-word">copy()</span> : copy an object.</li>
  <li><span class="d-word">toString()</span> : convert object to string.</li>
  <li><span class="d-word">component1()</span> , <span class="d-word">component2()</span> ,…: components in order of declaration.</li>
</ul>

<p>If a property is declared in the body of the class, instead of in the parent constructor, <span class="negrita">it will no longer have the indicated benefits</span>:</p>

<section><pre><code class="language-kotlin">data class Complejo(var real: Double, 
                    var imaginario: Double=0.0) {
    val irracional: Boolean = false
} 
</code></pre></section><br><br>
<p>In the previous example the <span class="cursiva">irracional</span> property is ignored in the equals(), hashCode(), copy(), toString() and componentX() functions.</p>
<p>Data classes must meet the following requirements:</p>

<ul>  
  <li>The primary constructor must have at least one parameter.</li>
  <li>All main constructor parameters must be marked as <span class="d-word">val</span>  or <span class="d-word">var</span> .</li>
  <li>Data classes cannot be <span class="d-word">abstract</span> , <span class="d-word">open</span> , <span class="d-word">sealed</span> , or <span class="d-word">internal</span> </li>
</ul>

<p>When copying an object we can change some of its properties:</p>
<section><pre><code class="language-kotlin">val c = Complejo(1.0, -1.0)
val c2 = c.copy(im = 0.0)
</code></pre></section><br><br>

<p class="sub-section">Destructured statements</p>
<p>Destructuring is the procedure by which we can extract multiple values ​​that are stored in objects and vectors. 
  Some times occasions it is necessary to deconstruct an object into different variables. It is done as follows:</p>

  <section><pre><code class="language-kotlin">val c = Complejo(1.0, -1.0); 
val (re, im) = c 
  </code></pre></section><br><br>

<p>In this way we can access each of the values ​​of a <span class="d-word">data class</span>  using a single assignment. 
  To access each property, the <span class="negrita">component1()</span> , <span class="negrita">component2()</span>,… functions are defined. </p>
<p>Those codes are similar.</p>
<section><pre><code class="language-kotlin">//A
val (re, im) = c 	

//B
val re = c.component1()
val im = c.component2() 
</code></pre></section><br><br>

<p>If we are not interested in any value, we use <span class="d-word">_</span> :</p>
<section><pre><code class="language-kotlin">val (_, im) = c 

  val im = c.component2() //Same result
</code></pre></section><br><br>

<p>We can use destructuring to return multiple values ​​from a function:</p>
<section><pre><code class="language-kotlin">data class Resultado(val res1: String, val res2: Int)

fun funcion(): Resultado {
    val res1 = "texto"
    val res2 = 3
    return Resultado(res1, res2)
}
// To use the function
val (res1, res2) = funcion()  
</code></pre></section><br><br>

<p>First we define a <span class="d-word">data class</span>  that has as attributes the types to return, so that the function has to return this class.</p>
</p>Another of the most common uses of destructuring is to decompose objects stored in a <span class="d-word">Map</span>  by their key identifier and value.</p>
<section><pre><code class="language-kotlin">val mapa = HashMap<String, Int>()
for ((clave, valor) in mapa) { … } 
</code></pre></section><br><br>


<h3>Kotlin class types: open, abstract, inner, and aliased</h3>

<p class="sub-section">Abstract classes</p>


<p>As with Java, Kotlin's <span class="d-word">abstract</span>  classes are classes that cannot be instantiated. Its purpose is to use them in order to provide a common template for other
   classes that extend them.
  The way to declare an abstract class is by using the <span class="d-word">abstract</span>  keyword. An <span class="d-word">abstract</span>  class can contain both abstract (marking them with the abstract keyword) and non-abstract properties and functions:</p>
  <section><pre><code class="language-kotlin">abstract class Vehiculo(val name: String,
                        val color: String,
                        val peso: Double) {   // no abstract properties
   abstract var maxVelocidad: Double   // abstract propertie
   abstract fun arrancar() // abstract functions
   abstract fun parar()
   fun muestraDetalless() {  // no abstract function
      println("name: $name, Color: $color, Velicidad: $maxVelocidad ")
   }
} 
  </code></pre></section><br><br>

<p>Any subclass that extends an <span class="d-word">abstract</span>  class must implement all of its <span class="d-word">abstract</span>  
  <span class="cursiva">methods</span>  and <span class="cursiva">variables</span> , or be declared abstract as well.</p>
<p>As we have seen above, in inheritance, it would be necessary to use the <span class="d-word">open</span>  keyword to indicate that we 
  can extends from that class. However, with <span class="d-word">abstract</span>  classes <span class="negrita">it is not necessary</span>
   to do so, since they incorporate this property by default.</p><p>Let's see an example of how to extend an abstract class:</p>

<section><pre><code class="language-kotlin">class Coche(name: String, color: String, peso: Double,
       override var maxVelocidad: Double): Vehiculo(name, color, peso) {
   override fun arrancar() {
      println("Coche arrancado")
   }
   override fun parar() {        
      println("Coche parado")
   }
} 
</code></pre></section><br><br>
<br>

<p class="sub-section">Nested and inner classes</p>
<p>In Kotlin, a class can be declared inside another, resulting in a <span class="d-word">nested</span>  class.</p>
<p>Nested class</p>
<section><pre><code class="language-kotlin">class Externa {
   private val propiedad: Int = 1
   class Anidada {
      fun funcion() = 2
   }
} 
</code></pre></section><br><br>
<p>Inner class</p>

<section><pre><code class="language-kotlin">class Externa {
   private val propiedad: Int = 1
   inner class Interna {
      fun funcion() = propiedad
   }
} 
</code></pre></section><br><br>
<p>If we put the <span class="d-word">inner</span>  modifier in front of a <span class="d-word">nested</span>  class, 
  we transform it into internal, with which we achieve that the class can access all the members of the external class.</p>


  <p class="sub-section">Type Alias</p>
  
<p>
  One of the interesting things we can do in Kotlin is assign an <span class="d-word">alias</span>  to a data type, that is very useful to shorten the name of data types
  when they are very long or if we want to clarify the meaning:</p>

  <section><pre><code class="language-kotlin">typealias GrupoPersonas = Set&lt;Persona>
typealias TablaFicheros<K> = MutableMap&lt;K, Mutable-List&lt;File>> 
</code></pre></section><br><br>
<p>It can even be applied to function types:</p>
<section><pre><code class="language-kotlin">typealias Manejador = (Int, String, Any) -> Unit
typealias Predicado<T> = (T) -> Boolean 
</code></pre></section><br><br>

<p>Use example</p>
<section><pre><code class="language-kotlin">typealias MyMapList = MutableMap&lt;Int,ArrayList&lt;String>>
typealias MyFun = (Int,String, MyMapList) -> Boolean

  //..........
  var myNewMap : MutableMap&lt;Int,ArrayList&lt;String>> = mutableMapOf()
  //using it
  var myNewMap : MyMapList = mutableMapOf()
  
  myNewMap[1] = arrayListOf("Hello", "World")
  myNewMap[2] = arrayListOf("PMDM", "2DAM")


  fun myHighFun(a:Int, mFun:MyFun){

  }
</code></pre></section><br><br>

<p class="sub-section">Sealed classes in Kotlin</p>
<p><span class="d-word">Sealed</span>  classes are used to represent a hierarchy of classes that inherit from a parent class, 
  so that both the <span class="negrita">parent</span>  class and the <span class="negrita">nested</span>  classes <span class="negrita">are defined together</span>  
  in the same file.</p>
<p>Let's imagine that we want to define the parent class <span class="d-word">Figura</span>  from which the <span class="d-word">Triangulo</span> , 
  <span class="d-word">Cuadrado</span>  and <span class="d-word">Circulo</span>  subclasses extend. As you can see, it is a technique to do polymorphism.</p>
<section><pre><code class="language-kotlin">sealed class Figura {
   class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figu-ra()
   class Cuadrado(val lado:Int) : Figura()
   class Circulo(val radio:Int) : Figura()
} 
</code></pre></section><br><br>
<p>Since Kotlin 1.1 it is no longer necessary for child classes to be nested within the parent class:</p>
<section><pre><code class="language-kotlin">sealed class Figura 
class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figura()
class Cuadrado(val lado:Int) : Figura()
class Circulo(val radio:Int) : Figura() 
</code></pre></section><br><br>
<p>A <span class="d-word">sealed</span>  class is declared as <span class="d-word">abstract</span> , when we create instances of this class 
  we are forced to <span class="negrita"> use one of its children</span>. Furthermore, a <span class="d-word">sealed</span>  class must be defined in a single file, 
  so the number of child classes <span class="negrita">cannot be expanded in the future</span>. 
  Which means that we will not be able to enlarge the type of figures. For this reason they are known as sealed. 
</p><p>Thanks to this fact, when we use them with a <span class="r-word">when</span>  expression, since it is possible to verify that all cases are covered,
   it will not be necessary to add the <span class="d-word">else</span> clause.
</p>

<section><pre><code class="language-kotlin">val figura: Figura = Triangulo()
val texto = when (figura) {
   is Triangulo -> "triangulo"
   is Cuadrado -> "cuadrado"
   is Circulo -> "circulo"
   else -> "sin definir" 
} 
</code></pre></section><br><br>

<p class="sub-section">object</p>

<p>In case that we are interested in considering the possibility that a <span class="d-word">figura</span>  is not defined, or even a type of <span class="d-word">figura</span> 
  that does not require storing a state, we add <span class="d-word">object</span>  elements to our <span class="d-word">sealed</span>  class:
</p>



<section><pre><code class="language-kotlin">sealed class Figura 
class Triangulo(val lado1:Int, val lado2:Int, val lado3:Int) : Figura()
…
object Punto : Figura()
object SinDefinir : Figura() 
</code></pre></section><br><br>

<p>we will have to incorporate these options to the <span class="d-word">when</span> block:</p>
<section><pre><code class="language-kotlin">val texto = when (figura) {
   is Triangulo -> "triangulo"
   …
   Punto -> "punto"
   SinDefinir -> "sin definir"
} 
</code></pre></section><br><br>
<p>Note that the new options are no classes, so we will not use is in the comparison.</p>
<p>To understand the difference between class and object, let's see how it works internally.</p>
<p>When it is a <span class="cursiva">Triangulo</span> , <span class="cursiva">Cuadrado</span>  or <span class="cursiva">Circulo</span>  type <span class="cursiva">Figura</span>,
 it will work normally. That is, a new object will be created in memory with all its properties.</p>
 <p>But when it is <span class="d-word">Punto</span>  or <span class="d-word">SinDefinir</span> , it will work differently. 
  The first time it is needed, an instance of the object will be created. These objects are only created once in memory. 
  The second time a variable with this value is needed, a <span class="negrita">new object will not be created</span> , 
  but this variable will be a reference to the previously created object. This behavior is the same as those listed, 
  which we will see in the next section. An object cannot extend the class with new properties, but it can overwrite its functions.</p> <p>Let's see it with an example:
</p>


<section><pre><code class="language-kotlin">sealed class Figura(open var color:Int=0) {
   abstract fun area(): Int

   class Cuadrado(override var color: Int,  
          val lado: Int) : Figura(color) {
      override fun area() = lado * lado
   }
   object Punto : Figura(1) {
      override fun area() = 0
      init {print("Punto Creado, ")}
   }
} 
</code></pre></section><br><br>

<section><pre><code class="language-kotlin">fun main(){
  val p1 = Figura.Punto
  val p2 = Figura.Punto
  val c = Figura.Cuadrado(2,8)

  p1.color = 3
  print("color c=${c.color}, ")
  print("color p2=${p2.color}")
}
</code></pre></section><br><br>
<a class="tarea" target="_blank" href="#">With the code above</a> 
<ol style="list-style-position: inside;">
  <li>Which is the exit?</li>
  <li>How do you explain that "Punto creado" apears just once?</li>
  <li>Why is the color of p2 3, if what we have changed is the color of p1?</li>
  <li>Why is the color of c still 2?</li>
  <li>How can we get each point to have its own color?</li>
</ol>

<section class="marco-t inf">
  <span class="icono info"> </span> <span class="negrita">Solution</span>
  </section>
<section class="marco-b">
  <p>When the <span class="d-word">Figura</span>  class is created, an instance is created for each object element. The example will create the <span class="d-word">Punto</span> 
    object. The creation of the variables <span class="cursiva">p1</span>  and <span class="cursiva">p2</span>  will <span class="negrita">not</span>  imply the creation of <span class="negrita">new objects</span> , 
    both will be references to the previous object. The initialization of c will mean the creation of a new object in memory, with its two properties. 
    In the following instruction, the color of <span class="cursiva">p1</span>  is modified, but since there is only one color, the color of <span class="negrita">p2</span>  is also modified.
  </p>

  <ol style="list-style-position: inside;">
    <li>Only one Point object is created.</li>
    <li>The variables <span class="cursiva">p1</span>  and <span class="cursiva">p2</span>  point to the same object.</li>
    <li>The variable <span class="cursiva">c</span>  is an independent object.</li>
    <li>We would use class <span class="d-word">Punto</span>  instead of object <span class="d-word">Punto</span> .</li>
  </ol>
    
</section>
  
<p>The previous example defined types of shapes. However, it is not necessary for the different subclasses to be related to each other. </p>
<p>We can use a <span class="d-word">sealed</span>  class to represent a variable that can take values ​​of different types, even though these types have no relation to each other.</p>
<p>For example, an <span class="d-word">HTTP request</span>  might return a <span class="negrita">web page</span>  or an <span class="negrita">error code</span> :</p>

<section><pre><code class="language-kotlin">sealed class RespuestaHTTP 
data class Correcta(val contenido: String) : Respuesta()
data class Error(val codigo: Int, val mesaje: String) : Respuesta()

fun getUrl(url: String): Respuesta {
   val valido = …
   if (valido) return Correcta("Contenido…")
   else        return Error(404, "No encontrada")
}

val respuesta = getUrl("/")
when (respuesta) {
   is Correcta -> println(respuesta.contenido)
   is Error -> println(respuesta.mesaje)
} 
</code></pre></section><br><br>


<h3>Enum classes in Kotlin</h3>

<p><span class="d-word">Enum</span>  classes allow us to declare a set of values ​​that a variable can take:</p>
<section><pre><code class="language-kotlin">enum class Estacion{PRIMAVERA, VERANO, OTOÑO, INVIERNO}
</code></pre></section><br><br>
<p>As in Java, an enum is defined by means of a <span class="r-word">class</span> , although now it is more obvious when having to indicate <span class="r-word">class</span>.
  Each one of the constants of an enum supposes the creation of an object. A variable of type <span class="d-word">Sesion</span>  is nothing more than a reference to one of these four objects. 
  We study it in detail in the next point. 
</p>
<p>Since each constant is an instance of the class, they can be initialized:</p>
<section><pre><code class="language-kotlin">enum class VersionAndroid(val api: Int) {
    JELLY_BEAN(16), KITKAT(19), MASHMALLOW(23), NOUGAT(24)
} 
</code></pre></section><br><br>
<p>An enum constant can also declare its own <span class="cursiva">methods</span>  and <span class="cursiva">properties</span> :</p>
<section><pre><code class="language-kotlin">enum class Estacion {
   PRIMAVERA { override fun temperatura() = 24.0 },
   VERANO { override fun temperatura() = 32.2 }; //Look at semicolon, starts parent class members.
   abstract fun temperatura(): Double
   var diasSoleados: Int = 0
} 
</code></pre></section><br><br>
<p>If an enumeration defines a member, it must be separated from the constants with a <span class="d-word">semicolon</span> , in the same way as we did in Java. 
  Likewise, enum classes in Kotlin have synthetic methods that allow you to list the defined constants (<span class="d-word">values​​()</span>)
   and obtain a constant by name (<span class="d-word">valueOf()</span> ). In addition, the <span class="d-word">name</span>  and <span class="d-word">ordinal</span> properties are defined in each constant:
</p>

<p class="sub-section">Comparison of enum and sealed classes</p>
<p><span class="d-word">Sealed</span>  class looks like <span class="d-word">enum</span> classes, but they are not exactly the same. 
  <span class="d-word">Sealed</span>  classes are an extension of enum classes, since the possible set of values ​​of an enumerated type is also restricted,
   but while each constant of the enumerated type only exists as a single instance, a subclass of a class sealed can have multiple instances.
</p>
<p>enum class</p>
<section><pre><code class="language-kotlin">enum class Estacion { 
   PRIMAVERA, 
   VERANO, 
   …
}
</code></pre></section><br><br>
<p>Sealed class</p>
<section><pre><code class="language-kotlin">sealed class Estacion() {
   object PRIMAVERA: Estacion() 
   object VERANO: Estacion() 
   …
} 
</code></pre></section><br><br>

<p>Both classes below have the same behavior as an abstract class, avoiding a direct instantiation of them, while allowing us to declare abstract methods:
</p>
<section><pre><code class="language-kotlin">enum class Direcciones {
   ARRIBA   { override fun direccion(x: Int, y: Int) = x to (y - 1) },
   IZQUIERDA{ override fun direccion(x: Int, y: Int) = (x - 1) to (y) },
   DERECHA  { override fun direccion(x: Int, y: Int) = (x + 1) to (y) },
   ABAJO    { override fun direccion(x: Int, y: Int) = x to (y + 1) };
   abstract fun direccion(x: Int, y: Int): Pair<Int, Int>
}
sealed class Intention {
   object None : Intention() {
      override fun log() { println("none") }
   }
   object Refresh : Intention() {
      override fun log() { println("refresh") }
   }
   data class Error(val reason: String) : Intention() {
      override fun log() { println("error") }
   }
   data class LoadContent(val content: List<String>) : Intention() {
      override fun log() { println("loadContent") }
   }
   abstract fun log()
} 
</code></pre></section><br><br>
<p>On the other hand, an <span class="d-word">enumerated</span>  class can only create one instance of each constant,
   while we can have several instances of the subclasses of a <span class="d-word">sealed</span>  class. </p>
<p>Depending on what we want to do, we can use one or the other. That is, if we need constant behavior, we will use an enumerated class, and otherwise a sealed class.</p>



  <!--*********************************************************Initialization with lateinit vs lazy***********************************************************-->
  <a name="sLateinit"><a>
  <h2>Initialization with lateinit vs lazy</h2>

  <p>Normally, those variables that are not declared null must be initialized in the constructor. 
    However, this is often not the best option. In case we don't want to initialize a property in the constructor, we have two alternatives, <span class="d-word">lateinit</span> 
     and <span class="d-word">lazy</span> .
    By means of <span class="d-word">lateinit</span>  what we get is a <span class="cursiva">late</span> initialization, indicating to the compiler that said initialization 
    will be done later in the code. If we try to access a variable before its initialization, we will get an error of the type Caused by:</p>
    <section class="marco-t err">
      <span class="icono error"> </span> <span class="negrita">kotlin.UninitializedPropertyAccessException: lateinit property test has not been initialized.</span>
      </section>
    <section class="marco-b">
        
    </section>

    <section><pre><code class="language-kotlin">lateinit var text: String
fun doSomething() {
   text = "a value"
   println("Length is "+text.length)
   texto = "Another value"
} 
    </code></pre></section><br><br>

<p>The <span class="d-word">lateinit</span>  modifier can only be used in mutable variables (<span class="negrita">var</span> ) declared in the body of a class 
  (not the one in the primary constructor), and only when that variable does not have a custom getter or setter.</p>
<p>Through <span class="d-word">lazy</span>  what we get is a lazy initialization, so a variable will not be initialized unless it is used in our code. 
  It will be initialized only once, then it will keep the value.</p>

<section><pre><code class="language-kotlin">public class Example{
   val name: String by lazy { "Rosa López" }

   if(condition) print("${name.length}") //Initialization takes place here
} 
</code></pre></section><br><br>

<p>In the example above, both the first and subsequent calls to name will return "Rosa López".</p>
<br><br>
<p>Once we know what each of these functions does, when should we use each one?</p>

<p>
  <ul>
    <li><span class="d-word">lazy</span>  can only be used for immutable <span class="d-word">val</span>  variables, while 
      <span class="d-word">lateinit</span>  can only be applied to mutable var variables, 
      since the immutability of that variable cannot be ensured because it cannot be compiled as <span class="d-word">final</span> </li>
    <li> A variable of type <span class="d-word">lateinit</span>  can be initialized anywhere in the object where it is visible. 
      If we need our variable to be initialized from outside, in an unknown way beforehand, we will have to use <span class="d-word">lateinit</span> </li>
  </ul>
</p>



<!--*********************************************************Let, run, also, apply, with***********************************************************-->
<a name="sModismos"><a>
<h2>Let, run, also, apply, with</h2>

<p>we’ll be implementing some of the important standard library functions available in Kotlin. The <span class="d-word">kotlin-stdlib</span>  provides us with useful <span class="d-word">higher order</span> 
   functions implementing idiomatic patterns. We’ll see how they make programming in Kotlin so easier and faster.</p>

  <p>The functions that we’re going to discuss below are:</p>
  <ul>
    <li>let</li>
    <li>run</li>
    <li>also</li>
    <li>apply</li>
    <li>with</li>
  </ul>

  <h3>Koltin let</h3>

  <p><span class="d-word">let</span>  takes the object it is invoked upon as the parameter and returns the result of the lambda expression.
    Kotlin let is a scoping function wherein the variables declared inside the expression cannot be used outside.</p>
    
    <p>An example demonstrating kotlin let function is given below.</p>
<section><pre><code class="language-kotlin">fun main(args: Array<String>) {
        var str = "Hello World"
        str.let { println("$it!!") }
        println(str)
    
    }
    //Prints
    //Hello World!!
    //Hello World
</code></pre></section><br><br>
<p><span class="d-word">it</span> keyword contains the copy of the property inside <span class="d-word">let</span> .</p>
    
    
  <p>The last value from the <span class="d-word">let</span>  is returned as an argument as shown below.</p>
  <section><pre><code class="language-kotlin">var strLength = str.let { "$it function".length }
println("strLength is $strLength") //prints strLength is 20
  </code></pre></section><br><br>

  <p class="sub-section">Chaining let functions</p>

  <section><pre><code class="language-kotlin">var a = 1
var b= 2

a = a.let { it + 2 }.let { val i = it + b
        i}
println(a) //5
  </code></pre></section><br><br>

 <p class="sub-section">Nesting let</p>

 <p>We can set a let expression inside another let expression as shown below.</p>
 <section><pre><code class="language-kotlin">var x = "Anupam"
x.let { outer -> outer.let { inner -> print("Inner is $inner and outer is $outer") } }

//Prints
//Inner is Anupam and outer is Anupam
 </code></pre></section><br><br>

 <p>For <span class="d-word">nested</span>  let, we can’t use <span class="d-word">it</span>  keyword. We need to assign explicit names to <span class="d-word">it</span>  in both the let functions.
  Only the outermost let returns the value as shown below.</p>

<section><pre><code class="language-kotlin">var x = "Anupam"
    x = x.let { outer ->
        outer.let { inner ->
            println("Inner is $inner and outer is $outer")
            "Kotlin Tutorials Inner let"
        }
        "Kotlin Tutorials Outer let" 
    }
    println(x) //prints Kotlin Tutorials Outer let
</code></pre></section><br><br>

<p class="sub-section">let for null checks</p>

<p>Additionally, let is useful for checking <span class="d-word">Nullable</span>  properties as shown below.</p>


<section><pre><code class="language-kotlin">var name : String? = "Kotlin let null check"
name?.let { println(it) } //prints Kotlin let null check
name = null
name?.let { println(it) } //nothing happens
</code></pre></section><br><br>

<p>The code inside the let expression is executed only when the property is not null. Thus let saves us from the <span class="d-word">if else</span>  null checker too!</p>

<h3>Kotlin run</h3>

<p>Kotlin <span class="d-word">run</span>  is another interesting function. The following example demonstrates its use cases.</p>
<section><pre><code class="language-kotlin">var tutorial = "This is Kotlin Tutorial"
    println(tutorial) //This is Kotlin Tutorial
    tutorial = run {
        val tutorial = "This is run function"
        tutorial
    }
    println(tutorial) //This is run function
</code></pre></section><br><br>

<p>Kotlin run expression can change the outer property. Hence in the above code, we’ve redefined it for the local scope.</p>
<ul>
  <li>Similar to the <span class="d-word">let</span>  function, the run function also returns the last statement.</li>
    <li>Unlike let, the <span class="d-word">run</span>  function doesn’t support the <span class="d-word">it</span>  keyword.</li>
</ul>

<p class="sub-section">let and run</p>
<p>Let’s combine the let and run functions together.</p>
<section><pre><code class="language-kotlin">var p : String? = null
    p?.let { println("p is $p") } ?: run { println("p was null. Setting default value to: ")
        p = "Kotlin"}

    println(p)
//Prints
//p was null. Setting default value to: 
//Kotlin
</code></pre></section><br><br>


<h3>Kotlin also</h3>
<p>As the name says, <span class="d-word">also</span>  expressions does some additional processing on the object it was invoked.</p>
<p>Unlike let, it returns the original object instead of any new return data. Hence the return data has always the same type.
  Like <span class="d-word">let</span> , <span class="d-word">also</span>  uses <span class="d-word">it</span>  too.</p>

<section><pre><code class="language-kotlin">var m = 1
m = m.also { it + 1 }.also { it + 1 }
println(m) //prints 1 
</code></pre></section><br><br>

<p class="sub-section">Kotlin let vs also</p>

<p>Following code snippet shows a great example to differentiate between <span class="d-word">let</span>  and <span class="d-word">also</span> .</p>
<section><pre><code class="language-kotlin">data class Person(var name: String, var tutorial : String)
fun main(args: Array<String>) {
    var person = Person("Carlos", "Kotlin")

    var l = person.let { it.tutorial = "Android" }
    var al = person.also { it.tutorial = "Java" }

    println(l)
    println(al)
    println(person)

}
/*Prints
kotlin.Unit
Person(name=Carlos, tutorial=Java)
Person(name=Carlos, tutorial=Java)
  */
</code></pre></section><br><br>

<p class="sub-section">Kotlin apply</p>
<p>Kotlin <span class="d-word">apply</span>  is an extension function on a type. 
  It runs on the object reference (also known as receiver) into the expression and returns the object reference on completion.</p>
<section><pre><code class="language-kotlin">data class Person(var name: String, var tutorial : String)
var person = Person("Carlos", "Kotlin")

person.apply { this.tutorial = "Swift" }
println(person)
</code></pre></section><br><br>

<p class="sub-section">apply vs also</p>
<span class="d-word">data class Person(var n: String, var t : String)
var person = Person("Carlos", "Kotlin")

person.apply { t = "Swift" }
println(person)

person.also { it.t = "Kotlin" }
println(person)</span> 


<p>Note: In <span class="d-word">apply</span>  <span class="r-word">it</span>  isn’t allowed. If the property name of the data class is unique in the function, you can omit <span class="r-word">this</span>.</p>

  <p>We should use <span class="d-word">also</span>  only when we don’t want to shadow <span class="d-word">this</span> .</p>


<h3>Kotlin with</h3>
<p>Like <span class="d-word">apply</span> , <span class="d-word">with</span>  is used to change instance properties without the need to call <span class="negrita">dot</span>  operator over the reference every time.</p>
  
  
<section><pre><code class="language-kotlin">data class Person(var name: String, var tutorial : String)
var person = Person("Carlos", "Kotlin")

with(person)
    {
        name = "No Name"
        tutorial = "Kotlin tutorials"
    }
</code></pre></section><br><br>

<p>Again <span class="d-word">with</span>  is similar to <span class="d-word">apply</span>  except for a few differences.</p>

<p class="sub-section">Kotlin apply vs with</p>
<ul>
<li>with runs without an object(receiver) whereas apply needs one.</li>
<li>apply runs on the object reference, whereas with just passes it as an argument.</li>
<li>The last expression of with function returns a result.</li>
</ul>

<section><pre><code class="language-kotlin">var xyz = with(person)
{
    name = "No Name"
    tutorial = "Kotlin tutorials"
    val xyz = "End of tutorial"
    xyz
}
println(xyz) //End of tutorial
</code></pre></section><br><br>
<p>That’s all for Kotlin standard functions to alter variables or modify objects within the function.</p>





<!--*********************************************************Exercises***********************************************************-->
<a name="sExercises"><a>
<h2>Exercises</h2>

<div class="" style="width: 100%;">
  <p>Practice with those exercises from <a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> </p> <br>
  <iframe src="https://play.kotlinlang.org/koans/Introduction/Hello,%20world!/Task.kt" frameborder="1" style="width: 100%;height: 1500px;"></iframe>
</div>


<!--*********************************************************Webgrafia***********************************************************-->

<a name="s"><a>
<h2>Webgrafia</h2>
<ul>
  <li><a class="enlace" target="_blank" href="http://www.androidcurso.com/index.php/99-kotlin/">http://www.androidcurso.com/index.php/99-kotlin/</a> </li>
  <li><a class="enlace" target="_blank" href="https://www.journaldev.com/19467/kotlin-let-run-also-apply-with">https://www.journaldev.com/19467/kotlin-let-run-also-apply-with</a> </li>
  <li><a class="enlace" target="_blank" href="https://kotlinlang.org/">https://kotlinlang.org/</a> </li>
</ul>


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
  <script src="../script/prism.js"></script>
</body>
</html>
