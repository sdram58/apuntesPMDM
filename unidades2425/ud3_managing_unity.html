<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD3.- Managing Unity</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">    
      <a href="#sManejo_de_Unity" title="1.- Handling Unity">1.- Handling Unity</a>
    </div>
    
  </nav> <!-- BTM_MENU-->
  
  <h1>UD3.- Managing Unity</h1> 

  
  <div class="main-menu">    
    <div class="fila">
      <a href="#sIntroduccion" title="1.- Introduction">1.- Introduction</a>
      <a href="#sUnityHub" title="2.- Unity Hub">2.- Unity Hub</a>
      <a href="#sInstalacionUnity" title="3.- Unity Installation">3.- Unity Installation</a>
    </div>    
    <div class="fila">
      <a href="#sCrear_Proyecto_Unity" title="4.- Create Unity Project">4.- Create Unity Project</a>
      <a href="#sEditor_Unity" title="5.- Unity Editor">5.- Unity Editor</a>
      <a href="#sEjecución_del_juego" title="6.- Game Execution">6.- Game Execution</a>
    </div>
    
    <div class="fila">
      <a href="#sAnyadiendo_codigo_ejecutable" title="7.- Adding Executable Code">7.- Adding Executable Code</a>
      <a href="#sScripting" title="8.- Scripting">8.- Scripting</a>
      <a href="#sManejo_de_Unity" title="9.- Handling Unity">9.- Handling Unity</a>
    </div>
</div>


  
  <!--*********************************************************Introducción***********************************************************-->
  <section class="apartado">
    <a name="sIntroduccion"></a>
    <h2>Introduction</h2>
    <h3>What is Unity?</h3>
    <p>Unity is a cross-platform game engine.</p>
    <p>It originated in 2005.</p>
    <p>It allows for the development of 2D and 3D games.</p>
    <p>Currently, Unity supports development for around 20 platforms, with the most popular being PC, iOS, and Android.</p>
    <p>Unity offers such a comprehensive set of tools that it minimizes the need for external tools to complete projects.</p>
 
</section><!-- End section Introducción-->

<!--*********************************************************Unity Hub***********************************************************-->
<section class="apartado">
  <a name="sUnityHub"></a>
  <h2>Unity Hub</h2>
  
  <p>The <a class="enlace" target="_blank" href="https://unity.com/es/pricing?check_logged_in=1#plans-student-and-hobbyist">Unity Hub</a> program allows you to manage the versions of the Unity editor that you want to use.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-08-33.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>To use Unity Hub, you need to have a <span class="negrita">Unity ID</span></p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-09-03.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can also create the Unity ID from the Unity website:
  <a class="enlace" target="_blank" href="https://id.unity.com/es/">https://id.unity.com/es/</a>
  </p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-09-38.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>By having a Unity ID, in addition to being able to use the game engine (license for use), you can also access the <span class="negrita">Unity Asset Store</span>
     where you can download both free and paid assets.</p>
  
     <p><a class="enlace" target="_blank" href="https://assetstore.unity.com/">https://assetstore.unity.com/</a></p>
     
  <figure><img src="UD9/images/ud9-2024-01-24-12-10-47.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
  </section><!-- End section Unity Hub-->
  
  
  <!--*********************************************************Unity Installation***********************************************************-->
  <section class="apartado">
  <a name="sInstalacionUnity"></a>
  <h2>Unity Installation</h2>
  <p>To develop video games, you need the <span class="negrita">Unity editor</span>.</p>
  
  <p>The first time you log in to Unity Hub with your Unity ID, you will be prompted to install a Unity editor.</p>
  
  <p>By default, the Unity editor that will be installed is the latest stable version, <span class="negrita">LTS</span> (Long Term Support).</p>
  
  <p>This default installation is not recommended as it does not allow for installation customization.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-12-31.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>From the <span class="negrita">Installs</span> section in <span class="negrita">Unity Hub</span>, you can install different versions of the available Unity editor:</p>
  
  <figure><img src="UD9/images/ud9-2024-01-24-12-35-16.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>You must choose which configuration you want for the Unity editor that will allow you to create game executables for each platform, add Asian languages, and include Unity documentation.</p>
  <p>For class purposes, it will be enough to select <span class="negrita">Linux Build Support (IL2CPP)</span>.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-36-15.png" /><br><figcaption></figcaption></figure>
  <br>
  <h3>Code Editor</h3>
  <p>Unity requires a code editor for scripting, and during the installation on Windows, <span class="negrita">Microsoft Visual Studio Community</span> is included. 
    In class, those who have it will detect <span class="negrita">Visual Studio Code</span> and set it as the default editor.</p>
  
  <p>If you do not have that editor installed and do not want to install it, you should uncheck it.</p>
  
  <p>If you use <span class="negrita">Microsoft Visual Studio Community</span> or <span class="negrita">Visual Studio Code</span>
     as the default editor, you can install the extensions for the <span class="negrita">C#</span> programming language, which is used with Unity.</p>
  
  <figure><img src="UD9/images/ud9-2024-01-24-12-38-44.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>If you do not have <span class="negrita">Microsoft Visual Studio Community</span> installed and do not want to install it, you should uncheck it.</p>
  <p>You can use any other code editor by changing the Unity editor's settings once installed. 
    In <span class="negrita">Menu &rarr; Edit &rarr; Preferences</span>.</p>
  
    <figure><img src="UD9/images/ud9-2024-01-24-12-40-06.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>If needed later in the development process, you can add/remove modules to the editor.</p>
    
  <figure><img src="UD9/images/ud9-2024-01-24-12-40-35.png" /><br><figcaption></figcaption></figure>
  </section><!-- End section Unity Installation-->
  

<!--*********************************************************Create Unity Project***********************************************************-->
<section class="apartado">
  <a name="sCrear_Proyecto_Unity"></a>
  <h2>Create Unity Project</h2>
  
  <p>Unity HUB will be the starting point for any Unity project. In its window, you can see the sections:
    <ul>
      <li><span class="negrita">Projects</span>: project manager.</li>
      <li><span class="negrita">Installs</span>: manager of installed Unity editors.</li>
      <li><span class="negrita">Learn</span>: self-learning section</li>
      <li><span class="negrita">Community</span>: access to the community with sections such as Asset Store or Forums.</li>
    </ul>
  </p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-43-08.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>From <span class="negrita">Unity Hub</span>, in the <span class="negrita">Projects</span> section, you can create projects by clicking the <span class="d-word">New project</span> button.</p>
  
  <figure><img src="UD9/images/ud9-2024-01-24-12-43-46.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>When creating a project, you need to <span class="negrita">choose the type of project</span> so that the necessary libraries are loaded.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-44-24.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Once the project is created, it will be available in Unity Hub.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-45-11.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>During creation, <span class="subrayado">the Unity editor will open</span> for that project.</p>
  
  <div class="tarea">
    <p><span class="negrita">Activity 1:</span> <br>Installation of a Unity editor.</p>
    <p><span class="negrita">Activity 2:</span> <br>Create the project <span class="negrita">TestYourName</span>.</p>
  </div>
  
  </section><!-- End section Create Unity Project-->
  
<!--*********************************************************Unity Editor***********************************************************-->
<section class="apartado">
  <a name="sEditor_Unity"></a>
  <h2>Unity Editor</h2>
  <p>By default, the Unity editor window looks like this:</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-47-45.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Unity uses <span class="negrita">Object-Oriented Programming</span>, 
    which is why all game elements are included in the object hierarchy.</p>
  
  <p>The <span class="negrita">game</span> occupies the highest position in the hierarchy and 
    within it are the <span class="negrita">scenes</span>, which can be considered the screens of the game.</p>
  
  <p>The <span class="negrita">hierarchy</span> shows all the elements in a scene.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-49-46.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Within each scene, you must add all the necessary elements, 
    these elements are <span class="d-word">GameObjects</span>. Scenes also follow a hierarchical structure, allowing <span class="negrita">GameObjects</span>
    to be grouped within each other.</p>
  
  <p>By default, a Unity project contains a <span class="negrita">Scene</span> that in turn contains a <span class="negrita">GameObject</span>
     of type <span class="negrita">camera</span> called <span class="d-word">Main Camera</span> and a <span class="negrita">GameObject</span> of type 
     <span class="negrita">light</span> called <span class="d-word">Directional Light</span>.</p>
  
    <p>In the central part of the editor, you can see a <span class="negrita">scene view</span> which,
      when you press the play button, will become <span class="negrita">the view from the camera configured in the game</span>.</p>
      <figure><img src="UD9/images/ud9-2024-01-24-12-52-56.png" /><br><figcaption></figcaption></figure>
      <br>
      <p>When you select an object in the scene, the <span class="negrita">Inspector</span> displays all its characteristics.</p>
      
  <figure><img src="UD9/images/ud9-2024-01-24-12-53-48.png" /><br><figcaption></figcaption></figure>
  <br>
  
      <p>From the code, you can access the components of each object.</p>
     
    <p>Each type of object will have default components, and additional components can be added if needed.</p>
    <figure><img src="UD9/images/ud9-2024-01-24-12-54-33.png" /><br><figcaption>Main Camera</figcaption></figure>
    <br>
    <figure><img src="UD9/images/ud9-2024-01-24-12-54-55.png" /><br><figcaption>Directional Light</figcaption></figure>
    <br>
    <p>The <span class="negrita">File Manager</span> allows you to view and perform all required actions on the project files.</p>
    <p>It is recommended that all folders and files you want to create be created from the file manager in the editor.</p>
    
     <figure><img src="UD9/images/ud9-2024-01-24-12-55-54.png" /><br><figcaption></figcaption></figure>
     <br>
    <p>The official documentation contains all the information about the Unity interface: 
      <a class="enlace" target="_blank" href="https://docs.unity3d.com/2023.3/Documentation/Manual/UsingTheEditor.html">https://docs.unity3d.com/2023.3/Documentation/Manual/UsingTheEditor.html</a>
    </p>
    
    <figure><img src="UD9/images/ud9-2024-01-24-12-56-39.png" /><br><figcaption></figcaption></figure>
      
     
  </section><!-- End section Unity Editor-->
  

<!--*********************************************************Game Execution***********************************************************-->
<section class="apartado">
  <a name="sEjecución_del_juego"></a>
  <h2>Game Execution</h2>
  <p>When the <span class="negrita">game is running</span> (the "Play" ▶ button on the top bar), the view section changes to the camera view and
     the entire interface darkens.</p>
  
  <p>While the game is running, you can work with the project to see how it reacts to different values, 
    but <span class="negrita">changes only persist during the game execution</span>.</p>
  
  <p>Since there is almost no difference in style between the two states, sometimes it’s easy to forget that the game is running and lose changes.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-12-59-27.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>From the <span class="negrita">Menu &rarr; Edit &rarr; Preferences</span> in the <span class="negrita">Colors</span> section,
     you can decide which color will overlay the interface when the game is running: <span class="negrita">Playmode tint</span>.</p>
  
  <p>It's helpful to choose a mode that provides high contrast so you can always know if the game is running or not.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-00-34.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Once the color is changed, it’s much easier to see that the game is running.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-01-12.png" /><br><figcaption></figcaption></figure>
  
  </section><!-- End section Game Execution-->
  

<!--*********************************************************Adding Executable Code***********************************************************-->
<section class="apartado">
  <a name="sAnyadiendo_codigo_ejecutable"></a>
  <h2>Adding Executable Code</h2>

  <p>To add executable code to the project, you need to create files to contain the code; these files are called <span class="negrita">scripts</span>.</p>
  <p>There are several ways to add scripts to the project, but the most appropriate method is through the file manager.</p>
  <p>Additionally, it is important to maintain good file organization, so it is common to create a folder named <span class="inline-folder">Scripts</span> 
    within the <span class="inline-folder">Assets</span> folder and place all necessary scripts there.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-14-52.png" /><br><figcaption></figcaption></figure>
  <br>

  <p>Once the <span class="inline-folder">Scripts</span> folder is created, right-click on it or on the folder icon in the manager and select <span class="negrita">Create &rarr; C# Script</span></p>

  <figure><img src="UD9/images/ud9-2024-01-24-13-15-46.png" /><br><figcaption></figcaption></figure>
  <br>

  <p>At this point, you should type the name of the file, <span class="subrayado">following C# naming conventions similar to Java</span>
     (<span class="negrita">CamelCase</span> with the first letter capitalized).</p>

  <p>Also, the script should have a name that clearly identifies the actions it performs.</p>

  <p>When a Script is selected in the File Manager, you can see its code in the Inspector, but it cannot be edited from there.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-16-57.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Double-clicking the Script will open it in the configured code editor.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-37-10.png" /><br><figcaption>Microsoft Visual Studio Community</figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-01-24-13-37-44.png" /><br><figcaption>Visual Studio Code</figcaption></figure>
  <br>

  <h3>Default Structure of a Unity Script</h3>
  <p>A default Unity Script has the following structure:</p>

  <figure><img src="UD9/images/ud9-2024-01-24-13-39-20.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>The frequency with which a game loop executes can vary, so the <span class="r-word">Update</span> method does not always run the same number of times.</p>

  <p>The following code will make messages appear in the console when the script runs.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-40-27.png" /><br><figcaption></figcaption></figure>
  <br>

  <p>To test this, click the "Play" ▶ button in the top center of the Unity editor.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-40-42.png" /><br><figcaption></figcaption></figure>
  <br>

  <p>As seen, no messages appear in the <span class="negrita">Console</span> tab.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-41-31.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>This is because <span class="negrita">to run a script, it must be attached to a GameObject</span>.</p>

  <p>You can attach a script to a GameObject by dragging the script from the task manager to the GameObject in various ways:
    <ul>
      <li>Dragging the script onto the GameObject in the hierarchy.</li>
      <li>Dragging the script onto the GameObject in the scene view.</li>
      <li>Selecting the GameObject and dragging the script onto the Inspector.</li>
    </ul>
  </p>

  <p>Once a script is attached to a GameObject, it becomes a component of the GameObject and appears in the Inspector.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-42-50.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Now, when running the game, the created script will execute.</p>
  <figure><img src="UD9/images/ud9-2024-01-24-13-45-10.png" /><br><figcaption></figcaption></figure>
  <br>

  <p>It is important to check the <span class="negrita">Collapse</span> option, which will consolidate messages with the same content into a single line and increase the count of occurrences.</p>

  <p>Also, enabling the <span class="negrita">Stats</span> option in the view can provide information such as the <span class="negrita">FPS</span> (frames per second) at which the game is running.</p>
  
  <figure><img src="UD9/images/ud9-2024-01-24-13-45-54.png" /><br><figcaption></figcaption></figure>
  <br>
  <hr>
  <div class="tarea">
    <p>Activity 3: <br>Create a Script named MiPrimerScript that displays "Hello, world!" and attach it to the Main Camera. Then remove it and attach it to the Directional Light, 
      and finally create an EmptyObject and attach it to that. Is there any difference?</p>
  </div>

</section><!-- End section Adding Executable Code-->


<!--*********************************************************Scripting***********************************************************-->
<section class="apartado">
<a name="sScripting"></a>
<h2>Scripting</h2>
<p>Like any software application, games need their functionality to be coded.</p>

<p>In Unity, functionality is coded through <span class="negrita">scripts</span>.</p>

<p>With scripts, you can:
  <ul>
    <li>Respond to player inputs.</li>
    <li>Execute events at the right moment.</li>
    <li>Create graphical effects.</li>
    <li>Control the physical behavior of GameObjects.</li>
    <li>Implement an AI system for game NPCs.</li>
    <li>…</li>
  </ul>
</p>

<p>Currently, the only recommended programming language for creating projects with Unity is <span class="r-word">C#</span>.</p>
<p>There is also support for <span class="negrita">UnityScript</span>, which was designed from JavaScript specifically for Unity, but its use is discouraged. It is possible that some current projects may still have scripts in UnityScript.</p>
<p>Previously, the language <span class="negrita">Boo</span>, which had a syntax similar to Python, could also be used. Today, it is no longer supported.</p>

<p><span class="negrita">C#</span> was created in 2000 to be compatible with the <span class="cursiva">.NET platform from Microsoft</span>.</p>

<p>It inherits the best features from C++, Java, and Visual Basic.</p>

<p>It is a native object-oriented language.</p>

<p>Thanks to the IL2CPP library, scripts created in Unity are converted to C++ scripts so that the native compiler can complete the compilation on the target platform.</p>

<p>A Unity script has the following basic structure:
  <ul>
    <li><span class="negrita">UnityEngine</span>: imports the MonoBehaviour class needed to define scripts associated with GameObjects.</li>
    <li><span class="negrita">System.Collections</span>: .NET library with lists, arrays, hash tables, etc.</li>
    <li> Defined class that extends MonoBehaviour:
      <ul>
        <li><span class="negrita">Start Method</span>: used to initialize the GameObject.</li>  
        <li><span class="negrita">Update Method</span>: executed once per frame, also known as the game loop.</li>
      </ul>
    </li>
  </ul>
</p>

<p>In C#, all instructions must end with <span class="d-word">;</span> <span class="subrayado">just like in Java</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-24-13-54-35.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Data Types in C#</h3>
<p class="sub-section">Basic data types in C# are:</p>

<figure><img src="UD9/images/ud9-2024-01-24-13-55-57.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Compound data types:</p>

<p>
    <ul>
      <li><span class="negrita">Array</span>: a collection of one data type.</li>
      <li><span class="negrita">List</span>: dynamic lists (can modify their size).</li>
    </ul>
  </p>
  
<p class="sub-section">Data types specific to C# for Unity are:</p>

<p>
  <ul>
    <li><span class="negrita">Vector3</span>: a package of three floats (x, y, z) that facilitates working with points, vectors, and directions within 3D space.</li>
    <li><span class="negrita">GameObject</span>: reference to a GameObject in the scene or a prefab from the project.</li>
    <li><span class="negrita">Transform, Rigidbody, or any other component</span>: reference to such a component within a GameObject.</li>
    <li><span class="negrita">Texture, Material, or any other type of asset</span>: reference to an asset from the project.</li>
  </ul>
</p>

<h3>Operators</h3>
<p>The operators are similar to those used in Java:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-27-24.png" /><br><figcaption></figcaption></figure>
<br>
<p>The <span class="r-word">Mathf</span> class allows calculations with <span class="r-word">float</span> numbers:</p>

<p>Examples:
  <ul>
    <li>Mathf.Abs(number)</li>
    <li>Mathf.Round(number)</li>
    <li>Mathf.Ceiling(number)</li>
    <li>Mathf.Floor(number)</li>
    <li>Mathf.Max(a, b, c, d)</li>
    <li>Mathf.Min(a, b, c, d)</li>
    <li>Mathf.Pow(number, exponent)</li>
    <li>Mathf.Sqrt(number)</li>
    <li>…</li>
  </ul>
</p>


<h3>Variables</h3>

<p>Variables in C# are defined just like in Java:</p>

	<section><pre><code class="language-kotlin">int age;</code></pre>
  </section><br>

<p>They can also be initialized at declaration:</p>

	<section><pre><code class="language-kotlin">int age = 21;</code></pre>
  </section><br>

<p>Once declared, their value can be changed at any time:</p>

	<section><pre><code class="language-kotlin">age = 22;</code></pre>
  </section><br>

<p>If variables are declared for the class as properties, their access can be set as <span class="negrita">public</span> or <span class="negrita">private</span>.</p>
<p>If a variable is declared within a method, the access type should not be declared as it will only be visible within that method.</p>

<figure><img src="UD9/images/ud9-2024-01-25-10-30-33.png" /><br><figcaption></figcaption></figure>
<br>

<p>Variables declared as public properties <span class="subrayado">will be visible from the Unity Inspector</span> during runtime, allowing their values to be changed from there during execution.</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-31-18.png" /><br><figcaption></figcaption></figure>
<br>

<p>It should be noted that changes made during execution are temporary, and when execution stops, it will return to the initial state.</p>

<h3>Control Structures</h3>

<figure><img src="UD9/images/ud9-2024-01-25-10-48-49.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Arrays</h3>
<p class="sub-section">Declare an <span class="negrita">Array</span></p>
<p>You can specify its size and then assign values:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-49-57.png" /><br><figcaption></figcaption></figure>
<br>

<p>You can declare it by directly assigning values:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-50-13.png" /><br><figcaption></figcaption></figure>

<p class="sub-section">Iterate through an <span class="negrita">Array</span></p>
<p>Using a <span class="negrita">for</span> loop:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-51-21.png" /><br><figcaption></figcaption></figure>
<br>

<p>Using a <span class="negrita">foreach</span> loop:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-51-40.png" /><br><figcaption></figcaption></figure>

<h3>Lists</h3>
<p><span class="negrita">Lists</span> allow modification of their size and addition/removal of elements.</p>

<p>You need to import the library:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-04.png" /><br><figcaption></figcaption></figure>
<br>

<p>Declare an empty list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-18.png" /><br><figcaption></figcaption></figure>
<br>

<p>Declare a list by assigning data:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-56-33.png" /><br><figcaption></figcaption></figure>
<br>

<p><span class="negrita">Lists</span> allow modification of their size and addition/removal of elements.</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-17.png" /><br><figcaption></figcaption></figure>
<br>

<p>Modifying elements is done similarly to Arrays:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-36.png" /><br><figcaption></figcaption></figure>
<br>

<p>Add elements to a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-57-57.png" /><br><figcaption></figcaption></figure>
<br>

<p>Remove elements from a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-58-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Get the length of a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-10-58-36.png" /><br><figcaption></figcaption></figure>
<br>

<p>Remove all elements from a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-00-32.png" /><br><figcaption></figcaption></figure>
<br>

<p>Check if a value is in a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-00-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Sort a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-01-05.png" /><br><figcaption></figcaption></figure>
<br>

<p>Reverse the order of a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-01-21.png" /><br><figcaption></figcaption></figure>
<br>

<p>Iterate through a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-23.png" /><br><figcaption></figcaption></figure>
<br>

<p>Convert a list to an array:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-38.png" /><br><figcaption></figcaption></figure>
<br>

<p>Convert an array to a list:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-02-58.png" /><br><figcaption></figcaption></figure>
<br>

<h3>ArrayList</h3>
<p>In an Array or a List, you can only store data of one type.</p>

<p>In <span class="r-word">ArrayList</span>, you can store data of different types and it does not have a predefined size like lists.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-04-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>You should be careful when changing data because the compiler does not perform any type checking:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-05-06.png" /><br><figcaption></figcaption></figure>
<br>

<h3>HashTable</h3>
<p><span class="r-word">HashTable</span>, also known as <span class="negrita">dictionaries</span>, is a composite data type 
  where each element is a <span class="negrita">key-value</span> pair.</p>

<p>In HashTables, data is accessed through the key.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-06-39.png" /><br><figcaption></figcaption></figure>
<br>

<p>Keys must always be of type <span class="negrita">string</span>.</p>

<p>The size of a HashTable is dynamic, like lists.</p>

<p>You can check if a key exists with the <span class="negrita">Contains</span> method, and to use the value you need to perform a casting:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-07-37.png" /><br><figcaption></figcaption></figure>
<br>

<p>Iterating through a HashTable:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-08-34.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Methods</h3>
<p>Like in any object-oriented language, you can create methods within classes.</p>

<p>In C#, to create a method, you should follow this structure:
  <ul>
    <li>Access modifier (if none is specified, it defaults to private).</li>
    <li>Return type (void if it returns nothing).</li>
    <li>Method name (first letter capitalized and CamelCase).</li>
    <li>Parentheses to indicate parameters, if any.</li>
    <li>Braces to indicate the method's code block.</li>
  </ul>
</p>
<p>Method declaration:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-10-37.png" /><br><figcaption></figcaption></figure>
<br>

<p>Calling a method is done the same way as in any programming language:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-11-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>MonoBehaviour Class</h3>
<p>When creating a C# script in Unity, you will notice that the class containing the script inherits from the <span class="r-word">MonoBehaviour</span> class.</p>

<p>The <span class="negrita">MonoBehaviour</span> class is necessary for scripts that are associated with the project's <span class="negrita">GameObjects</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-12-47.png" /><br><figcaption></figcaption></figure>
<br>

<p>Since Unity operates on events, within classes inheriting from MonoBehaviour, you can include a series of default-defined methods that will execute when the events associated with those methods occur.</p>

<p>By default, two methods are added that execute with specific events:
  <ul>
    <li><span class="negrita">Start</span>: is called in the frame when the script is activated and just before the first call to any Update method.</li>
    <li><span class="negrita">Update</span>: is called every frame.</li>
  </ul>
</p>



<p>There are many more methods that can be consulted in the documentation: 
  <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a></p>

<h3>Game Loop</h3>

<p>The game loop can be defined as the different phases a script goes through during execution:
  <ul>
    <li>Initialization</li>
    <li>Physics Update</li>
    <li>Input Update</li>
    <li>Game Logic</li>
    <li>Destruction</li>
  </ul>
</p>

<p>Each of these phases is associated with a set of methods from the MonoBehaviour class:</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-15-54.png" /><br><figcaption></figcaption></figure>
<br>

<p>When the game is executed, Unity starts running the game loop, and in each phase, it will call the corresponding methods that are found in the scripts added to the GameObjects in the scene.</p>

<p>Example of a script implementing some of the MonoBehaviour class methods:</p>

<figure><img src="UD9/images/ud9-2024-01-25-11-16-34.png" /><br><figcaption></figcaption></figure>


</section><!-- End section Scripting-->

<!--*********************************************************Manejo de Unity***********************************************************-->
<section class="apartado">
<a name="sManejo_de_Unity"></a>
<h2>Manejo de Unity</h2>
<p>Es muy importante aprender cómo funciona la ventana de visualización de Unity para poder trabajar correctamente con los GameObject.</p>

<p>La ventana de visualización es el lugar donde se pueden ver los objetos que forman parte de la escena.</p>

<p>En esta ventana suelen aparecer los llamados gizmos, un gizmo es un gráfico que ayuda al programador ofreciendo información sobre el GameObject dentro de la escena.</p>

<p>Por ejemplo, si se selecciona la luz que aparece en la escena se podrá ver cómo aparece un gizmo que indica la dirección de la luz.</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-22-45.png" /><br><figcaption></figcaption></figure>
<br>
<p>El sistema de coordenadas es el que permite ubicar a todos los GameObject en la escena.</p>

<p>Cada GameObject tendrá unas coordenadas que indican su posición.</p>

<p>Unity utiliza un sistema de coordenadas <span class="negrita">Y-Up</span>:
  <ul>
    <li><span class="negrita">x</span>: eje horizontal</li>
    <li><span class="negrita">y</span>: eje vertical</li>
    <li><span class="negrita">z</span>: eje profundidad</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-25-11-59-29.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cada motor de juegos y cada editor 3D utiliza un sistema de coordenadas diferente.</p>

<p>Unity utiliza el sistema Y-Up.</p>

<p>Unreal y Blender utilizan el sistema Z-Up donde el eje vertical es z y el eje de profundidad es y.</p>
<p>En la <span class="negrita">parte superior derecha de la ventana de visualización</span> aparece un <span class="negrita">gizmo</span>
   muy útil que indica la dirección en la que se está visualizando la escena.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-00-40.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al hacer clic en lo conos se cambia la visualización para orientarse en ese eje.</p>

<p>En la parte inferior de ese gizmo aparece el punto de vista actual, puede indicar "Persp" o cualquier otra dirección como "Back", si se pulsa sobre el cubo central o en el icono de debajo con el punto de vista actual, se cambia a una visualización isométrica.</p>

<p>Si se está desarrollando un juego en 3D la visualización irá cambiando constantemente, pero si se está desarrollando un juego en 2D la visualización por defecto no es la correcta y debería cambiarse.</p>

<p>En la parte superior se encuentran las siguientes herramientas.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-01-47.png" /><br><figcaption></figcaption></figure>
<br>

<p>En la izquierda:
  <ul>
    <li>Las dos primeras son opciones de cómo funciona la herramienta "mano".</li>
    <li>La tercera permite activar/desactivar la visualización de la rejilla.</li>
    <li>La cuarta permite que al mover los GamObjects se "enganchen" a los puntos de la rejilla.</li>
    <li>La quinta indica los pasos de movimiento cuando se mueve un GameObject.</li>
  </ul>
</p>

<p>En la derecha:
  <ul>
    <li>La primera indica cómo se van a visualizar los GameObjects de la escena (sólidos, aristas…).</li>
    <li>La segunda permite cambiar el tipo de cámara de 3D a 2D (ortográfica).</li>
    <li>La tercera permite activar/desactivar las luces de la escena.</li>
    <li>La cuarta permite activar/desactivar los sonidos.</li>
    <li>La quinta permite activar efectos como el cielo, la niebla…</li>
    <li>La sexta permite mostrar/ocultar el número de GameObjects ocultos en la escena.</li>
    <li>La séptima permite configurar la cámara.</li>
    <li>La octava permite configurar la visualización de los gizmos.</li>
  </ul>
</p>

<p>En la parte superior izquierda se encuentran las siguientes herramientas que permiten desplazarse por la escena y manipular los GameObject de la misma:</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-09-50.png" /><br><figcaption></figcaption></figure>
<br>
<p>Las herramientas anteriores que permiten modificar un GameObject de la escena, 
  al seleccionarlas mostrarán un gizmo sobre el GameObject para facilitar la manipulación del GameObject.</p>
<figure><img src="UD9/images/ud9-2024-01-25-12-11-24.png" /><br><figcaption></figcaption></figure>
<br>

<p>Todos los GameObjects tienen un <span class="negrita">punto pivote</span> que será a partir del cual se ejecutarán los cambios sobre ellos.</p>

<p>El punto pivote por defecto se encuentra en el <span class="negrita">centro del Gameobject</span>, 
  por eso el gizmo de las herramientas anteriores se dibuja desde el centro del GameObject seleccionado.</p>

  <figure><img src="UD9/images/ud9-2024-01-25-13-50-41.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>El punto pivote no se puede cambiar de sitio.</p>

  <h3>Movimiento de la cámara de visualización</h3>

  <p class="sub-section">Con teclas:</p>
  <p>
    <ul>
      <li>Flechas ⬅ ➡: desplaza izquierda-derecha la cámara.</li>
      <li>Flechas ⬆ ⬇: zoom-in y zoom-out.</li>
    </ul>
  </p>
  
  
  <p class="sub-section">Con ratón:</p>
  <p>
    <ul>
      <li>Con la herramienta mano seleccionada al hacer clic y arrastrar: se desplaza en horizontal y vertical la cámara.</li>
      <li>Botón central (rueda) del ratón: misma acción que la línea anterior.</li>
      <li>CTRL + ALT + clic izquierdo: misma acción que la línea anterior.</li>
      <li>Con el botón derecho pulsado: se rota la cámara sobre sí misma.</li>
      <li>ALT + clic izquierdo: rota la cámara sobre el punto central de la visualización.</li>
    </ul>
  </p>

  <p>Todos los GameObject se pueden mover/alinear con la visualización.</p>

  <p>Esto es útil con las cámaras porque permiten alinear la cámara a la vista de visualización para que al ejecutar el juego sea esa orientación vista la que se vea.</p>
  
  <figure><img src="UD9/images/ud9-2024-01-25-13-53-48.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Como se ha indicado anteriormente, si se está desarrollando un juego en 2D interesa cambiar la visualización de la escena para que se ajuste a la visualización 
    del juego teniendo el eje z en horizontal y el eje y en vertical.</p>
  <figure><img src="UD9/images/ud9-2024-01-25-13-54-45.png" /><br><figcaption></figcaption></figure>
  <br>
  
</section><!-- End section Manejo de Unity-->

  <!--*********************************************************Agregando GameObjects a la escena***********************************************************-->
  <section class="apartado">
    <a name="sAgregando_GameObjects_a_la_escena"></a>
    <h2>Agregando GameObjects a la escena</h2>
    
    <p>Para agregar GameObjects a la escena se puede hacer click derecho sobre la zona de elementos de la escena (jerarquía) 
      o bien se puede pulsar la opción del menú GameObject.</p>
    
<p>La opción del menú ofrece además acciones a realizar sobre un GameObject si está seleccionado.</p>
<figure><img src="UD9/images/ud9-2024-01-25-13-56-44.png" /><br><figcaption></figcaption></figure>
<br>
<p>Dependiendo del tipo de proyecto se tendrán disponibles diferentes tipos de GameObjects para a la escena 
  (desde el Package Manager se pueden agregar paquetes para ampliar el catálogo).</p>

<p>Se pueden añadir GameObjects vacíos (empty) que sirven para agrupar otros GameObjects y así mantener la jerarquía organizada.</p>

<p>También existen objetos 3D que serán los primeros con los que se trabajará en clase.</p>

<figure><img src="UD9/images/ud9-2024-01-25-13-58-59.png" /><br><figcaption>Proyecto 3D</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-25-13-59-21.png" /><br><figcaption>Proyecto 3D con el paquete 2D Sptrite</figcaption></figure>
<br>
<p>Al agregar un GameObject a la escena en la jerarquía se permite cambiar el nombre 
  (posteriormente se puede cambiar haciendo clic derecho sobre él en la jerarquía).</p>

<p>Además, al añadir el GameObject, este se posiciona en el centro de la escena sean cuales sean esas coordenadas.</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-00-24.png" /><br><figcaption></figcaption></figure>
<br>


<p>Al seleccionar el GameObject en el inspector se puede ver los componentes que tiene, 
  entre ellos se encuentra <span class="r-word">Transform</span> que indica los valores de <span class="negrita">posición, rotación y escala</span>.</p>

  <p>Los GameObject se agregan en la jerarquía como hijos de la escena.</p>

  <p>Desde la jerarquía, se pueden organizar los GameObject unos dentro de otros arrastrándolos encima del que debe contenerlos o 
    arrastrándolos fuera del que los contiene.</p>
  
  <p>Si se hace clic derecho sobre un objeto en la jerarquía y se añade un GameObject, este se añadirá directamente como hijo del que se ha pulsado.</p> 
  <figure><img src="UD9/images/ud9-2024-01-25-14-01-59.png" /><br><figcaption></figcaption></figure>
  <br>
  
<section class="marco-t warn">
  <span class="icono warning"> </span>Todas las modificaciones que se realicen sobre un GameObject afectan a todos los GameObjects que se encuentren 
  dentro de él en la jerarquía.
  </section>
<section class="marco-b">
    
</section>

<h3>Punto pivote de un GameObject</h3>
<p><span class="negrita">Todos los GameObject tienen un punto pivote situado en su centro.</span></p>

<p>Las coordenadas de este punto pivote en la escena es lo que utiliza Unity para realizar todos los cálculos necesarios.</p>

<p>El punto pivote <span class="negrita">no se puede cambiar de sitio</span>.</p>

<p>El punto pivote también es la referencia cuando un GameObject sigue a otro, por ejemplo, una cámara que sigue a un personaje, 
  en este caso la cámara tomará como centro a seguir el punto pivote del GameObject.</p>

<p>Si se quiere que ese centro de seguimiento sea diferente se puede crear un GameObject vacío y añadirlo al GameObject principal en las coordenadas que se quiera, y a continuación indicar que la cámara siga al GameObject vacío.</p>

<h3>Modificando GameObjects</h3>
<p>Para modificar un GameObject se debe seleccionar o haciendo clic en él en la jerarquía o haciendo clic en él en la visualización de la escena.</p>

<p>Si se hace doble clic en un GameObject de la jerarquía además de seleccionar el GameObject la vista se centrará en ese GameObject.</p>

<p>Si se hace clic sobre un GameObject en la visualización además de seleccionar el GameObject la vista se centrará donde se hecho doble clic.</p>

<p><span class="negrita">Todas las modificaciones se realicen sobre un GameObject toman como referencia el punto pivote del GameObject</span>.</p>

<p>Existen varias formas de modificar un GameObject en la escena:</p>

<p class="sub-section">Cambiando manualmente sus valores en el inspector</p>

<figure><img src="UD9/images/ud9-2024-01-25-14-06-47.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede indicar que el GameObject se sitúe en el centro del las coordenadas (0,0,0).</p>

<figure><img src="UD9/images/ud9-2024-01-25-14-07-26.png" /><br><figcaption></figcaption></figure>
<br>

<p>Esta acción puede ser problemática debido a que el punto pivote por defecto se encuentra en su centro, así que al mover a (0,0,0)
  puede ocurrir algo como lo de la siguiente imagen donde el GameObject tiene la mitad debajo del punto (0,0,0).</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-07-47.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Desde el inspector situando el ratón encima de una de las coordenadas </p>
<p>cambia el icono y permite que al hacer clic y desplazar sin soltar el clic se cambie el valor</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-08-44.png" /><br><figcaption></figcaption></figure>
<br>
<p class="sub-section">Con las herramientas vistas anteriormente</p>
<p>Utilizando el ratón podemos modificar un GameObject.</p>

<p>Al seleccionarlas aparece un gizmo y al interactuar con él con el ratón se realizan las acciones requeridas.</p>

<p>Cada gizmo funciona de una manera diferente</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-09-56.png" /><br><figcaption></figcaption></figure>
<br>
<p>Movimiento solo en el eje X</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-10-56.png" /><br><figcaption></figcaption></figure>
<br>

<p>Movimiento en los ejes que no son Y (plano X, Z):</p>
<figure><img src="UD9/images/ud9-2024-01-25-14-10-43.png" /><br><figcaption></figcaption></figure>
<br>
<p>Al usar las herramientas con los gizmos se puede utilizar el ajuste por <span class="negrita">snaps</span>.</p>

<p>Los pasos o snaps por defecto se pueden cambiar:</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-28-26.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para realizar las modificaciones por snaps al usar los gizmos se debe pulsar la tecla control.</p>

<p>Todas las modificaciones se realizan tomando como punto de referencia el punto pivote.</p>

<p>Se pueden realizar modificaciones cambiando el punto de referencia a un vértice de la malla del GameObject, para esto se debe pulsar la tecla v tras seleccionar la herramienta.</p>

<p>Se puede ver como al pulsar la tecla v, al mover el ratón sobre el GameObject el gizmo se sitúa en el vértice más cercano.</p>

<p>Esta acción se conoce como vertex snap y permite situar GameObjects a partir de uno de sus vértices en el vértice de otro Gameobject.</p>

<figure><img src="UD9/images/ud9-2024-01-26-09-29-17.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Unidades de medida</h3>
<p>Por defecto las unidades de medida usadas en Unity son:
  <ul>
<li><span class="negrita">Distancias</span>: metros.</li>
<li><span class="negrita">Tamaños</span>: metros.</li>
<li><span class="negrita">Peso (masa)</span>: kilogramos.</li>
<li><span class="negrita">Tiempo</span>: segundos.</li>
  </ul>
</p>

<p>Es importante tener esto en cuenta ya que el comportamiento de los GameObjects con las físicas va a depender de su tamaño y peso.</p>



</section><!-- End section Agregando GameObjects a la escena-->
<!--*********************************************************Materiales***********************************************************-->
<section class="apartado">
<a name="sMateriales"></a>
<h2>Materiales</h2>
<p>Los <span class="negrita">materiales</span> permiten dar aspecto a los GameObject.</p>

<p>Para crear un material se hace clic derecho en el gestor de archivos y se selecciona <span class="negrita">Create &rarr; Material</span>, 
  al crearlo permitirá asignarle un nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-32-28.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cabe recordar que para mantener la organización de archivos los materiales deben incluirse en una carpeta llamada <span class="inline-folder">Materials</span>
   dentro de la carpeta <span class="inline-folder">Assets</span>.</p>

   <p>Un material en el gestor de archivos se representa con una esfera y según la configuración que se le aplique en el inspector tendrá un aspecto u otro.</p>
   
<figure><img src="UD9/images/ud9-2024-01-26-09-33-59.png" /><br><figcaption></figcaption></figure>
<br>
<p>Con una buena configuración se puede conseguir que el material sea realista.</p>

<p>También se pueden conseguir materiales de la Unity Asset Store y de repositorios de internet.</p>
<figure><img src="UD9/images/ud9-2024-01-26-09-53-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se puede aplicar un material a un GameObject de varias maneras:
  <ul>
<li>Arrastrar el material al GameObject en la jerarquía.</li>
<li>Arrastrar el material al GameObject en la visualización.</li>  
<li>Arrastrar el material al GameObject en el inspector en la zona "Add Component".</li>
</ul>
</p>

<figure><img src="UD9/images/ud9-2024-01-26-09-54-59.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Materiales Físicos</h3>
<p>Los materiales físicos (Physic Material) permiten controlar como van a interactuar físicamente los GameObject cuando colisionan entre sí.</p>

<p>Se suelen utilizar para permitir que los GameObject reboten o para que haya fricción entre ellos.</p>

<p>Para crear un material físico se hace clic con el botón derecho sobre el gestor de archivos y se elige la opción <span class="negrita">Create &rarr; Physic Material</span>.</p>

<p>Al crearse, se debe introducir su nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-05-23.png" /><br><figcaption></figcaption></figure>
<br>
<p>Los parámetros que se pueden configurar en un material físico son:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-05-53.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede aplicar un material físico a un GameObject de varias maneras:
  <ul>
    <li>Arrastrar el material al GameObject en la jerarquía.</li>
    <li>Arrastrar el material al GameObject en la visualización.</li>
    <li>Arrastrar el material al GameObject en el inspector en la zona "Add Component".</li>
</ul>
</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-06-48.png" /><br><figcaption></figcaption></figure>
 <br>
 <br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 3. Montando la escena</span> <br>
    Crea un proyecto 3D en Unity llamado <span class="subrayado">EscenaTuNombre</span>. <br>
Pon la cámara de visualización como si se fuera a desarrollar un juego en 2D (eje z hacia atrás). <br>
Añade a la escena un plano y modifica su tamaño para que tenga poca profundidad, pero sea muy ancho (como una pasarela en horizontal de izquierda a derecha). <br>
Añade a la escena un cubo, una esfera, una cápsula y un cilindro. Sitúalos en la escena como quieras, pero deben de estar en la misma coordenada Z que el plano. <br>
Solo uno debe estar tocando la superficie del plano. <br>
De los GameObject que no están tocando la superficie del plano debes colocar uno en la misma coordenada z que el que está tocando la superficie otro, 
la coordenada x debe estar un poco desplazada (tiene que seguir estando encima del otro) y la coordenada y debe ser más alta, en la parte superior de la escena. <br>
Crea 5 materiales con color y aspecto distinto y asigna cada uno a un GameObject. <br>

Sitúa la visualización en un ángulo diferente al de la cámara, puedes rotarla y moverla, pero tienen que aparecer el plano y todos los objetos.
<span class="oculto">Haz una captura de la ventana de visualización y ponle el nombre TuNombreUnity1.png </span>
<span class="oculto">Haz una captura de la ventana del juego en ejecución, ponle el nombre TuNombreUnity2.png.
  Comprime las dos capturas en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.</span>

  </p>
</div>

<br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 4. Eventos MonoBehaviour</span> <br>
    Abre el proyecto EscenaTuNombre. <br>
Crea un script llamado EventsScript y añádelo al GameObject que está en la superficie. <br>
En el script añade instrucciones para mostrar mensajes por consola con Debug.Log para los siguientes eventos:
 Start, Update, OnMouseEnter (el ratón se sitúa sobre el GameObject), OnMouseDrag (se clica sobre el GameObject y sin soltar se mueve el ratón). <br>
Los mensajes deben seguir el siguiente formato "TuNombre (NombreEvento): LoQueQuieras".  <br>
 <span class="oculto">
  Haz clic en el script en el gestor de archivos para que se vea en el inspector el código del script, a continuación, 
ejecuta el juego y haz una captura donde se visualice la consola y el inspector (recuerda activar la opción Collapse de la consola), 
ponle a la captura el nombre TuNombreUnity3.png. <br>
Comprime la captura en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.
 </span>


  </p>
</div>

<br>
 <hr>
 <br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 5. Gravedad</span> <br>
    Abre el proyecto EscenaTuNombre. <br>
Uno de los GameObject de la escena se encuentra en la misma vertical que el que estaba tocando la superficie, 
pues a ese objeto que está en la parte superior de la escena añádele el componente RigidBody. <br>
Ejecuta el juego y observa qué ocurre. <br>
Cambia el peso de ese GameObject y vuelve a ejecutar el juego para observar qué ocurre. <br>
Cambia otras configuraciones del RigidBody y vuelve a ejecutar el juego para observar qué ocurre. <br>

<div class="oculto">Haz una captura de la ventana del juego en ejecución antes de que el cubo caiga, ponle el nombre TuNombreUnity4.png. <br>
  Haz una captura de la ventana del juego en ejecución cuando el cubo golpea al objeto que tiene debajo, ponle el nombre TuNombreUnity5.png. <br>
  Haz una captura de la ventana del juego en ejecución cuando el cubo deje de moverse, ponle el nombre TuNombreUnity6.png. <br>
  Comprime las dos capturas en un archivo rar o zip llamado TuNombre y adjunta ese archivo</div>

</div>

</section><!-- End section Materiales-->

<!--*********************************************************Componentes de GameObject***********************************************************-->
<section class="apartado">
<a name="sComponentes_de_GameObject"></a>
<h2>Componentes de GameObject</h2>
<p>Los GameObject pueden contener diferentes componentes.</p>

<p>Como mínimo todos los GameObject tienen_el compone_te Transform que sirve para indicar la posición, la rotación y el tamaño del GameObject</p>

<p>Los GameObject geométricos también tienen un Mesh y un Mesh Renderer para poder dibujarse.</p>

<p>Los GameObject que se visualizan en las cámaras tienen un Collider para detectar las colisiones.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-00-53.png" /><br><figcaption></figcaption></figure>
<br>

<p>Se pueden añadir otros componentes a los GameObject desde el <span class="negrita">Menú &rarr; GameObject</span> o
  desde el inspector con el botón "<span class="negrita">Add Component</span>" que aparece en la parte inferior.</p>


<p>Usando el botón "Add Componen" aparece un buscador en el que se puede escribir el componente que se quiere.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-02-02.png" /><br><figcaption></figcaption></figure>
<br>

<p>Cuando se desarrolla un videojuego suele ser necesario que algunos GameObjects estén <span class="negrita">afectados por las físicas</span>
   (gravedad, fuerzas…) para eso se necesita que los GameObject tengan un componente llamado <span class="r-word">RigidBody</span>.</p>

<p>En la configuración del <span class="r-word">RigidBody</span> se indica el peso del GameObject dentro de la escena entre otros parámetros.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-03-05.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Componentes de GameObject-->

<!--*********************************************************UI (User Interface)***********************************************************-->
<section class="apartado">
<a name="sUI"></a>
<h2>UI (User Interface)</h2>
<p>La interfaz de usuario (UI) son elementos que se añaden a la escena para dar información al usuario.</p>

<p>Con a la interfaz de usuario se pueden crear los menús y el HUD (Head-Up display).</p>

<p>La interfaz de usuario se puede crear tanto con GameObjects 2D como 3D pero habitualmente se utilizan GameObjects 2D.</p>

<p>Dentro de la interfaz de usuario pueden aparecer GameObjects como texto, imágenes, sliders, scrollbars, botones o campos de texto.</p>

<p>Los GameObjects de interfaz de usuario deben ser hijos de un GameObject de tipo <span class="negrita">Canvas</span>.</p>

<p>Cuando se añade a la escena un GameObject de interfaz de usuario, si no existe un <span class="negrita">Canvas</span> en la escena, 
  se creará para poder contener el GmaObject de la interfaz de usuario.</p>

  <figure><img src="UD9/images/ud9-2024-01-26-10-09-35.png" /><br><figcaption></figcaption></figure>

  <h3>UI - Texto</h3>
  <p>Existen dos GameObjects para añadir texto a la escena:
    <ul>
      <li><span class="negrita">Text</span>: texto primitivo con pocas opciones de configuración.</li>
      <li><span class="negrita">TextMeshPro</span>: texto avanzado con muchas opciones de configuración.</li>
    </ul>
  </p>

<p>Existen otros GameObject de tipo MeshPro que mejoran a los tipos primitivos.</p>

<p>Se recomienda el uso de los MeshPro siempre que estén disponibles.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-11-13.png" /><br><figcaption></figcaption></figure>
<br>
<p>Cuando se añade un <span class="negrita">TextMeshPro</span> por primera vez al proyecto aparecerá una ventana indicando que se necesita importar todos los paquetes 
  necesarios, se debe pulsar en el botón "<span class="cursiva">Import TMP Essentials</span>".</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-12-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>También indica que se pueden importar paquetes de ejemplos y extras.</p>

<p>Para visualizar correctamente los elementos del <span class="negrita">Canvas</span> en la pantalla hay que realizar 
  desde el inspector algunos cambios en la configuración.</p>

<p>Se debe seleccionar como "<span class="negrita">Render Mode</span>" la opción "<span class="negrita">Screen Space - Camera</span>" 
  y posteriormente arrastrar desde la jerarquía la cámara a la casilla "<span class="negrita">Render Camera</span>"</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-14-41.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-15-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>UI - Imágenes</h3>
<p>Para añadir imágenes a la interfaz de usuario se necesita que las imágenes sean <span class="d-word">sprites</span>.</p>

<p>Los sprites son imágenes de mapa de bits que contienen una unidad mínima de información como puede ser la imagen de un botón o la imagen de un personaje.</p>

<p>Una imagen puede contener uno o más sprites.</p>

<p>Cada sprite se pueden añadir a la escena directamente de manera independiente convirtiéndose en un GameObject.</p>

<p>Si una imagen contiene varios sprites se optimiza la carga de las imágenes en el juego.</p>

<p>Los sprites pueden usarse para formar un personaje completo y poder animar cada uno de los sprite de manera independiente.</p>

<p>También pueden usarse para formar la animación de un personaje o un objeto al moverse haciendo que un GameObject vaya cambiando de sprite.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-28-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una imagen con varios sprites también sirve para contener los diferentes elementos del mundo o de la interfaz de usuario.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-29-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>El primer paso para poder añadir sprites al proyecto Unity es añadir el paquete 2D Sprite desde el <span class="negrita">Menú &rarr; Window &rarr; Package Manager</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-30-33.png" /><br><figcaption></figcaption></figure>
<br>

<p>De esta manera se instala la herramienta <span class="negrita">Unity Sprite Editor</span>.</p>

<p>El siguiente paso es arrastrar las imágenes al gestor de archivos a una carpeta llamada <span class="inline-folder">Sprites</span>.</p>

<p>Al seleccionar una imagen del gestor de archivos, en el inspector se puede indicar el tipo de textura que es.
  Para convertirla en un Sprite se debe elegir la opción <span class="negrita">Sprite (2D and UI)</span>.</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-31-40.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al realizar esta acción estará disponible el botón <span class="negrita">Sprite Editor</span> y 
  al pulsarlo se abrirá el editor que permite crear el sprite a partir de la imagen.</p>

<p>Si la imagen solo contiene un Sprite al estar seleccionado el modo por defecto "<span class="cursiva">Single</span>" 
  solo con abrir el editor ya se habrá convertido la imagen en un Sprite.</p>

<p>Cuando una imagen se convierte en un Sprite en el gestor de archivos aparece una flecha sobre ella.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-32-54.png" /><br><figcaption></figcaption></figure>
<br>

<p>El editor de sprites permite modificar el sprite.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-33-21.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si una imagen contiene varios sprites, en el inspector la opción <span class="negrita">Sprite Mode</span> se debe marcar como <span class="negrita">Multiple</span>.</p>

<p>Es importante que el fondo de la imagen sea transparente para obtener mejores resultados con los sprites.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-34-18.png" /><br><figcaption></figcaption></figure>
<br>


<p>De esta manera el editor de sprite permite obtener varios sprites a partir de la imagen.</p>

<p>Desde el editor de sprites se pueden seleccionar a mano los diferentes sprites con el ratón, una vez seleccionado un sprite se debe poner un nombre para reconocerlo posteriormente:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-35-15.png" /><br><figcaption></figcaption></figure>
<br>
<p>Una vez creado el sprite, con la opción <span class="negrita">Trim</span> se recorta el sprite ajustándose al contenido de la imagen (el fondo debe ser transparente).</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-35-48.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede cambiar la manera de seleccionar el sprite si se quiere ajustar mejor a la imagen.</p>

<p>Con <span class="negrita">Outline Tolerance</span> se ajusta el contorno a la imagen, 
  con <span class="negrita">Generate</span> se genera el contorno y con <span class="negrita">Apply</span> se crea el sprite con ese contorno.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-37-14.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si los sprites se organizan en la imagen de una manera ordenada, 
  desde el editor en el desplegable <span class="negrita">Slice</span> se puede seleccionar la manera en la que se va a dividir la imagen para que 
  el editor cree automáticamente los sprites:</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-37-42.png" /><br><figcaption></figcaption></figure>
<br>

<p><ul>
  <li><span class="negrita">Automatic</span>: el editor detecta los sprites según el contenido.</li>
  <li><span class="negrita">Grid By Cell Size</span>: en la imagen los sprites se encuentran organizados en forma de rejilla, con esta opción se debe indicar el tamaño de cada cuadro de la rejilla.</li>
  <li><span class="negrita">Grid By Cell Count</span>: en la imagen los sprites se encuentran organizados en forma de rejilla, con esta opción se debe indicar el número de filas y de columnas.</li>
</ul></p>

<p>Tras seleccionar la opción deseada se debe pulsar el botón Slice para generar todos los sprites</p>

<figure><img src="UD9/images/ud9-2024-01-26-10-39-10.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-39-17.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-40-12.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si la imagen contiene los sprites de animación de un personaje, como en el ejemplo, 
  cuando se utilizan las opciones del botón <span class="negrita">Slice</span> se debe estudiar el contenido de la imagen para que el pivote sea correcto 
  y la animación funcione correctamente.</p>

<p>Lo más habitual en estos casos es que los sprites estén organizados en forma de rejilla y el pivote se sitúe en el centro, 
  aunque esto puede cambiar entre las diferentes hojas de sprites.</p>

<p>Una vez creados los sprites en el gestor de archivos al pulsar la flecha que aparece en la imagen se mostrarán todos los sprites creados junto con su nombre.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-41-11.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una vez una imagen se ha convertido en uno o varios sprites, se puede arrastrar uno de los sprite a la jerarquía o a la visualización y se añadirá un GameObject que muestre ese sprite.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-52-04.png" /><br><figcaption></figcaption></figure>
<br>
<p>También se puede añadir un GameObject de tipo <span class="negrita">UI &rarr; Image</span> y añadirle el sprite arrastrándolo a la opción Source Image.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-52-56.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-26-10-53-10.png" /><br><figcaption></figcaption></figure>
<br>

</section><!-- End section UI (User Interface)-->

<!--*********************************************************Prefabs***********************************************************-->
<section class="apartado">
<a name="sPrefabs"></a>
<h2>Prefabs</h2>
<p>Un <span class="r-word">Prefab</span> es un GameObject con todas sus características 
  (tamaño, rotación, giro, material, texturas, físicas…) almacenado como un asset.</p>

<p>Al tener un GameObject guardado como un prefab este <span class="negrita">podrá ser instanciado desde un script</span>.</p>

<p>Un ejemplo típico de un prefab en un juego serían los objetos que dejan los enemigos cuando desaparecen tras ser golpeados.</p>

<p>Los prefab también son fáciles de exportar para poder ser usados en otros proyectos.</p>

<p>Para crear un prefab se debe arrastrar el objeto desde la jerarquía al gestor de archivos.</p>

<p>Para mantener una buena organización todos los prefab se situarán en una carpeta llamada <span class="inline-folder">Prefabs</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-55-31.png" /><br><figcaption></figcaption></figure>
<br>
<p>En la jerarquía se indica que el GameObject proviene de un prefab mostrando su nombre en color azul.</p>

<p>En el gestor de archivos aparece una previsualización del prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-56-18.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al seleccionar el prefab en el inspector se pueden ver sus características y componentes.
</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-56-46.png" /><br><figcaption></figcaption></figure>
<br>
<p>Un GameObject en la jerarquía que proviene de un prefab se puede editar en la escena actual sin que esta edición afecte al prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-57-23.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para editar un prefab se debe hacer doble clic sobre él en el gestor de archivos.</p>

<p>Los cambios sobre el prefab se replicarán en todos los GameObject del proyecto que estén creados a partir del prefab.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-57-56.png" /><br><figcaption></figcaption></figure>
<br>
<p>En una escena se pueden añadir todas las copias de un prefab que se necesiten.</p>

<p>Desde un script también se pueden añadir GameObjects que sean prefabs.</p>
<figure><img src="UD9/images/ud9-2024-01-26-10-58-35.png" /><br><figcaption></figcaption></figure>
<br>


<br>
<hr>
<br>
<div class="tarea">
  <p><span class="subrayado negrita">Actividad 6. Imágenes y prefabs</span> <br>
Abre el proyecto <span class="subrayado">EscenaTuNombre</span>. <br>
Añade un GameObject del tipo Cube, crea un material nuevo para él y asígnaselo. <br>
Crea 5 copias de este último cubo y crea una figura juntándolos como quieras (puedes rotarlos y escalarlos). <br>
Crea un GameObject vacío y añádele los 6 cubos que forman la figura, ten cuidado con las coordenadas. <br>
Crea un Prefab con ese GameObject vacío. <br>
Añade a la escena un texto con tu nombre. <br>
Añade a la escena una foto tuya tipo carnet (actual). <br>

<div class="oculto">Haz una captura de toda la ventana de Unity en ejecución, se tiene que ver el Asset en el gestor de archivos y 
  en la ventana de visualización se tienen que ver todos los GameObject de la escena, ponle el nombre TuNombreUnity7.png. <br>
  Comprime la captura en un archivo rar o zip llamado TuNombre y adjunta ese archivo comprimido a la tarea.</div>
</p>
  
</div>

</section><!-- End section Prefabs-->

<!--*********************************************************La Clase GameObject***********************************************************-->
<section class="apartado">
<a name="sLa_Clase_GameObject"></a>
<h2>La Clase GameObject</h2>
<h3>Acceso a las propiedades del GameObject</h3>
<p>Desde un script añadido a un GameObject se puede acceder a las propiedades del propio GameObject y a todos los componentes que se añadan al GameObject.</p>

<p>Para acceder a toda esta información se utiliza la variable <span class="r-word">gameObject</span> 
  que <span class="negrita">se inyecta directamente</span> al heredar de la clase <span class="r-word">MonoBehaviour</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-10-56-27.png" /><br><figcaption></figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-01-29-10-56-54.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-10-57-11.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-10-57-50.png" /><br><figcaption>Cambiando la propiedad nombre por código</figcaption></figure>
<br>

<p>Todos los GameObject tienen al menos un componente <span class="negrita">Transform</span> que sirve para <span class="negrita">indicar la posición, 
  la rotación y el tamaño del GameObject</span>.</p>

<p>Como es un componente presente <span class="subrayado">en todos</span> los GameObject, 
  Unity inyecta directamente la propiedad <span class="negrita">transform que se puede usar directamente</span> o 
  desde la propiedad gameObject para poder utilizarlo directamente.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-00-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para acceder a un componente <span class="negrita">diferente a Transform</span>, 
  se debe crear una propiedad para poder almacenar ese componente en ella mediante el método <span class="negrita">GetComponent</span> y poder acceder.</p>

<p>Por ejemplo, para acceder al componente <span class="negrita">Collider</span>:</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-01-57.png" /><br><figcaption>Al ejecutar se desactiva el collider</figcaption></figure>
<br>
<h3>Acceso a otros GameObjects</h3>
<p>Para acceder desde un script a otros GameObjects <span class="negrita">se debe <span class="negrita">declarar una propiedad de tipo GameObject</span></span>
  y posteriormente <span class="negrita">asignarle el GameObject que se quiera</span>. (Sphere<span class="negrita">GO</span>  &rarr; <span class="negrita">G</span>ame<span class="negrita">O</span>bject).</p>

  <figure><img src="UD9/images/ud9-2024-01-29-11-03-58.png" /><br><figcaption></figcaption></figure>
  <br>

<p>Hay varias opciones para asignar el GameObject a la propiedad.
  <ul>
    <li>Si la propiedad es <span class="negrita">pública</span> se puede <span class="negrita">arrastrar</span> el GameObject desde la jerarquía a la variable en el Inspector.
      <figure><img src="UD9/images/ud9-2024-01-29-11-06-10.png" /><br><figcaption></figcaption></figure>     
    </li>
    <li>Desde el propio script con el método <span class="negrita">Find</span> de la clase <span class="negrita">GameObject</span>
       para buscar por el <span class="negrita">nombre</span> (en estos casos la propiedad suele ser privada).
       <figure><img src="UD9/images/ud9-2024-01-29-11-07-41.png" /><br><figcaption>Al ejecutar se buscan los GameObjects con esa etiqueta y se rellena el array</figcaption></figure>
    </li>
    <li><span class="negrita">Asignar etiquetas</span> a los GameObject y 
      desde el propio script con el método <span class="r-word">FindGameObjectsWithTag</span> de la clase <span class="negrita">GameObject</span>
       para buscar por <span class="negrita">etiqueta</span>.
       <figure><img src="UD9/images/ud9-2024-01-29-11-09-22.png" /><br><figcaption></figcaption></figure>
       <br>
       <p>En este caso la variable se debe declarar como array porque pude haber más de un GameObject con esa etiqueta (en estos casos la propiedad suele ser privada).</p>
       <figure><img src="UD9/images/ud9-2024-01-29-11-11-20.png" /><br><figcaption></figcaption></figure>  
       <br>    
       
       <figure><img src="UD9/images/ud9-2024-01-29-11-12-54.png" /><br><figcaption>Al ejecutar se buscan los GameObjects con esa etiqueta y se rellena el array.
</figcaption></figure>
       <br>
       
      </li>
  </ul>
</p>

<p>Al acceder a otros GameObjects se puede acceder a sus propiedades, por ejemplo, 
  el siguiente script añadido a la MainCamera, accedería a la propiedad <span class="negrita">Text</span> de un GameObject de tipo TextMeshPro y modificaría su valor.</p>

<p>Para poder acceder al GameObject se deberá arrastrar dicho GameObject a la casilla correspondiente del Inspector al seleccionar la MainCamera.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-14-25.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Acceso a componentes de otros GameObjects</h3>
<p>Una vez se tiene la referencia a un GameObject con cualquiera de las técnicas vistas anteriormente, 
  se puede acceder a los componentes de dicho GameObject con el método <span class="negrita">GetComponent</span>
   igual que se accede a los componentes del propio GameObject .</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-15-43.png" /><br><figcaption></figcaption></figure>
<br>
<p>Si la propiedad para acceder al componente se declara pública <span class="negrita">al arrastrar el GameObject</span>
   a la casilla en el Inspector <span class="negrita">se asignará directamente el tipo de componente especificado</span> al declarar la propiedad.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-16-38.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se puede acceder a los scripts de otros GameObjetcs a partir del GameObject al que se quiere acceder y al <span class="negrita">nombre del script</span>.</p>

<p>Se puede utilizar cualquier técnica de las vistas anteriormente para obtener la referencia al otro GameObject.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-18-28.png" /><br><figcaption></figcaption></figure>
<br>
</section><!-- End section La Clase GameObject-->

<!--*********************************************************El componente Transform***********************************************************-->
<section class="apartado">
<a name="sEl_componente_Transform"></a>
<h2>El componente Transform</h2>
<p>El componente <span class="r-word">Transform</span> se estructura en tres elementos:
  <ul>
    <li><span class="negrita">Posición</span></li>
    <li><span class="negrita">Rotación</span></li>
    <li><span class="negrita">Escala</span></li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-20-46.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para cada elemento se especifica un valor por cada coordenada que se puede consultar como se ha visto anteriormente.</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-20-54.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para modificar la <span class="negrita">posición</span>, la <span class="negrita">rotación</span> y la <span class="negrita">escala</span>
   se usan objetos de la clase <span class="r-word">Vector3</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-22-06.png" /><br><figcaption></figcaption></figure>
<br>

<p>El código de la imagen representa las coordenadas: x=3, y=8, z=1.</p>

<p>Los parámetros que admite son números decimales (float) aunque se puede indicar con enteros.</p>

<p>Si se indica un número decimal se debe añadir al final la letra f:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-22-20.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Cambiar posición de un GameObject</h3>

<p>Para <span class="negrita">cambiar la posición</span> de un GameObject:
<ul>
  <li>
    Indicar <span class="negrita">un nuevo Vector3</span> para la propiedad <span class="negrita">position</span> de su <span class="negrita">Transform</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-23-18.png" /><br><figcaption></figcaption></figure>
  </li>
  <li>
    Operar la propiedad <span class="negrita">position</span> del <span class="negrita">Transform</span> con un <span class="negrita">Vector3</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-24-03.png" /><br><figcaption></figcaption></figure>
  </li>
  <li>
    Usar el método <span class="r-word">Translate</span> sobre el <span class="negrita">Transform</span>:
    <figure><img src="UD9/images/ud9-2024-01-29-11-24-40.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Con <span class="r-word">Translate</span> se puede indicar si se usará como referencia el transform propio (valor por defecto) 
      o el punto central del espacio de coordenadas (0, 0, 0):</p>
    <figure><img src="UD9/images/ud9-2024-01-29-11-25-39.png" /><br><figcaption></figcaption></figure>
    <br>
    
  </li>
</ul>
</p>

<p>Además, la clase <span class="r-word">Vector3</span> dispone de algunas propiedades que devuelven objetos Vector3 a una unidad en las coordenadas:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-26-32.png" /><br><figcaption></figcaption></figure>
<br>
<p>En la documentación se puede consultar todo lo disponible:
<a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Vector3.html">https://docs.unity3d.com/ScriptReference/Vector3.html</a>
</p>

<p>Los objetos de la clase <span class="r-word">Vector3</span> se pueden operar:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-27-08.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Rotar un GameObject</h3>
<p class="sub-section">Sobre sí mismo</p>

<p>Indicar un <span class="negrita">nuevo Vector3</span> para la propiedad <span class="negrita">rotation</span> de su <span class="negrita">Transform</span>
   usando el método <span class="negrita">Euler</span> de la clase <span class="negrita">Quaternion</span>:</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-29-15.png" /><br><figcaption></figcaption></figure>
<br>

<p>Usar la propiedad <span class="negrita">eulerAngles</span> (comportamiento similar al método anterior):</p>

<figure><img src="UD9/images/ud9-2024-01-29-11-30-49.png" /><br><figcaption></figcaption></figure>
<br>

<p>Usar el método <span class="negrita">Rotate</span> sobre el <span class="negrita">Transform</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-30-56.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con <span class="negrita">Rotate</span> se puede indicar si se usará como referencia el transform propio (valor por defecto)
   o el punto central del espacio de coordenadas (0, 0, 0).</p>

<p class="sub-section">Girar alrededor de otro</p>

<p>Con el Método <span class="r-word">RotateAround(origen, eje, velocidad)</span> se puede hacer que un GameObject gire alrededor de otro:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-32-50.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con el método <span class="r-word">LookAt(transformOtherGameObject)</span> se puede hacer que un GameObject mire siempre hacia otro GameObject:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-33-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Estas dos técnicas deben usarse dentro del método Update del script.</p>

<h3>Escalar un GameObject</h3>
<p>Para <span class="negrita">escalar</span> un GameObject solo tiene sentido el escalarlo respecto a su punto pivote.</p>
<p>Por esta razón se utiliza la propiedad <span class="r-word">localScale</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-34-06.png" /><br><figcaption></figcaption></figure>
<br>

<h3>El componente Transform en la jerarquía</h3>
<p>Cuando se tienen GameObjects agrupados, el componente Transform permite acceder a todos los Transform y GameObjects de la agrupación</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-35-02.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-11-35-14.png" /><br><figcaption></figcaption></figure>
<br>
<p>El orden de acceso a los GameObject hijos es el mismo que el orden en el que se encuentren en la jerarquía.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-38-33.png" /><br><figcaption></figcaption></figure>
<br>
<p>Desde un GameObject agrupado también se puede acceder a su padre.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-39-18.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Movimiento desde los métodos Update y FixedUpdate</h3>
<p class="sub-section">Método Update</p>

<p>El método <span class="r-word">Update</span> se ejecuta una vez por cada frame generado.</p>

<p>Cuando se aplica una modificación del componente transform de un GameObject en el método Update <span class="negrita">se produce un movimiento</span>, por ejemplo: 
  añadir 0,01 unidad a la posición x en cada Update.</p>

  <figure><img src="UD9/images/ud9-2024-01-29-11-40-35.png" /><br><figcaption>Moviendo el GameObject</figcaption></figure>
  <br>
  
  <p>El problema de usar el método <span class="negrita">Update</span> es que la cantidad de FPS que se generar depende de muchísimos factores, 
    desde la capacidad del equipo donde se ejecuta el juego hasta la cantidad de elementos que se muestran en un momento determinado.</p>
  <figure><img src="UD9/images/ud9-2024-01-29-11-41-57.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Por esta razón, no es buena idea realizar movimientos directamente de esta manera.</p>
  
  <p>Existen dos formas para solucionar este problema:
    <ul>
      <li>La clase <span class="r-word">Time</span> y su método <span class="r-word">deltaTime</span>. <br>
Si se multiplica un movimiento por <span class="negrita">Time.deltaTime</span> se consigue que el movimiento sea constante independientemente de la cantidad de frames
de cada momento.
<span class="negrita">Time.deltaTime</span> devuelve el valor 0,02 (que corresponde a 20 milisegundos).
(Técnica usada hasta la creación del método siguiente).</li>
<li>El método <span class="r-word">FixedUpdate</span> de la clase <span class="negrita">MonoBehaviour</span>.
	Se ejecuta en intervalos regulares de tiempo de 20 ms (50 veces/segundo).</li>
    </ul>
  </p>
  
<p>Además, es habitual crear una propiedad de tipo float llamada <span class="negrita">speed</span> para usarla como multiplicador y controlar la velocidad.</p>

<p>Mover un objeto en el eje x dependiendo del valor de la propiedad speed desde el método <span class="negrita">Update</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-44-47.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">Método FixedUpdate</p>
<p>Por defecto el método <span class="negrita">FixedUpdate</span> se ejecuta cada 20 ms, 
  pero este comportamiento se puede cambiar desde <span class="negrita">Menú &rarr; Edit &rarr; Project Settings</span>… en la sección <span class="negrita">Time</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-45-47.png" /><br><figcaption></figcaption></figure>
<br>

<p>Mover un objeto en el eje x dependiendo del valor de la propiedad <span class="negrita">speed</span> desde el método <span class="r-word">FixedUpdate</span></p>
<figure><img src="UD9/images/ud9-2024-01-29-11-46-19.png" /><br><figcaption></figcaption></figure>
<br>
<p>Con los dos métodos, Update y Fixedupdate se puede conseguir el mismo resultado si se acaba multiplicando por el mismo valor.</p>
<figure><img src="UD9/images/ud9-2024-01-29-11-47-06.png" /><br><figcaption>speed*Time.deltaTime</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-29-11-47-21.png" /><br><figcaption>speed</figcaption></figure>
<br>
<p>La ventaja de FixedUpdate es que se puede configurar desde los ajustes del proyecto.</p>

</section><!-- End section El componente Transform-->

<!--*********************************************************La clase Input***********************************************************-->
<section class="apartado">
<a name="sLa_clase_Input"></a>
<h2>La clase Input</h2>
<p>Mediante la clase <span class="r-word">Input</span> se pueden capturar <span class="negrita">los eventos de entrada</span>
   del dispositivo del usuario (teclado, ratón, gamepad…).</p>

<p>La <span class="negrita">clase Input permite unificar</span> en un único punto todos los dispositivos de entrada disponibles.</p>

<p>Unity ofrece una herramienta donde poder configurar los dispositivos de entrada.</p>

<p>En muchos juegos también se permite cambiar esa configuración para que el usuario tenga una experiencia personalizada.</p>

<p>Desde el <span class="negrita">Menu &rarr; Edit &rarr; Project Settings…</span>
   se abre la configuración del proyecto, allí en la opción <span class="negrita">Input Manager</span> se puede visualizar y
    configurar los <span class="negrita">dispositivos de entrada</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-29-19-19-18.png" /><br><figcaption></figcaption></figure>
<br>
<p>La clase <span class="r-word">MonoBehaviour</span> ofrece algunos métodos que permiten ejecutar código cuando se producen eventos de ratón:
<ul>
  <li><span class="negrita">OnMouseDown</span></li>
  <li><span class="negrita">OnMouseDrag</span></li>
  <li><span class="negrita">OnMouseEnter</span></li>
  <li><span class="negrita">OnMouseExit</span></li>
  <li><span class="negrita">OnMouseOver</span></li>
  <li><span class="negrita">OnMouseUp</span></li>
  <li><span class="negrita">OnMouseUpAsButton</span></li>
</ul>
</p>
<p>La <span class="negrita"> clase Input</span> tiene una serie de métodos que devuelven un valor booleano cuando se produce la interacción del usuario con una <span class="negrita">tecla</span>, 
  <span class="negrita">un botón del ratón</span> o un <span class="negrita">botón virtual</span> como "<span class="cursiva">Fire1</span>".</p>

<p>Estos métodos se suelen utilizar dentro del método Update del script debido a que se ejecuta muchas más veces que otros métodos.</p>
<figure><img src="UD9/images/ud9-2024-01-29-19-21-12.png" /><br><figcaption></figcaption></figure>
<br>
<p>
  <ul>
    <li>Input.GetKeyDown(KeyCode.E)
Input.GetKey(KeyCode.V)
Input.GetKeyUp(KeyCode.Space)
Input.GetMouseButtonDown(0)
Input.GetMouseButton(1)
Input.GetMouseButtonUp(2)
Input.GetMouseButtonUp("Fire1")
Input.GetMouseButton("Jump")
</li>
  </ul>
</p>

<p>Todos los métodos en la  <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Input.html">documentación</a></p>

<p>La <span class="negrita">clase Input</span> tiene una serie de métodos para capturar los valores de los ejes de movimiento.</p>

<p>Estos métodos devuelven un valor decimal float que cuando el eje está en reposo el valor es 0 y cuando se pulsan devuelven un entre -1 y 1 dependiendo de la aceleración (tiempo de pulsación de la tecla o rango de movimiento del joystick).</p>
<p>Existen los ejes:
  <ul>
    <li>Horizontal y Vertical: w, a, s, d, flechas, joystick, cruceta.
      <ul>
          <li>Input.GetAxis("Horizontal")</li>
          <li>Input.GetAxis("Vertical")</li>
      </ul>
    </li>
    <li>Mouse X y Mouse Y: asignados al movimiento del ratón.
      <ul>
<li>Input.GetAxis("Mouse X")</li>
<li>Input.GetAxis("Mouse Y")</li>
      </ul>
    </li>
  </ul>
</p>


<h3>Movimiento mediante la clase Input</h3>
<p>Gracias a la <span class="negrita">clase Input se pueden mover GameObjects</span> cuando el usuario interactúe con los <span class="negrita">dispositivos de entrada</span>.</p>

<p>En el código, teniendo la cámara con la orientación que se indica con el gizmo:
  <ul>
    <li>flecha arriba o w	 &rarr;	<span class="negrita">mover</span> hacia adelante (se aleja de la cámara).</li>
    <li>flecha abajo o s	 &rarr;	<span class="negrita">mover</span> hacia atrás ( se acerca a la cámara).</li>
    <li>flecha izquierda o a &rarr;	<span class="negrita">mover</span> hacia izquierda.</li>
    <li>flecha derecha o d &rarr;	<span class="negrita">mover</span> hacia derecha.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-12-50-54.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-31-12-51-05.png" /><br><figcaption></figcaption></figure>
<br>
<p><ul>
  <li>flecha arriba o w		&rarr;	<span class="negrita">mover</span> hacia adelante.</li>
	<li>flecha abajo o s		&rarr;	<span class="negrita">mover</span> hacia atrás.</li>
	<li>flecha izquierda o a	&rarr;	<span class="negrita">rotar</span> hacia izquierda.</li>
	<li>flecha derecha o d	&rarr;	<span class="negrita">rotar</span> hacia derecha</li>
</ul></p>

<figure><img src="UD9/images/ud9-2024-01-31-12-55-05.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con cualquiera de los dos códigos anteriores, si se sitúa la cámara detrás del GameObject, en la misma orientación x y se añade la cámara como hija del GameObject, 
  la cámara seguirá al GameObject mientras se mueva.</p>

<figure><img src="UD9/images/ud9-2024-01-31-12-55-32.png" /><br><figcaption></figcaption></figure>
<br>
<br>
<hr>
<br>
<div class="tarea">
  <p>
    <span class="subrayado negrita">Actividad 7.  Modificando GameObjects mediante Inputs</span> <br>
Crea un proyecto 3D en Unity llamado <span class="subrayado">InputsTuNombre</span>. <br>
Pon la cámara de visualización como si se fuera a desarrollar un juego en 2D (eje z hacia atrás). <br>
Añade a la escena un plano y modifica su tamaño para que sea de 15x15x15 y esté en las coordenadas (0, 0, 0). <br>
Añade un GameObject del tipo Capsule y sitúalo en las coordenadas (0, 1, 0). <br>
Añade un GameObject del tipo Cube y sitúalo en las coordenadas (3, 0.5, 0). <br>
Añade un GameObject del tipo Sphere y sitúalo en las coordenadas (6, 0.5, 0). <br>
Crea un material de color naranja y asígnaselo al GameObject Capsule. <br>
Crea un material de color azul y asígnaselo al cubo. <br>
Crea un material de color verde y asígnaselo a la esfera <br>
Duplica el cubo y muévelos por el plano (puedes hacer unas 20  copias). <br>
Crea un script para la cápsula y añade en él el código necesario para realizar las siguientes acciones:
<ul>
  <li>Al pulsar los ejes Horizontal y vertical la cápsula debe moverse por el plano.</li>
  <li>Al pulsar la tecla E la esfera debe escalarse en todos sus ejes creciendo 0.5.</li>
  <li>Al pulsar la tecla Q la esfera debe escalarse en todos sus ejes decreciendo -0.5. Debes comprobar que la esfera nunca sea más pequeña que 0.5.</li>
</ul>
 <br>
Crea un script para la cámara y añádele el código para que siempre esté mirando hacia la cápsula

  </p>
</div>

</section><!-- End section La clase Input-->
<!--*********************************************************Movimiento cinemático y movimiento físico***********************************************************-->
<section class="apartado">
<a name="sMovimiento_cinematico_y_movimiento_fisico"></a>
<h2>Movimiento cinemático y movimiento físico</h2>
<p>Tipos de movimientos en Unity:
  <ul>
    <li><span class="negrita">Cinemático</span>:
      <ul>
        <li>Movimiento que se realiza directamente sobre el componente transform del GameObject.</li>
        <li>Estos movimientos son independientes de las físicas del juego (gravedad, aceleración, impulsos, inercias, rozamiento…).</li>
      </ul>
    </li>
    <li><span class="negrita">Físico</span>:
      <ul>
        <li>Movimientos que se realizan usando el motor físico del juego.</li>
        <li>El GameObject debe tener el componente <span class="negrita">Rigidbody</span>.</li>
      </ul>
    </li>
  </ul>
</p>

<p>Al añadir el componente <span class="r-word">Rigidbody</span> a un GameObject en el inspector se puede ver su configuración.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-00-16.png" /><br><figcaption></figcaption></figure>
<br>

<p>Propiedades de <span class="negrita">Rigidbody</span>:
<ul>
    <li><span class="negrita">Mass</span>: peso del objeto en kilogramos.</li>
  <li><span class="negrita">Drag</span>: resistencia al movimiento lineal.</li>
  <li><span class="negrita">Angular Drag</span>: resistencia a las rotaciones.</li>
  <li><span class="negrita">Use Gravity</span>: indica si le afecta o no la gravedad.</li>
  <li><span class="negrita">Is Kinematic</span>: si se activa, el GameObject no se verá afectado por el motor físico.
    Se suele activar para detectar colisiones.	(solo se podrá manipular con su Transform).</li>
  <li><span class="negrita">Constraints</span>: permite bloquear coordenadas.</li>

</ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-02-08.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con los movimientos cinemáticos (sin físicas) cuando se mueve un GameObject lo que ocurre es que el GameObject se está <span class="negrita">transportando</span>
   a la nueva posición.</p>

<p>Cuando un GameObject tiene el componente <span class="negrita">Rigidbody</span> no es recomendable modificar su posición usando su 
  Transform ya que al transportarse a la nueva posición podría aparecer parcialmente dentro de otro objeto y generar una colisión indeseada.</p>

<p>Para mover un GameObject que tenga un Rigidbody se le deben <span class="negrita">aplicar fuerzas que empujen</span> al GameObject en alguna dirección.</p>

<p>Si las <span class="negrita">fuerzas se aplican sin interacción con el Input</span> se utiliza el método <span class="negrita">FixedUpdate</span>.</p>

<p>Si las <span class="negrita">fuerzas se aplican con interacción con el Input</span> se utiliza el método <span class="negrita">Update</span>.</p>

<h3>Movimiento Físico</h3>
<p>Ejemplo de movimiento físico:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-29-35.png" /><br><figcaption></figcaption></figure>
<br>

<p>Con el código anterior se debe tener cuidado con los materiales físicos de los GameObjects 
  ya que la fricción puede hacer que el GameObject no se comporte como se desea.</p>

<p>El suelo ofrece rozamiento y al empujar al GameObject este vuelca hacia adelante.</p>

<p>Además, por la fricción, al aplicar las fuerzas el GameObject tarda un tiempo en realizar el movimiento y al parar de aplicar fuerzas el GameObject va frenándose.</p>

<figure><img src="UD9/images/ud9-2024-01-31-13-30-46.png" /><br><figcaption></figcaption></figure>
<br>
<p>Para solucionar estos problemas se puede optar una de las siguientes opciones:
  <ul>
    <li>Crear <span class="negrita">Materiales físicos</span> para ofrecer más realismo. 
      Estos materiales físicos se deben configurar correctamente y se deben de asignar a los GameObject que afecten al movimiento como son superficies o personaje.</li>
    <li>Añadir <span class="negrita">restricciones</span> al componente Rigidbody para bloquear la posición y/o rotación en alguno de los 3 ejes.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-32-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>Como se ha visto para aplicar fuerzas se necesita una propiedad el tipo Rigidbody en el código.</p>

<p>Algunos de los métodos que se pueden utilizar son:
  <ul>
    <li><span class="negrita">AddForce</span>: aplica fuerzas de empuje en las coordenadas del mundo.</li>
    <li><span class="negrita">AddTorque</span>: aplica fuerzas de giro en las coordenadas del mundo.</li>
    <li><span class="negrita">AddRelaviteForce</span>: aplica fuerzas de empuje en las coordenadas locales.</li>
    <li><span class="negrita">AddRelaviteTorque</span>: aplica fuerzas de giro en las coordenadas locales.</li>
    <li><span class="negrita">AddForceAtPosition</span>: aplica fuerzas de empuje en una posición determinada.</li>
    <li><span class="negrita">AddExplosionForce</span>: se utiliza para simular explosiones.</li>
  </ul>
</p>

<p>Estos métodos tienen una versión que además de recibir un Vector3 también se les puede indicar el tipo de fuerza a aplicar con las siguientes propiedades:
  <ul>
    <li><span class="negrita">ForceMode.Force</span>: en función del objeto. fuerza = masa * aceleración.</li>
    <li><span class="negrita">ForceMode.Acceleration</span>: aceleración ignorando la masa del GameObject.</li>
    <li><span class="negrita">ForceMode.Impulse</span>: aplica la fuerza de manera instantánea en un frame (se usa en Update).</li>
    <li><span class="negrita">ForceMode.VelocityChange</span>: aplica directamente una velocidad.</li>
  </ul>
</p>

<p>Usando solo movimientos físicos se puede mantener la inercia de los movimientos en cualquier eje.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-35-11.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Combinación de movimientos cinemáticos y físicos</h3>
<p>Aunque no es recomendable, se pueden mezclar los dos tipos de movimiento:
  <ul>
    <li><span class="negrita">Cinemático</span>: mover al personaje/enemigos por las superficies.</li>
    <li><span class="negrita">Físico</span>: aplicar fuerza hacia arriba para que el personaje salte.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-36-07.png" /><br><figcaption></figcaption></figure>
<br>

<p>El problema con este código es que si se deja de mover el personaje en mitad de un salto, no mantendrá la inercia en el salto.</p>
 <br><br>
 <hr>
 <br>
 <div class="tarea">
  <p>
    <span class="subrayado negrita">Actividad 8. Rigidbody y seguimiento de cámara</span> <br>
    Abre el proyecto <span class="subrayado">InputsTuNombre</span>.
    Añade a la cápsula el componente Rigidbody. <br>
    Configura las restricciones del Rigidbody de la cápsula para que no vuelque al chocar. <br>
    A la hora de programar el movimiento de la cápsula había dos opciones, la que rotaba con las teclas a y d y la que no rotaba. 
    Si usaste la que no rotaba, cambia el código para usar la opción que sí que rota. <br>
    Añade a la esfera el componente Rigidbody. <br>
    Desactiva el script de la cámara. <br>
    Pon la visualización detrás de la cápsula como en la imagen (eje z apuntando al fondo). <br>
     <figure><img src="UD9/images/ud9-2024-02-01-10-37-56.png" /><br><figcaption></figcaption></figure>
     <br>
     
    Selecciona la cámara y selecciona la opción Menú &rarr; GameObject &rarr; Align With View. <br> <br>
    Haz que la cámara sea hija de la cápsula. <br> <br>
    Ejecuta el juego y mueve la cápsula para observar que la cámara ahora sigue a la cápsula y que la cápsula colisiona con el resto de GameObjects gracias al Rigidbody.
    
  </p>
 </div>


</section><!-- End section Movimiento cinemático y movimiento físico-->

<!--*********************************************************Colisiones***********************************************************-->
<section class="apartado">
<a name="sColisiones"></a>
<h2>Colisiones</h2>
<p>Para poder detectar las colisiones entre GameObjects, estos deben tener un componente <span class="r-word">Collider</span> 
  (suele estar presente en todos los GameObjects).</p>

<p>Unity ofrece dos mecanismos que permiten detectar las colisiones entre GameObjects:
  <ul>
    <li>Mediante <span class="negrita">Collider</span>.</li>
    <li>Mediante <span class="negrita">Trigger</span> (Collider marcado como is Trigger generalmente cuando son GameObjects sin representación gráfica en pantalla).</li>
  </ul>
</p>

<p>Lo más habitual es utilizar el nombre del GameObject o las etiquetas (<span class="negrita">Tag</span>) para detectar las colisiones.</p>

<h3>Colisiones con Collider</h3>
<p>Las <span class="negrita">colisiones mediante collider</span> se utilizan cuando un GameObject toca a otro.</p>

<p>Por ejemplo:
  <ul>
    <li>El jugador empuja a otro GameObject.</li>
    <li>Un GameObject impacta en otro GameObject como podría ser un disparo.</li>
    <li>…</li>
  </ul>
</p>

<p>Los collider pueden ser 3D o 2D, así, la clase MonoBehaviour ofrece métodos que se ejecutarán cuando se detecte una colisión entre colliders.</p>

<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter(Collision collision)</span>: se activa en el frame en el que inicia la colisión.</li>
    <li><span class="negrita">void OnCollisionStay(Collision collision)</span>: activo mientras la colisión se mantiene.</li>
    <li><span class="negrita">void OnCollisionExit(Collision collision)</span>: se activa en el frame que termina la colisión.</li>
  </ul>
</p>

<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionStay2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionExit2D(Collision collision)</span></li>
  </ul>
</p>

<p>En los métodos se recibe un objeto del tipo Collisión a través del cual se podrá acceder a todo lo relacionado con la colisión y con el otro GameObject.</p>

<p>Al colisionar con otros GameObjects se pueden ejecutar acciones.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-40-49.png" /><br><figcaption></figcaption></figure>
<br>

<p>A través de la colisión se puede acceder a todos los elementos del GameObject contra el que se ha colisionado.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-41-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Colisiones con Trigger</h3>
<p>Las <span class="negrita">colisiones con trigger</span> se utilizan para determinar si un GameObject esta en una zona determinada</p>
<p>Por ejemplo:
  <ul>
    <li>Un GameObject tiene un collider más grande que su tamaño para poder detectar que el jugador está en el radio de acción 
      y cuando pulse una tecla lo pueda recoger (consumible) o utilizar (interruptor).</li>
    <li>Un GameObject vacío tiene un collider para detectar si el jugador está dentro de él.</li>
    <li>…</li>
  </ul>
</p>

<p>Para que un GameObject actúe como Trigger se debe marcar la opción <span class="negrita">Is Trigger</span> en el Inspector dentro del componente Collider.</p>

<p>En ocasiones los GameObject que actúan como Trigger solo tienen los componentes Transform y Collider porque no es necesario que se muestren en pantalla.</p>

<p>Si se configura un collider como Is Trigger los métodos que ofrece la clase MonoBehaviour son los siguientes:</p>


<p class="sub-section">Versiones 3D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter(Collider other)</span>: se activa en el frame en el que inicia la colisión.</li>
    <li><span class="negrita">void OnTriggerStay(Collider other)</span>: activo mientras la colisión se mantiene.</li>
    <li><span class="negrita">void OnTriggerExit(Collider other)</span>: se activa en el frame que termina la colisión.</li>
  </ul>
</p>


<p class="sub-section">Versiones 2D:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerStay2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerExit2D(Collider other)</span></li>
  </ul>
</p>

<p>En esta ocasión el otro objeto se recibe en los métodos como objetos del tipo Collider que es el Collider del otro GameObject implicado.</p>
<p>En el GameObject que se mueve:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-44-02.png" /><br><figcaption></figcaption></figure>
<br>


<p>En el GameObject configurado como <span class="negrita">is Trigger</span>:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-44-10.png" /><br><figcaption></figcaption></figure>
<br>

<p>En el siguiente ejemplo, un GameObject invisible con un Collider aplica una fuerza que hace flotar a otro GameObject que esté dentro de él, 
  siempre y cuando el otro GameObject tenga un componente Rigidbody:</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-45-12.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Colisiones-->

<!--*********************************************************Métodos Intersantes***********************************************************-->
<section class="apartado">
<a name="sMetodos_Intersantes"></a>
<h2>Métodos Interesantes</h2>
<h3>Método Destroy</h3>
<p>El método <span class="r-word">Destroy</span> elimina al GameObject, si no se indica tiempo se eliminará inmediatamente, 
  si se indica tiempo se eliminará pasados esos segundos.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-47-43.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Método Instantiate</h3>
<p>El método <span class="r-word">Instantiate</span> permite crear GameObjects en tiempo de ejecución.</p>

<p>Ejemplos de uso:
  <ul>
    <li>Cuando el jugador dispara debe crearse el proyectil en ese punto y moverse en la dirección en la que apunta.</li>
    <li>En una zona del escenario aparece un enemigo en la parte superior que cae y al llegar abajo desaparece 
      (bucle con Instantiate, movimiento, detección por trigger al llegar abajo y Destroy).</li>
  </ul>
</p>

<p>Se crea un objeto cuando se pulsa el botón "<span class="cursiva">Fire1</span>" (botón izquierdo del ratón).</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-03.png" /><br><figcaption></figcaption></figure>
<br>
<p>Cuando el jugador toca al GameObject este se replica a si mismo 10 veces.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-19.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se crea un objeto cuando en intervalos de tiempo fijos sin tener que realizar ninguna acción.
Al GameObject creado se le aplica una fuerza al crearse y saldrá lanzado.
</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-37.png" /><br><figcaption>GameObject generador</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-01-31-13-49-55.png" /><br><figcaption>GameObject generado</figcaption></figure>
<br>

<h3>Utilidades</h3>
<p>Mediante los métodos <span class="r-word">Invoke</span> e <span class="r-word">InvokeRepeating</span>
   se puede indicar el tiempo de espera antes de realizar la llamada a otro método.</p>


<figure><img src="UD9/images/ud9-2024-01-31-13-50-28.png" /><br><figcaption></figcaption></figure>
<br>
<p>Se pueden cancelar las invocaciones a ctivas con el método <span class="r-word">CancelInvoke</span>.</p>
<p>Si no se le indica ningún parámetro cancelará todas las invocaciones, si se le pasa como parámetro el nombre de un método cancelará esa invocación.</p>

<figure><img src="UD9/images/ud9-2024-01-31-13-50-52.png" /><br><figcaption></figcaption></figure>
<br>

<p>Otra manera de realizar las tareas de <span class="r-word">InvokeRepeating</span> es con el uso de <span class="negrita">Corrutinas</span>.</p>
<figure><img src="UD9/images/ud9-2024-01-31-13-51-28.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para cancelar corrutinas se utilizan los métodos <span class="negrita">StopAllCoroutines</span> y <span class="negrita">StopCoroutine("NombreMétodo")</span>.</p>


<br><br>
<hr>
<br>
<div class="tarea">
  <p><span class="subrayado negrita">Práctica 6 – Pachinko</span></p>
  
<p>Un Pachinko es una máquina recreativa de origen japonés en la que el jugador tiene una gran cantidad de bolas de acero que se introducen en la máquina recreativa. <br>
La máquina de pachinko tiene un sistema que lanza las bolas desde abajo por un lateral para que lleguen a la parte superior y desde ahí comiencen a bajar. <br>
En el tablero hay una serie de alfileres (pines) en los que las bolas metálicas rebotan y toman caminos de manera aleatoria. <br>
Además, en el tablero puede haber diferentes puertas por las que pueden entrar las bolas para así conseguir puntos con los que se consiguen premios, 
y en ocasiones, puertas que devuelven la bola al jugador para que vuelva a introducirla. <br>
Por último, las bolas que llegan a la parte inferior no otorgan premios. <br></p>


<p>A continuación, se pueden ver algunos ejemplos reales y en videojuegos.</p>
<figure><img src="UD9/images/ud9-2024-02-01-11-00-27.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-01-11-00-52.png" /><br><figcaption></figcaption></figure>
<br>


 	  	 
<p>Crea un proyecto 3D en Unity llamado <span class="subrayado">PachinkoTuNombre</span>. <br>
Instala en el proyecto el paquete de Unity que se <a class="enlace" target="_blank" href="./UD9/resources/pr-pachinko.unitypackage">adjunta</a> 
en la tarea de una de las siguientes maneras: 
<ul>
  <li>Al hacer doble clic en el archivo del paquete se abrirá la ventana de diálogo para incorporar todos los elementos del paquete. </li>
  <li>Al arrastrar el archivo del paquete se abrirá la ventana de diálogo para incorporar todos los elementos del paquete.</li>
</ul> <br>
</p>
<p>El paquete incluye además del tablero, una imagen con sprites y 
  una serie de materiales que puedes aplicar al tablero y a las bolas metálicas. <br> 

Todos los elementos del tablero incluyen un Collider para que las bolas no puedan traspasarlos, y además se incluye un Collider 
delante para que así las bolas no puedan salir despedidas hacia delante (quedando el hueco para las bolas metálicas).</p>
<figure><img src="UD9/images/ud9-2024-02-01-11-04-26.png" /><br><figcaption></figcaption></figure>
<br>

 <p>En el siguiente enlace puedes encontrar el mismo paquete que de materiales metálicos que se incluye con la tarea. 
Puedes usar alguno de esos materiales para las bolas metálicas. 
<a class="enlace" target="_blank" href="https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949">https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949</a></p>


<p>Primero deberás crear los siguientes prefabs (presta atención a la escala de los elementos para que no haya problema con las colisiones):
<ul>
  <li>Una bola metálica con físicas y colisiones.</li>
  <li>Un pin estático (puede ser un cilindro) con material metálico y con material físico para que reboten las bolas.</li>
  <li>Un pin giratorio (puede ser un cilindro con un cubo alargado, o con dos cubos alargados en forma de cruz o cualquier cosa que se te ocurra) 
    que no tendrá material que haga que rebote. En este pin cuando la bola choque con él, deberá girar el pin teniendo como eje su centro.</li>
   <figure><img src="UD9/images/ud9-2024-02-01-11-09-34.png" /><br><figcaption></figcaption></figure>
   <br>
   
  <li>Puerta en la que se ganan 5 puntos si la bola cae en ella.</li>
  <li>Puerta en la que se ganan 10 puntos si una bola cae en ella, debe ser algo más pequeña que la anterior.</li>
  <li>Puerta en la que se obtiene una bola extra.</li>
</ul></p>


<p>Los prefabs de las puertas deben tener los sprites incluidos para indicar al usuario qué ocurre al caer la bola en esas puertas.
En la escena debes añadir:
<li>En la parte superior central debe verse una foto tuya tipo carnet (actual), tu nombre la cantidad de puntos y la cantidad de bolas restantes.</li>
 <figure><img src="UD9/images/ud9-2024-02-01-11-12-11.png" /><br><figcaption></figcaption></figure>
 <br>
 
<li>Tantos pines estáticos y giratorios como quieras para que el juego se vea dinámico.</li>
<li>Dos puertas de 5 puntos.</li>
<li>Una puerta de 10 puntos.</li>
<li>Dos puertas de bola extra.</li></p>



<p><span class="subrayado">Mecánicas del juego:</span> 
<ul>
  <li>El juego empezará con 100 bolas y 0 puntos.</li>
  <li>Al pulsar la tecla flecha izquierda caerá una bola desde el hueco superior izquierdo y se restará una bola a la cantidad de bolas.</li>
  <li>Al pulsar la tecla flecha derecha caerá una bola desde el hueco superior derecho y se restará una bola a la cantidad de bolas.</li>
  <li>Cuando una bola cae en alguna puerta se deben sumar los puntos correspondientes o sumar una bola a la cantidad de bolas restantes.</li>
  <li>Cuando una bola cae en alguna puerta o por la parte inferior se debe destruir.</li>
  <li>En todo momento el HUD debe estar actualizado con los puntos actuales y la cantidad de bolas restantes.</li>
</ul></p>



<p>Los GameObjects en la escena deben tener nombres apropiados. <br>
Crea y asigna todas las etiquetas que veas que son necesarias. <br>
Crea los scripts necesarios y añádelos a los GameObjects o Prefabs para que el juego funcione correctamente.</p>


<p>
<span class="subrayado">Extras:</span>
<ul>
  <li>Cada vez que se cree una bola su material será uno aleatorio de entre todos los materiales de bolas metálicos incluidos en el paquete.</li>
  <li>Prefab de una puerta que premia al jugador con 50 bolas más. Debe ser una puerta que sea difícil que una bola caiga a ella. 
    Una vez creada la puerta añádela al tablero.</li>
  <li>Modificar el tablero para que sea como los pachinko originales en los que la bola se lanza desde abajo por el lateral hacia la parte superior del tablero. 
    En este caso las teclas de las flechas se sustituirán por la tecla espacio y al pulsarla se lanzará una bola. 
    Debes crear un mecanismo para que la fuerza de la bola pueda cambiar, por ejemplo, una rueda que gire con las teclas de las flechas e indique la potencia.</li>
</ul></p>



</div>

</section><!-- End section Métodos Intersantes-->

<!--*********************************************************Componente CharacterController***********************************************************-->
<section class="apartado">
<a name="sComponenteCharacterController"></a>
<h2>Componente CharacterController</h2>
<p>En muchos juegos en primera o tercera persona se necesitan las físicas para el control de algunas colisiones como por ejemplo 
  que el personaje no atraviese el suelo o las paredes.</p>

<p>Además, en estos juegos el movimiento no es realista de manera intencionada de manera que el personaje 
  puede empezar a moverse o cambiar de dirección de manera inmediata sin que le afecte ningún tipo de inercia.</p>

<p>Para estos casos Unity ofrece la clase <span class="r-word">CharacterController</span> que tiene funciones propias, 
  le afectan las colisiones y no necesita de un <span class="r-word">Rigidbody</span> facilitando así su uso.</p>

<p>Al añadir el componente <span class="negrita">CharacterController</span> a un GameObject automáticamente se añade un 
  <span class="subrayado">collider en forma de cápsula</span>  al GameObject 
  que está asociado al componente <span class="negrita">CharacterController</span>.</p>

<figure><img src="UD9/images/ud9-2024-02-20-18-19-30.png" /><br><figcaption>GameObject vacío</figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-02-20-18-19-46.png" /><br><figcaption>GameObjects compuestos</figcaption></figure>
<br>
<p>Todos los GameObjects que se representan gráficamente en la escena tienen un componente <span class="negrita">Collider</span>,
  puede ser interesante eliminarlo o desactivarlo si con el collider en forma de cápsula del CharacterController es suficiente.</p>
<figure><img src="UD9/images/ud9-2024-02-20-18-21-17.png" /><br><figcaption></figcaption></figure>
<br>

<p>Las <span class="negrita">propiedades del componente CharacterController</span> son las siguientes:
  <ul>
    <li><span class="negrita">Slope Limit</span> : el personaje podrá subir pendientes de hasta los grados indicados aquí.</li>
    <li><span class="negrita">Step Offset</span> : el personaje podrá subir escalones de como máximo 0,3 metros.</li>
    <li><span class="negrita">Skin Width</span> : ancho de la piel del collider (margen en el que no afectan las colisiones).</li>
    <li><span class="negrita">Min Move Distance</span> : valor mínimo para que se mueva el personaje.</li>
    <li><span class="negrita">Center</span> : posición del collider con respecto al GameObject.</li>
    <li><span class="negrita">Radius</span> : radio de la cápsula.</li>
    <li><span class="negrita">Height</span> : altura de la cápsula.</li>
  </ul>
</p>
<figure><img src="UD9/images/ud9-2024-03-05-09-59-36.png" /><br><figcaption></figcaption></figure>
<br>


<p>Como al <span class="negrita">CharacterController no le afectan las físicas</span>, 
  el componente ofrece una serie de propiedades y métodos para obtener información del 
  GameObject como por ejemplo la propiedad <span class="r-word">isGrounded</span> que indica si el elemento
   ha tocado el suelo durante su último movimiento.</p>

<p>El suelo será cualquier otro GameObject con un collider en el que el CharacterController pueda situarse encima de él.</p>


<p>Para mover al personaje hay disponibles dos métodos:
  <ul>
    <li><span class="negrita">Move</span> : permite mover al personaje especificándole todos los movimientos como gravedad, salto, desplazamiento horizontal…</li>
    <li><span class="negrita">SimpleMove</span> : permite mover al personaje afectándole la gravedad.</li>
  </ul>
</p>


<p>La técnica que se utiliza con el método <span class="r-word">Move</span> consiste en recopilar del <span class="negrita">Input</span> 
  y del resto de GameObjects de la escena todos los datos que afectan al movimiento 
  y con ellos calcular el vector de movimiento que se debe aplicar al personaje.</p>


<p>Algunos datos que se deben recopilar son:
  <ul>
    <li>¿Se está tocando el suelo?</li>
    <li>¿Se ha pulsado alguna tecla o botón?</li>
    <li>¿Hay que aplicar impulso hacia arriba porque se está saltando?</li>
    <li>…</li>
  </ul>
</p>

<p>Una primera aproximación del movimiento de un jugador con CharacterController donde el jugador se pueda mover por una superficie,
   sería la siguiente:</p>

<figure><img src="UD9/images/ud9-2024-02-20-18-26-04.png" /><br><figcaption></figcaption></figure>
<br>

<p>Las propiedades son públicas para poder consultar su valor en el <span class="cursiva">Inspector</span> 
  cuando se ejecuta el script.</p>

<p>Esta aproximación es muy sencilla ya que no tiene en cuenta la cámara ni la gravedad ni otros factores importantes. 
  Además, al moverse en diagonal se suman las dos fuerzas y el movimiento es más rápido, lo cual no tiene sentido.</p>

  <h3>Control de personaje con CharacterController</h3>

<p>A continuación, se va a mostrar una serie de scripts para:
  <ul>
    <li>Movimiento completo del jugador, incluidos el salto y el deslizamiento en pendientes pronunciadas.</li>
    <li>Seguimiento de la cámara al jugador.</li>
    <li>Poder empujar GameObjects afectados por la física (con Rigidbody).</li>
  </ul>
</p>
<p>Estos scripts están basados en los tutoriales de Unity y se pueden mejorar de varias maneras.</p>
<p class="sub-section">PlayerController.cs</p>

<figure><img src="UD9/images/ud9-2024-02-20-18-37-45.png" /><br><figcaption></figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-02-20-18-37-54.png" /><br><figcaption>PlayerController.cs</figcaption></figure>
<br>

<figure><img src="UD9/images/ud9-2024-02-20-18-38-58.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-20-18-39-20.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-20-18-39-46.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
<br>
<p class="sub-section">PushRigidBody.cs</p>
<figure><img src="UD9/images/ud9-2024-02-20-18-40-38.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-20-18-40-47.png" /><br><figcaption></figcaption></figure>
<br>

<p class="sub-section">ThirdPersonCamera.cs</p>
<figure><img src="UD9/images/ud9-2024-02-20-18-41-06.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-02-20-18-41-19.png" /><br><figcaption></figcaption></figure>
<br>

<h3>CharacterController vs Movimiento físico</h3>
<p>A la hora de implementar el movimiento del personaje se debe elegir entre:
  <ul>
    <li>Implementar el movimiento mediante físicas con Rigidbody. <br>
      Al utilizar físicas, el movimiento se vuelve más realista lo que puede ser un valor añadido en simuladores. <br>
      El control por parte del jugador será más complicado.</li>
      <li>Implementar el movimiento mediante cinemática con CharacterController. <br>
Al utilizar CharacterController, como desarrollador se tiene más facilidad de uso, 
control preciso de las colisiones y más eficiencia en general al estar optimizada para personajes. <br>
Además, el jugador tendrá un control más preciso que es muy útil para realizar acciones complejas. <br>
En la mayoría de los casos es suficiente la implementación con CharacterController.</li>
  </ul>
</p>

</section><!-- End section Componente CharacterController-->

<a href="#s"></a>
<!--*********************************************************Cámara profesional***********************************************************-->
<section class="apartado">
<a name="sCamaraprofesional"></a>
<h2>Cámara profesional</h2>
<p>Unity ofrece un paquete llamado <span class="r-word">Cinemachine</span> que ofrece herramientas y 
  de cámaras virtuales que simulan un estudio de grabación y permiten un control total de la cámara.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-24-06.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-24-16.png" /><br><figcaption></figcaption></figure>
<br>


<p>Una vez instalado el paquete, en el <span class="negrita">Menú &rArr; Component &rArr; Cinemachine</span> 
   se encuentran las configuraciones de cámaras virtuales que se pueden añadir a la cámara de la escena.</p>

<figure><img src="UD9/images/ud9-2024-03-11-10-25-13.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-25-32.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Cámara profesional-->


<!--*********************************************************Movimiento Programado***********************************************************-->
<section class="apartado">
<a name="sMovimientoProgramado"></a>
<h2>Movimiento Programado</h2>

<p>En un video juego puede haber elementos que tengan un movimiento programado,
  por ejemplo, un enemigo que se mueve de un lado a otro siempre en la misma ruta o una plataforma que va de un punto a otro.</p>


<p>En estos casos la mecánica siempre es la misma:
  <ul>
    <li>Se crea un GameObject vacío.</li>
    <li>Se añade a ese GameObject el GameObject que va a moverse (enemigo, plataforma…).</li>
    <li>Se añaden a ese GameObject tantos GameObjects vacíos como puntos se deben alcanzar al moverse.</li>
    <li>En un script añadido al elemento que va a moverse se indica el movimiento de punto a punto.</li>
  </ul>
</p>
<p>El conjunto anterior quedará así si la plataforma solo tiene que ir a dos puntos:</p>
<figure><img src="UD9/images/ud9-2024-03-05-10-03-16.png" /><br><figcaption></figcaption></figure>
<br>

<br>
<p>En el GameObject que se debe mover se añade un script con el siguiente código:</p>
<figure><img src="UD9/images/ud9-2024-02-20-18-53-12.png" /><br><figcaption></figcaption></figure>
<br>


<p>En este código se utiliza el movimiento cinemático para trasladar la plataforma de un lugar a otro.</p>

<p>El código anterior se puede mejorar creando un array de posiciones destino y 
  haciendo que cuando el GameObject pase por todas las posiciones repetidamente.</p>

<p>También se puede indicar que el GameObject haga una pausa al llegar a un destino.</p>

<p>Si se añade un <span class="negrita">RigidBody a la plataforma</span>  (que no use gravedad y que sea kinemático), 
  se podrá hacer que el jugador u cualquier otro GameObject pueda quedarse encima de la plataforma y moverse con ella.</p>

<p>Al tener un Rigidbody el movimiento debe hacerse con físicas.</p>

<p>En este caso el script se situará en el GameObject padre de la plataforma.</p>

<p>Este código se debe añadir al GameObject padre del que se mueve.</p>
<figure><img src="UD9/images/ud9-2024-03-05-10-55-07.png" /><br><figcaption></figcaption></figure>
<br>
<p>Además se deberá arrastrar en el inspector la plataforma y los puntos por los que debe pasar la plataforma.</p>

<figure><img src="UD9/images/ud9-2024-03-11-10-28-20.png" /><br><figcaption></figcaption></figure>
<br>


<p>Al tener la plataforma un Rigidbody el movimiento debe ser físico.</p>

<figure><img src="UD9/images/ud9-2024-03-11-10-28-38.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si se ha implementado el movimiento del personaje mediante el componente <span class="negrita">CharacterController</span> 
   y se usa el ejemplo anterior para mover una plataforma, el personaje no se mantendrá encima de la plataforma.</p>

<p>Esto ocurre porque la plataforma contiene un Rigidbody y se mueve mediante físicas pero el personaje no tiene Rigidbody.</p>

<p>Para solucionar esto se debe detectar el suelo que está tocando el personaje y
  cuando esté en la plataforma mover al personaje lo mismo que se mueve la plataforma.</p>

<p>Para realizar esto se pueden utilizar los <span class="negrita">Raycast</span> .</p>
</section><!-- End section Movimiento Programado-->

<!--*********************************************************Raycast***********************************************************-->
<section class="apartado">
<a name="s"></a>
<h2>Raycast</h2>

<p>Un <span class="negrita">Raycast</span>  consiste en la emisión de un rayo.</p>

<p>Un <span class="negrita">rayo</span>  es una línea <span class="negrita">imaginaria</span>  que sale desde un punto y va en una dirección determinada.</p>

<p>Al realizar emisiones de rayos con Raycast se puede detectar los GameObjects y los triggers que se encuentran en la trayectoria del rayo.</p>

<p>Para emitir un rayo se necesita:
  <ul>
    <li>Un objeto de la clase <span class="negrita">Ray</span> .</li>

    <li>Un objeto de la clase <span class="negrita">RaycastHit</span>  que indicará en qué GameObject impacta el rayo.</li>
    
    <li>Emitir el rayo con el método <span class="negrita">Raycast</span>  de la clase <span class="negrita">Physics</span> .</li>
  </ul>
</p>

<p>Algunas utilidades de Raycast son:
  <ul>
    <li>Detectar colisiones.</li>
    <li>Detectar si un GameObject está en la trayectoria de otro.</li>
    <li>Seleccionar elementos con el ratón.</li>
    <li>Realizar disparos.</li>
    <li>…</li>
  </ul>
</p>

<p>En el siguiente ejemplo se emite un rayo y cuando impacta se muestra un mensaje:</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-29-22.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-29-32.png" /><br><figcaption></figcaption></figure>
<br>

<p>Si los rayos no se visualizan al ejecutar se deberán activar en la parte de la derecha de la visualización de la Scene o del Game en el apartado Gizmos:</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-29-55.png" /><br><figcaption></figcaption></figure>
<br>

<p>El método <span class="negrita">Raycast</span>  tiene varias versiones.</p>

<figure><img src="UD9/images/ud9-2024-03-11-10-30-21.png" /><br><figcaption></figcaption></figure>
<br>

<p>Una de las versiones admite un segundo parámetro de la clase <span class="negrita">RaycastHit</span>,
  en este objeto se almacenará toda la información sobre el impacto, incluido el GameObject en el que impacta el rayo.</p>

<p>Se debe declarar el objeto de la clase <span class="negrita">RaycastHit</span> antes de realizar la llamada al método 
  <span class="negrita">Raycast</span>.</p>

  <figure><img src="UD9/images/ud9-2024-03-11-10-30-58.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-31-08.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Se pueden aplicar <span class="negrita">filtros</span> para que el rayo solo impacte en los GameObjects afectados por ese filtro.
    <ul>
      <li><span class="negrita">Por distancia</span>: menor o igual a 7
        <figure><img src="UD9/images/ud9-2024-03-11-10-33-47.png" /><br><figcaption></figcaption></figure>       
      </li>
      <li><span class="negrita">Por capas</span>: igual que se pueden crear etiquetas (tags) se pueden crear capas  (layers) y 
        asignarlas a los GameObjects. Las capas se pueden indicar creando una variable de la clase LayerMask. 
        En el inspector se podrán selecciona varias capas.
      <figure><img src="UD9/images/ud9-2024-03-11-10-34-16.png" /><br><figcaption></figcaption></figure>
      <br>
      
      </li>
    </ul>
  </p>
  
  <p>Se puede indicar que el rayo no impacte en los Collider tipo Trigger.</p>

  <figure><img src="UD9/images/ud9-2024-03-11-10-34-47.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Por defecto un rayo solo impacta en el primer GameObject con el que se encuentra, 
    este comportamiento se puede cambiar si se utiliza el método <span class="negrita">RaycastAll</span> de la clase <span class="negrita">Physics</span> .</p>
  <p>Este método devuelve un array con todos los GameObjects en los que impacta el rayo.</p>
   <figure><img src="UD9/images/ud9-2024-03-11-10-35-12.png" /><br><figcaption></figcaption></figure>
   <br>
   
  <p>Se pueden emitir rayos desde la cámara, esto permite funciones como seleccionar objetos con el ratón.</p>
  
<p>El siguiente script se debe añadir a la cámara. 
  Este script no puede llamarse Camera porque sobre escribiría la clase <span class="negrita">Camera</span>  de Unity.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-36-10.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-36-19.png" /><br><figcaption></figcaption></figure>
<br>


  <p>En muchos videojuegos se utilizan los Raycast para detectar colisiones, por ejemplo, para saber si el personaje está tocando el suelo.</p>
  
  <p>Para detectar colisiones entre GameObjects usando Raycast se debe lanzar un rayo cuya distancia no supere mucho al GameObject 
    desde el que se emite.</p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-36-40.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-36-48.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>En algunos videojuegos se emiten rayos desde diferentes puntos del personaje para controlar así su movimiento.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-37-07.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-37-15.png" /><br><figcaption></figcaption></figure>
<br>

  <p>Con el método Raycast se emite un rayo, que es una línea.</p>
  
<p>La clase Physics ofrece otros tipos de emisión con otras formas:
  <ul>
    <li><span class="negrita">BoxCast</span>: emite un rayo cuyo haz tiene forma de cubo</li>
    <li><span class="negrita">CapsuleCast</span>: emite un rayo cuyo haz tiene forma de cápsula</li>
    <li><span class="negrita">SphereCast</span>: emite un rayo cuyo haz tiene forma de esfera</li>
    <li><span class="negrita">LineCast</span>: devuelve true si hay algún objeto con el que el rayo impacte</li>
  </ul>
</p>

<p>A continuación, se muestra un script que amplía la funcionalidad del control del personaje con <span class="negrita">CharacterController</span> 
   en el que se comprueba si el GameObject está tocando el suelo usando un <span class="negrita">SphereCast</span> .</p>

   <h3>Control de personaje – Sobre plataformas móviles</h3>    
   <p>Así, para que un personaje con CharacterController pueda moverse junto con una plataforma con Rigidbody que está pisando, 
    se debe añadir el siguiente script al personaje:</p>

    <figure><img src="UD9/images/ud9-2024-03-11-10-37-55.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD9/images/ud9-2024-03-11-10-38-03.png" /><br><figcaption></figcaption></figure>
    <br>
    
</section><!-- End section Raycast-->


<!--*********************************************************sNPCs***********************************************************-->
<section class="apartado">
<a name="sNPCs"></a>
<h2>NPC's</h2>
<p>Los <span class="negrita">NPC</span>  (<span class="negrita">N</span>on <span class="negrita">P</span>layable 
<span class="negrita">C</span>haracters) son aquellos personajes que los controla el propio videojuego 
y sobre los cuales el jugador no puede indicarle qué acciones debe realizar.</p>

<p>Los NPC se pueden clasificar en:
  <ul>
    <li><span class="negrita">Enemigos</span>: presentan un desafío que se debe superar para poder continuar.</li>
    <li><span class="negrita">Aliados</span>: acompañan al jugador pudiendo aportar ayuda en puzles y combates.</li>
    <li><span class="negrita">Influenciables</span>: dependiendo de las acciones pueden convertirse en aliados o enemigos.</li>
    <li><span class="negrita">Comerciantes</span>: ofrecen la posibilidad de intercambiar objetos para mejorar y/o avanzar.</li>
    <li><span class="negrita">Informativos</span>: solo proporcionan información con o sin importancia para la misión.</li>
    <li><span class="negrita">Decorativos</span>: existen para dotar al juego de un ambiente más realista completando las escenas.</li>
  </ul>
</p>

<p>En general un NPC puede ser:
  <ul>
    <span class="negrita">Activo</span>: ofrece misiones, información, objetos que cambian a medida que el jugador avanza.
    <span class="negrita">Pasivos</span>: repiten la misma información o comportamiento cada vez que el jugador interactúa con ellos.
  </ul>
</p>

<p>A los NPC se les presupone un mínimo de <span class="negrita">IA</span> (<span class="negrita">I</span>nteligencia 
  <span class="negrita">A</span>rtificial), esta IA consiste en programar el comportamiento que debe tener el NPC.
  Se pueden programar IA's más simples y más complejas.</p>

<p>En el siguiente ejemplo se va a estudiar como 
  <span class="negrita">implementar que un NPC vaya de un punto a otro por el camino más óptimo</span>.</p>

<p>Esta técnica también se puede utilizar para que el personaje vaya a un punto seleccionado con el ratón 
  o que un enemigo realice una ronda por el escenario y que al ver al jugador le persiga.</p>



<p>Se necesita instalar el paquete <span class="r-word">AI Navigation</span>.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-38-48.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al instalar el paquete AI Navigation se añadirá una nueva opción: <span class="negrita">Menú</span>  &rarr; <span class="negrita">Window</span>  &rarr;
<span class="negrita">AI</span>  &rarr; <span class="negrita">Navigation</span> .</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-38-59.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al pulsar la opción <span class="negrita">Menú</span>  &rarr; <span class="negrita">Window</span>  &rarr; <span class="negrita">AI</span> 
   &rarr; <span class="negrita">Navigation</span>  aparece la ventana Navigation.</p>

<p>En la pestaña <span class="negrita">Agents</span>  se pueden definir las características del GameObject 
  que se va a mover por la ruta más óptima.</p>

  <figure><img src="UD9/images/ud9-2024-03-11-10-39-33.png" /><br><figcaption></figcaption></figure>
  <br>
  
<p>Se pueden crear tantos agentes como se quiera, por ejemplo, puede haber enemigos que no pueden saltar sobre un muro y otros que sí.</p>

<p>En la pestaña <span class="negrita">Areas</span>  se pueden definir las diferentes áreas y su prioridad (Cost),
  a menor número mayor prioridad de pasar por esa área.</p>

  <figure><img src="UD9/images/ud9-2024-03-11-10-39-43.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>A los GameObjects que se deben mover se les debe añadir el componente <span class="negrita">NavMeshAgent</span> .</p>
  
  <p>En el ejemplo, la cápsula se moverá hasta la posición de la esfera por el camino más óptimo.</p>
  
  <p><span class="negrita">Se ha añadido el componente NavMeshAgent a la cápsula</span> , en el inspector se puede ver las opciones de configuración que tiene.</p>
  
  <figure><img src="UD9/images/ud9-2024-03-11-10-40-08.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-40-16.png" /><br><figcaption></figcaption></figure>
  <br>
  

<p>Ahora se debe añadir el componente <span class="negrita">NavMeshSurface</span>  sobre los GameObjects de la escena y asignarle el área que se quiera.</p>

<p>Este componente permite definir <span class="negrita">por dónde podrá moverse el agente</span> .</p>

<p>En el ejemplo, el suelo y todos los bloques están dentro de un GameObject y en ese GameObject se añade el componente NavMeshSurface.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-40-43.png" /><br><figcaption></figcaption></figure>
<br>
<figure><img src="UD9/images/ud9-2024-03-11-10-40-50.png" /><br><figcaption></figcaption></figure>
<br>


<p>Una vez configurado el NavMeshSurface se debe pulsar la opción <span class="negrita">Bake</span> .</p>

<p>Esta opción genera la superficie por la que el personaje se podrá mover. 
  Se puede observar que se deja un margen alrededor de los obstáculos para evitar comportamientos imprevistos. 
  Esta superficie se puede modificar cambiando los ajustes del <span class="negrita">Agent</span>  y pulsando <span class="negrita">Clear</span> 
   y <span class="negrita">Bake</span>  de nuevo.</p>

   <figure><img src="UD9/images/ud9-2024-03-11-10-41-12.png" /><br><figcaption></figcaption></figure>
   <br>
   

  <p>Como la esfera no es un elemento del escenario se le debe añadir el componente <span class="negrita">NavMeshObstacle</span> .</p>
     
  <p>El componente <span class="negrita">NavMeshObstacle</span>  se suele utilizar para los GameObject que pueden moverse por la escena.</p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-41-42.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-41-55.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>El componente <span class="negrita">NavMeshObstacle</span>  se utiliza para personajes que se mueven por la escena y 
    para GameObjects que al moverse pueden afectar a la superficie de navegación.</p>
  
  <p>Los enemigos tendrán el componente <span class="cursiva">NavMeshObstacle</span>  y no deben afectar a la superficie de navegación.</p>
  
  <p>GameObjects como piedras que pueden caer y entorpecer el paso o puertas 
    que pueden cerrarse sí que deben afectar a la superficie de navegación.</p>
  
  <p>Para configurar un <span class="negrita">NavMeshObstacle</span>  y que afecte a la superficie debe marcarse la opción <span class="negrita">Carve</span>, 
    si se quiere que solo afecte a la superficie cuando el GameObject se queda estático (por ejemplo una piedra grande que cae) 
    se debe desmarcar la opción <span class="negrita">Carve Only Stationary</span>.</p>

    <figure><img src="UD9/images/ud9-2024-03-11-10-42-37.png" /><br><figcaption></figcaption></figure>
    <br>
    
  <p>En el ejemplo, hay un cubo con el componente NavMeshObstacle y la opción Carve activada.</p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-42-56.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-43-06.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-43-22.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>En la navegación se pueden crear <span class="negrita">enlaces</span>.</p>
  <p>Existen dos tipos de enlaces:
    <ul>
      <li><span class="negrita">NavMeshLink</span> : permite unir zonas de navegación de la misma superficie, por ejemplo, para permitir que el jugador baje un escalón más grande del permitido.</li>
      <li><span class="negrita">OffMeshLink</span> : permite unir dos zonas de navegación separadas físicamente.</li>
    </ul>
  </p>
  <p>Los enlaces pueden ser unidireccionales o bidireccionales.</p>
  
  <h3>NavMeshLink</h3>
  <p>Un NavMeshLink tiene dos puntos y una superficie visible entre los dos puntos.</p>
  <p>Si por ejemplo, se quiere que el personaje pueda bajar el escalón pero no pueda subirlo se debe desmarcar la opción <span class="negrita">Bidireccional</span> .</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-43-51.png" /><br><figcaption></figcaption></figure>
<br>

  <h3>OffMeshLink</h3>
  <p>Un OffMeshLink necesita dos GameObjects como referencia para la navegación.</p>
  
  <p>En este punto solo falta asignar al GameObject que se debe mover (cápsula) el siguiente script.</p>
  <p>Se debe añadir la librería en la parte superior del script.</p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-44-24.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD9/images/ud9-2024-03-11-10-44-32.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>A partir del script anterior se puede conseguir que un GameObject realice una ruta:
    <ul>
      <li>En la escena se deben crear GameObjects vacíos con un collider tipo trigger y situarlos donde se quiera.</li>
      <li>En el script se debe declarar un array de objetivos.</li>
      <li>En el método Start se indica que el primer objetivo sea la posición cero del array.</li>
      <li>En el método Update se comprueba si se ha alcanzado el objetivo.</li>
      <li>Si se ha alcanzado se actualiza el objetivo a la siguiente posición del array.</li>
      <li>Si la siguiente posición del array es igual a longitud del array se actualiza el objetivo a la posición cero del array.</li>
      <li>En el inspector se deben añadir todos los GameObject vacíos al script en el orden que se quiere que tenga la ruta de movimiento.</li>
    </ul>
  </p>
  
  <p>Si se quiere que el enemigo que realiza la ruta persiga al jugador se deben añadir los siguientes elementos:
    <ul>
      <li>En el script se debe declarar un Transform para el jugador.  </li>
      <li>Se debe añadir al funcionalidad de que se cree un Raycast desde el enemigo en la dirección en la que camina y con una longitud (se puede simular la vista humana haciendo que el Raycast gire algunos grados a cada lado).</li>
      <li>Si el Raycast impacta en el jugador se guarda el objetivo actual en una variable y se cambia el objetivo por el transform del jugador.</li>
      <li>Si el Raycast deja de impactar en el jugador (el jugador se aleja más que la longitud del rayop) se actualiza el objetivo por el objetivo guardado en el paso anterior (se puede mejorar actualizando el objetivo por el punto más cercano actual de la ruta del enemigo).</li>
    </ul>
  </p>
  
<p>Si se quiere implementar que el personaje del jugador vaya al punto de la pantalla donde se realice clic, se puede utilizar el siguiente script:</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-45-08.png" /><br><figcaption></figcaption></figure>
<br>

  
  </section><!-- End section sNPCs-->

  <!--*********************************************************Cambio de escenas***********************************************************-->
  <section class="apartado">
  <a name="sCambiodeescenas"></a>
  <h2>Cambio de escenas</h2>
<p>En un videojuego es habitual que haya más de una escena, principalmente porque cada nivel del juego suele ser una escena diferente.</p>

<p>Además, en los juegos también suele haber un menú inicial y un menú de opciones, que también son escenas.</p>

<p>Para poder cambiar a una escena, esta debe añadirse en las preferencias del build del juego.</p>

<p>Los cambios entre escenas se pueden realizar en diferentes momentos:
<ul>
  <li>Al pulsar el botón Jugar en el menú principal.</li>
  <li>Al superar un nivel.</li>
  <li>Dentro de un nivel al entrar a una zona nueva.</li>
  <li>...</li>
</ul>
</p>

<p>El primer paso es añadir todas las escenas a las preferencias del build del juego: 
  <span class="negrita">File</span> &rarr; <span class="negrita">Build Settings…</span>.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-45-40.png" /><br><figcaption></figcaption></figure>
<br>

<p>Pulsando el botón <span class="negrita">Add Open Scenes</span>  se añadirá la escena abierta.</p>

<p>Para añadir el resto de escenas se deben arrastrar desde el gestor de archivos.</p>

<p>La escena que esté en primera posición (0) será la que se cargue cuando se ejecute el juego (tras compilarlo y generar el ejecutable).</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-46-03.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para realizar el cambio de escena desde un script, en el script se debe añadir la librería en la parte superior del script.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-46-23.png" /><br><figcaption></figcaption></figure>
<br>

<p>La instrucción para cambiar de escena es la siguiente:</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-46-31.png" /><br><figcaption></figcaption></figure>
<br>

<p>También se puede indicar el identificador de la escena (Build settings):</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-46-41.png" /><br><figcaption></figcaption></figure>
<br>

<p>Al realizar un cambio de escena se puede indicar a los GameObjects que no se destruyan y se mantengan en la escena nueva.</p>

<p>Esto permite pasar datos entre escenas y ahorrar tiempo al estar ya los GameObjects cargados en memoria.</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-46-55.png" /><br><figcaption></figcaption></figure>
<br>


  </section><!-- End section Cambio de escenas-->


  <!--*********************************************************PlayerPrefs***********************************************************-->
  <section class="apartado">
  <a name="sPlayerPrefs"></a>
  <h2>PlayerPrefs</h2>
  <p>Las <span class="negrita">PlayerPrefs</span>  permiten almacenar información en el ordenador donde se ejecute el juego.</p>
  

<p>Con las PlayerPrefs se suelen guardar:
<ul>
  <li>El nombre del jugador.</li>
  <li>Puntuaciones.</li>
  <li>Vidas.</li>
  <li>Opciones de juego como la resolución o teclas definidas por el usuario.</li>
  <li>Último nivel (escena) jugado.</li>
<li>…</li>
</ul>
</p>

<p><span class="negrita">PlayerPrefs</span>  ofrece varios métodos para almacenar/recuperar información según el tipo de dato:
  <ul>
    <li>SetFloat</li>
    <li>SetInt</li>
    <li>SetString</li>
  </ul>
  <figure><img src="UD9/images/ud9-2024-03-11-10-47-30.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <ul>
    <li>GetFloat</li>
    <li>GetInt</li>
    <li>GetString</li>
  </ul>
  <figure><img src="UD9/images/ud9-2024-03-11-10-47-40.png" /><br><figcaption></figcaption></figure>
  <br>
  
</p>

<p>Los métodos <span class="negrita">Get</span> pueden tener uno o dos parámetros, 
  el segundo será el valor por defecto para el caso en el que no exista la preferencia.</p>
  

<p>Para comprobar si una preferencia existe se usa el método <span class="negrita">HasKey</span> :</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-48-02.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para eliminar una preferencia se utiliza el método <span class="negrita">DeleteKey</span> :</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-48-11.png" /><br><figcaption></figcaption></figure>
<br>

<p>Para eliminar todas las preferencias se utiliza el método <span class="negrita">DeleteAll</span> :</p>
<figure><img src="UD9/images/ud9-2024-03-11-10-48-18.png" /><br><figcaption></figcaption></figure>
<br>

  
  </section><!-- End section PlayerPrefs-->

  <!--*********************************************************Menús***********************************************************-->
  <section class="apartado">
  <a name="sMenus"></a>
  <h2>Menús</h2>
  
  <p>Para crear menús hay dos opciones:
    <ul>
      <li>
        Menú <span class="negrita">principal</span>  (cuando no existe ningún nivel cargado): <br>
        Suele crearse en una escena propia utilizando elementos de UI.
      </li>
      <li>Menú <span class="negrita">ingame</span>:<br>
        Puede crearse igual que el menú principal, 
        pero al cambiar de escena entre el nivel actual y el menú se deberá almacenar toda la situación actual.</li>
    </ul>
    </p>
  
<p>Se puede crear dentro de la escena del nivel creando una cámara secundaria con los elementos de la UI. 
  Esta cámara estará lejos de los elementos del nivel. 
  Al acceder al menú se pondrán en pausa todos los elementos de la escena y 
  se cambiará la cámara activa para que sea la que tiene asociado el menú.</p>

  <p>Aunque se puede crear un menú con GameObjects como si fuera una escena del juego, 
    lo más habitual es utilizar GameObjects de UI (Interfaz de Usuario).</p>
    <figure><img src="UD9/images/ud9-2024-03-11-10-48-49.png" /><br><figcaption></figcaption></figure>
    <br>
    
  <p>El manejo de eventos en GameObjects de UI es diferente al del resto de GameObjects, 
    a continuación, se estudiarán los pasos a seguir para interactuar con ellos.</p>
  
    <p>Cada tipo de GameObject de UI dispone de unos eventos que se pueden consultar en el inspector.</p>
    <figure><img src="UD9/images/ud9-2024-03-11-10-49-25.png" /><br><figcaption></figcaption></figure>
    <br>
    
  <p>Estos eventos se deben enlazar con un método en un script de Unity.</p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-49-52.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Tras crear el script y añadir los métodos necesarios, que pueden tener el nombre que se quiera, 
    se debe añadir ese script al GameObject Canvas para poder seleccionar sus métodos posteriormente desde el inspector de los GameObject de UI.</p>
  
  <p>Una vez añadido el script al <span class="negrita">Canvas</span>, 
    para seleccionar un método desde un GameObject de UI se debe seleccionar el GameObject de UI y
    en el inspector realizar las siguientes acciones:
  <ul>
    <li>Pulsar <span class="negrita">+</span> en el evento que se quiera.</li>
    <li>En el bloque que aparece, arrastrar el GameObject Canvas desde la jerarquía.</li>
    <li>Seleccionar el método que se quiere que se ejecute al ejecutarse el evento.</li>
  </ul></p>
  <figure><img src="UD9/images/ud9-2024-03-11-10-50-22.png" /><br><figcaption></figcaption></figure>
  <br>
  
    

<p>De esta manera se enlaza el método con el evento en el GameObject de UI.</p>

<figure><img src="UD9/images/ud9-2024-03-11-10-51-21.png" /><br><figcaption></figcaption></figure>
<br>


  </section><!-- End section Menús-->

  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>