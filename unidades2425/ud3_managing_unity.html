<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UD3.- Managing Unity</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../styles/prism.css">
  <link rel="stylesheet" href="../styles/styles.css">
  <script src="../script/script.js"></script>
</head>

<body class="line-numbers">
  <div class="logos"></div>

  <nav id="menu-lateral" class="main-menu-lateral oculto">    
      
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Handling Unity">1.- Handling Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Adding GameObjects to the Scene">2.- Adding GameObjects to the Scene</a>
      <a href="#sMateriales" title="3.- Materials">3.- Materials</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- GameObject Components">4.- GameObject Components</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- The GameObject Class">7.- The GameObject Class</a>
      <a href="#sEl_componente_Transform" title="8.- The Transform Component">8.- The Transform Component</a>
      <a href="#sLa_clase_Input" title="9.- The Input Class">9.- The Input Class</a>
    </div>
    <div class="fila">
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="10.- Kinematic and Physical Movement">10.- Kinematic and Physical Movement</a>
      <a href="#sColisiones" title="11.- Collisions">11.- Collisions</a>
      <a href="#sMetodos_Intersantes" title="12.- Interesting Methods">12.- Interesting Methods</a>
    </div>
    <div class="fila">      
      <a href="#sComponenteCharacterController" title="13.- CharacterController Component">13.- CharacterController Component</a>
      <a href="#sCamaraprofesional" title="14.- Professional Camera">14.- Professional Camera</a>
      <a href="#sMovimientoProgramado" title="15.- Programmed Movement">15.- Programmed Movement</a>
    </div>
    
    <div class="fila">      
      <a href="#sRaycast" title="16.- Raycast">16.- Raycast</a>
      <a href="#sNPCs" title="17.- NPCs">17.- NPCs</a>
      <a href="#sCambiodeescenas" title="18.- Scene Switching">18.- Scene Switching</a>
    </div>
    <div class="fila">      
      <a href="#sPlayerPrefs" title="19.- PlayerPrefs">19.- PlayerPrefs</a>
      <a href="#sMenus" title="20.- Menus">20.- Menus</a>
      <a href="" class="oculto"></a>
    </div>
    
  </nav> <!-- BTM_MENU-->
  
  <h1>UD3.- Managing Unity</h1> 

  
  <div class="main-menu">  
    
    <div class="fila">      
      <a href="#sManejo_de_Unity" title="1.- Handling Unity">1.- Handling Unity</a>
      <a href="#sAgregando_GameObjects_a_la_escena" title="2.- Adding GameObjects to the Scene">2.- Adding GameObjects to the Scene</a>
      <a href="#sMateriales" title="3.- Materials">3.- Materials</a>
    </div>
    <div class="fila">      
      <a href="#sComponentes_de_GameObject" title="4.- GameObject Components">4.- GameObject Components</a>
      <a href="#sUI" title="5.- UI">5.- UI</a>
      <a href="#sPrefabs" title="6.- Prefabs">6.- Prefabs</a>
    </div>
    <div class="fila">      
      <a href="#sLa_Clase_GameObject" title="7.- The GameObject Class">7.- The GameObject Class</a>
      <a href="#sEl_componente_Transform" title="8.- The Transform Component">8.- The Transform Component</a>
      <a href="#sLa_clase_Input" title="9.- The Input Class">9.- The Input Class</a>
    </div>
    <div class="fila">
      <a href="#sMovimiento_cinematico_y_movimiento_fisico" title="10.- Kinematic and Physical Movement">10.- Kinematic and Physical Movement</a>
      <a href="#sColisiones" title="11.- Collisions">11.- Collisions</a>
      <a href="#sMetodos_Intersantes" title="12.- Interesting Methods">12.- Interesting Methods</a>
    </div>
    <div class="fila">      
      <a href="#sComponenteCharacterController" title="13.- CharacterController Component">13.- CharacterController Component</a>
      <a href="#sCamaraprofesional" title="14.- Professional Camera">14.- Professional Camera</a>
      <a href="#sMovimientoProgramado" title="15.- Programmed Movement">15.- Programmed Movement</a>
    </div>
    
    <div class="fila">      
      <a href="#sRaycast" title="16.- Raycast">16.- Raycast</a>
      <a href="#sNPCs" title="17.- NPCs">17.- NPCs</a>
      <a href="#sCambiodeescenas" title="18.- Scene Switching">18.- Scene Switching</a>
    </div>
    <div class="fila">      
      <a href="#sPlayerPrefs" title="19.- PlayerPrefs">19.- PlayerPrefs</a>
      <a href="#sMenus" title="20.- Menus">20.- Menus</a>
      <a href="" class="relleno"></a>
    </div>

  </div>


  <section class="apartado">
    <a name="sManejo_de_Unity"></a>
    <h2>Handling Unity</h2>
    <p>It is very important to learn how Unity's Scene View window works to correctly work with GameObjects.</p>
    
    <p>The Scene View window is where you can see the objects that are part of the scene.</p>
    
    <p>In this window, gizmos often appear. A gizmo is a graphic that helps the developer by providing information about the GameObject within the scene.</p>
    
    <p>For example, if you select the light in the scene, you will see a gizmo indicating the direction of the light.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-11-22-45.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>The coordinate system is what allows all GameObjects to be positioned in the scene.</p>
    
    <p>Each GameObject will have coordinates that indicate its position.</p>
    
    <p>Unity uses a <span class="negrita">Y-Up</span> coordinate system:
      <ul>
        <li><span class="negrita">x</span>: horizontal axis</li>
        <li><span class="negrita">y</span>: vertical axis</li>
        <li><span class="negrita">z</span>: depth axis</li>
      </ul>
    </p>
    <figure><img src="UD2/images/ud2-2024-01-25-11-59-29.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Each game engine and 3D editor uses a different coordinate system.</p>
    
    <p>Unity uses the Y-Up system.</p>
    
    <p>Unreal and Blender use the Z-Up system where the vertical axis is z, and the depth axis is y.</p>
    <p>In the <span class="negrita">top-right corner of the Scene View window</span>, a very useful <span class="negrita">gizmo</span> appears indicating the direction in which the scene is being viewed.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-12-00-40.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Clicking on the cones changes the view to align with that axis.</p>
    
    <p>At the bottom of this gizmo, the current view is displayed, which can indicate "Persp" or any other direction such as "Back." If you click on the central cube or the icon below it with the current view, the view changes to an isometric one.</p>
    
    <p>If you're developing a 3D game, the view will change constantly, but if you're developing a 2D game, the default view may not be correct and should be changed.</p>
    
    <p>The following tools can be found at the top of the window.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-12-01-47.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>On the left:
      <ul>
        <li>The first two options control how the "hand" tool works.</li>
        <li>The third toggles the grid display on or off.</li>
        <li>The fourth allows GameObjects to "snap" to grid points when moved.</li>
        <li>The fifth indicates the movement steps when moving a GameObject.</li>
      </ul>
    </p>
    
    <p>On the right:
      <ul>
        <li>The first indicates how the GameObjects in the scene will be viewed (solid, wireframe, etc.).</li>
        <li>The second allows you to switch between a 3D or 2D (orthographic) view.</li>
        <li>The third toggles the scene's lighting on or off.</li>
        <li>The fourth toggles sound on or off.</li>
        <li>The fifth toggles effects like sky, fog, etc.</li>
        <li>The sixth shows/hides the number of hidden GameObjects in the scene.</li>
        <li>The seventh allows camera configuration.</li>
        <li>The eighth allows gizmo visibility configuration.</li>
      </ul>
    </p>
    
    <p>In the top-left corner, the following tools are available to navigate the scene and manipulate its GameObjects:</p>
    <figure><img src="UD2/images/ud2-2024-01-25-12-09-50.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>The above tools, which allow modifying a GameObject in the scene, will display a gizmo on the selected GameObject to assist in manipulation.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-12-11-24.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>All GameObjects have a <span class="negrita">pivot point</span>, from which any changes will be applied to the object.</p>
    
    <p>The pivot point is located in the <span class="negrita">center of the GameObject</span> by default, which is why the gizmo for the above tools is drawn from the center of the selected GameObject.</p>
    
      <figure><img src="UD2/images/ud2-2024-01-25-13-50-41.png" /><br><figcaption></figcaption></figure>
      <br>
      <p>The pivot point cannot be moved.</p>
    
      <h3>Moving the Scene View Camera</h3>
    
      <p class="sub-section">With keys:</p>
      <p>
        <ul>
          <li>Arrow keys ⬅ ➡: moves the camera left and right.</li>
          <li>Arrow keys ⬆ ⬇: zooms in and out.</li>
        </ul>
      </p>
      
      
      <p class="sub-section">With mouse:</p>
      <p>
        <ul>
          <li>With the hand tool selected, click and drag: moves the camera horizontally and vertically.</li>
          <li>Middle mouse button (scroll wheel): same action as the previous line.</li>
          <li>CTRL + ALT + left-click: same action as the previous line.</li>
          <li>Right-click and hold: rotates the camera around its axis.</li>
          <li>ALT + left-click: rotates the camera around the center point of the view.</li>
        </ul>
      </p>
    
      <p>All GameObjects can be moved/aligned with the view.</p>
    
      <p>This is useful with cameras because it allows aligning the camera to the view so that when the game is run, the current view will be the one seen.</p>
      
      <figure><img src="UD2/images/ud2-2024-01-25-13-53-48.png" /><br><figcaption></figcaption></figure>
      <br>
      
      <p>As mentioned earlier, if you're developing a 2D game, it's useful to change the scene view so that it matches the game view, where the z-axis is horizontal, and the y-axis is vertical.</p>
      <figure><img src="UD2/images/ud2-2024-01-25-13-54-45.png" /><br><figcaption></figcaption></figure>
      <br>
      
  </section><!-- End section Manejo de Unity-->
  
  
  <section class="apartado">
    <a name="sAgregando_GameObjects_a_la_escena"></a>
    <h2>Adding GameObjects to the Scene</h2>
    
    <p>To add GameObjects to the scene, you can right-click on the scene element area (hierarchy) or select the option from the GameObject menu.</p>
    
    <p>The menu option also provides actions to perform on a GameObject if it is selected.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-13-56-44.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Depending on the type of project, different types of GameObjects will be available to add to the scene (packages can be added from the Package Manager to expand the catalog).</p>
    
    <p>Empty GameObjects can be added, which serve to group other GameObjects, helping to keep the hierarchy organized.</p>
    
    <p>There are also 3D objects, which will be the first ones used in class.</p>
    
    <figure><img src="UD2/images/ud2-2024-01-25-13-58-59.png" /><br><figcaption>3D Project</figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-01-25-13-59-21.png" /><br><figcaption>3D Project with 2D Sprite Package</figcaption></figure>
    <br>
    <p>When adding a GameObject to the scene, you can rename it in the hierarchy (later, you can rename it by right-clicking on it in the hierarchy).</p>
    
    <p>Additionally, when adding the GameObject, it is positioned at the center of the scene, regardless of the coordinates.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-00-24.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>When selecting the GameObject in the inspector, you can see its components, including <span class="r-word">Transform</span>, which indicates the values for <span class="negrita">position, rotation, and scale</span>.</p>
    
    <p>GameObjects are added to the hierarchy as children of the scene.</p>
    
    <p>In the hierarchy, you can organize GameObjects within each other by dragging them onto the one that should contain them or dragging them out of the one that contains them.</p>
    
    <p>If you right-click on an object in the hierarchy and add a GameObject, it will be added directly as a child of the selected one.</p> 
    <figure><img src="UD2/images/ud2-2024-01-25-14-01-59.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <section class="marco-t warn">
      <span class="icono warning"> </span>All modifications made to a GameObject affect all GameObjects contained within it in the hierarchy.
    </section>
    <section class="marco-b">
        
    </section>
    
    <h3>GameObject Pivot Point</h3>
    <p><span class="negrita">All GameObjects have a pivot point located at their center.</span></p>
    
    <p>The coordinates of this pivot point in the scene are what Unity uses to perform all necessary calculations.</p>
    
    <p>The pivot point <span class="negrita">cannot be moved</span>.</p>
    
    <p>The pivot point is also the reference when one GameObject follows another, for example, a camera following a character. In this case, the camera will track the pivot point of the GameObject.</p>
    
    <p>If you want a different tracking center, you can create an empty GameObject, add it to the main GameObject at the desired coordinates, and then set the camera to follow the empty GameObject.</p>
    
    <h3>Modifying GameObjects</h3>
    <p>To modify a GameObject, you must select it either by clicking on it in the hierarchy or by clicking on it in the scene view.</p>
    
    <p>If you double-click a GameObject in the hierarchy, it will not only select the GameObject, but the view will also focus on it.</p>
    
    <p>If you click on a GameObject in the scene view, it will both select the GameObject and center the view where you clicked.</p>
    
    <p><span class="negrita">All modifications made to a GameObject use the pivot point as the reference.</span></p>
    
    <p>There are several ways to modify a GameObject in the scene:</p>
    
    <p class="sub-section">Manually changing its values in the inspector</p>
    
    <figure><img src="UD2/images/ud2-2024-01-25-14-06-47.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>You can set the GameObject to be positioned at the origin coordinates (0,0,0).</p>
    
    <figure><img src="UD2/images/ud2-2024-01-25-14-07-26.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>This action can be problematic because the pivot point is centered by default. So when moved to (0,0,0), the GameObject might appear as in the image below, where half of it is below the point (0,0,0).</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-07-47.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p class="sub-section">Using the inspector by hovering over one of the coordinates</p>
    <p>The cursor will change, and you can click and drag to change the value.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-08-44.png" /><br><figcaption></figcaption></figure>
    <br>
    <p class="sub-section">With the tools mentioned earlier</p>
    <p>You can modify a GameObject using the mouse.</p>
    
    <p>When selected, a gizmo appears, and interacting with it using the mouse allows you to perform the required actions.</p>
    
    <p>Each gizmo works differently.</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-09-56.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Movement only along the X-axis</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-10-56.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Movement along non-Y axes (X, Z plane):</p>
    <figure><img src="UD2/images/ud2-2024-01-25-14-10-43.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>When using tools with gizmos, you can use <span class="negrita">snaps</span>.</p>
    
    <p>The default step sizes or snaps can be changed:</p>
    <figure><img src="UD2/images/ud2-2024-01-26-09-28-26.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>To apply snap modifications while using gizmos, hold down the control key.</p>
    
    <p>All modifications use the pivot point as the reference.</p>
    
    <p>You can make modifications by snapping the reference point to a vertex on the GameObject’s mesh. To do this, press the V key after selecting the tool.</p>
    
    <p>When pressing the V key, you’ll see the gizmo move to the closest vertex as you hover over the GameObject with the mouse.</p>
    
    <p>This action is known as vertex snap and allows you to align GameObjects by matching one of their vertices to a vertex of another GameObject.</p>
    
    <figure><img src="UD2/images/ud2-2024-01-26-09-29-17.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <h3>Units of Measurement</h3>
    <p>By default, the units of measurement used in Unity are:
      <ul>
        <li><span class="negrita">Distances</span>: meters.</li>
        <li><span class="negrita">Sizes</span>: meters.</li>
        <li><span class="negrita">Weight (mass)</span>: kilograms.</li>
        <li><span class="negrita">Time</span>: seconds.</li>
      </ul>
    </p>
    
    <p>It's important to keep this in mind, as the behavior of GameObjects with physics depends on their size and weight.</p>
    
  </section><!-- End section Agregando GameObjects -->
  
  <section class="apartado">
    <a name="sMateriales"></a>
    <h2>Materials</h2>
    <p><span class="negrita">Materials</span> allow you to give appearance to the GameObjects.</p>
    
    <p>To create a material, right-click in the file manager and select <span class="negrita">Create &rarr; Material</span>. When created, you will be able to assign it a name.</p>
    <figure><img src="UD2/images/ud2-2024-01-26-09-32-28.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>It is important to remember that to maintain file organization, materials should be placed in a folder named <span class="inline-folder">Materials</span> inside the <span class="inline-folder">Assets</span> folder.</p>
    
    <p>A material in the file manager is represented by a sphere, and depending on the settings applied in the inspector, it will have a different appearance.</p>
       
    <figure><img src="UD2/images/ud2-2024-01-26-09-33-59.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>With good configuration, you can achieve a realistic material.</p>
    
    <p>Materials can also be obtained from the Unity Asset Store and from repositories on the internet.</p>
    <figure><img src="UD2/images/ud2-2024-01-26-09-53-50.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>You can apply a material to a GameObject in several ways:
      <ul>
        <li>Drag the material onto the GameObject in the hierarchy.</li>
        <li>Drag the material onto the GameObject in the scene view.</li>  
        <li>Drag the material onto the GameObject in the inspector in the "Add Component" area.</li>
      </ul>
    </p>
    
    <figure><img src="UD2/images/ud2-2024-01-26-09-54-59.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <h3>Physical Materials</h3>
    <p>Physical materials (Physic Material) allow control over how GameObjects physically interact when they collide with each other.</p>
    
    <p>They are commonly used to make GameObjects bounce or to create friction between them.</p>
    
    <p>To create a physical material, right-click in the file manager and choose the option <span class="negrita">Create &rarr; Physic Material</span>.</p>
    
    <p>Upon creation, you will need to give it a name.</p>
    <figure><img src="UD2/images/ud2-2024-01-26-10-05-23.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>The parameters that can be configured in a physical material are:</p>
    <figure><img src="UD2/images/ud2-2024-01-26-10-05-53.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>You can apply a physical material to a GameObject in several ways:
      <ul>
        <li>Drag the material onto the GameObject in the hierarchy.</li>
        <li>Drag the material onto the GameObject in the scene view.</li>
        <li>Drag the material onto the GameObject in the inspector in the "Add Component" area.</li>
      </ul>
    </p>
    
    <figure><img src="UD2/images/ud2-2024-01-26-10-06-48.png" /><br><figcaption></figcaption></figure>
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Activity 3: Building the Scene</span> <br>
        Create a 3D project in Unity called <span class="subrayado">SceneYourName</span>. <br>
        Set the view camera as if developing a 2D game (Z-axis pointing backwards). <br>
        Add a plane to the scene and modify its size so that it is shallow but very wide (like a horizontal platform from left to right). <br>
        Add a cube, a sphere, a capsule, and a cylinder to the scene. Arrange them in the scene as you wish, but they should all be on the same Z coordinate as the plane. <br>
        Only one object should touch the surface of the plane. <br>
        Of the GameObjects not touching the plane’s surface, position one at the same Z coordinate as the one touching the surface, but with a slightly shifted X coordinate (still above the other), and the Y coordinate should be higher, at the top of the scene. <br>
        Create 5 materials with different colors and appearances, and assign each one to a GameObject. <br>
    
        Set the view to a different angle than the camera’s perspective—you can rotate and move it, but both the plane and all objects must appear in the view.
        <span class="oculto">Take a screenshot of the scene view and name it YourNameUnity1.png</span>
        <span class="oculto">Take a screenshot of the game view when the game is running, name it YourNameUnity2.png. Compress the two screenshots into a rar or zip file named YourName and attach the compressed file to the assignment.</span>
      </p>
    </div>
    
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Activity 4: MonoBehaviour Events</span> <br>
        Open the SceneYourName project. <br>
        Create a script called EventsScript and attach it to the GameObject that is touching the surface. <br>
        In the script, add instructions to display console messages with Debug.Log for the following events: Start, Update, OnMouseEnter (when the mouse is over the GameObject), and OnMouseDrag (when the GameObject is clicked and dragged with the mouse). <br>
        The messages should follow this format: "YourName (EventName): YourMessage". <br>
        <span class="oculto">
        Click on the script in the file manager so the code appears in the inspector, then run the game and take a screenshot showing both the console and the inspector (remember to activate the Collapse option in the console). 
        Name the screenshot YourNameUnity3.png. <br>
        Compress the screenshot into a rar or zip file named YourName and attach it to the assignment.</span>
      </p>
    </div>
    
    <br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Activity 5: Gravity</span> <br>
        Open the SceneYourName project. <br>
        One of the GameObjects is vertically aligned with the one that was touching the surface. Add a RigidBody component to the object at the top of the scene. <br>
        Run the game and observe what happens. <br>
        Change the weight of that GameObject and run the game again to observe the changes. <br>
        Change other RigidBody settings and run the game to see what happens. <br>
        <div class="oculto">Take a screenshot of the game window before the cube falls, and name it YourNameUnity4.png. <br>
          Take a screenshot of the game window when the cube hits the object below it, and name it YourNameUnity5.png. <br>
          Take a screenshot of the game window when the cube stops moving, and name it YourNameUnity6.png. <br>
          Compress the screenshots into a rar or zip file named YourName and attach them to the assignment.</div>
      </p>
    </div>
    
  </section><!-- End section Materials -->
  
  
  <!--*********************************************************GameObject Components***********************************************************-->
<section class="apartado">
  <a name="sComponentes_de_GameObject"></a>
  <h2>GameObject Components</h2>
  <p>GameObjects can contain different components.</p>
  
  <p>At a minimum, all GameObjects have the Transform component, which is used to indicate the position, rotation, and size of the GameObject.</p>
  
  <p>Geometric GameObjects also have a Mesh and a Mesh Renderer to allow them to be drawn.</p>
  
  <p>GameObjects that are visible in the cameras have a Collider to detect collisions.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-26-10-00-53.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Other components can be added to GameObjects from the <span class="negrita">Menu &rarr; GameObject</span> or from the inspector using the "<span class="negrita">Add Component</span>" button at the bottom.</p>
  
  <p>Using the "Add Component" button opens a search bar where you can type the component you're looking for.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-02-02.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>When developing a video game, it is often necessary for some GameObjects to be <span class="negrita">affected by physics</span> (gravity, forces, etc.), for which they need to have a component called <span class="r-word">RigidBody</span>.</p>
  
  <p>In the configuration of <span class="r-word">RigidBody</span>, the weight of the GameObject in the scene is specified, along with other parameters.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-03-05.png" /><br><figcaption></figcaption></figure>
  <br>
</section><!-- End section GameObject Components-->

<!--*********************************************************UI (User Interface)***********************************************************-->
<section class="apartado">
  <a name="sUI"></a>
  <h2>UI (User Interface)</h2>
  <p>The user interface (UI) consists of elements added to the scene to provide information to the user.</p>
  
  <p>The user interface can be used to create menus and the HUD (Head-Up Display).</p>
  
  <p>The user interface can be created with either 2D or 3D GameObjects, but 2D GameObjects are commonly used.</p>
  
  <p>The user interface can include GameObjects such as text, images, sliders, scrollbars, buttons, or text fields.</p>
  
  <p>UI GameObjects must be children of a <span class="negrita">Canvas</span> GameObject.</p>
  
  <p>When a UI GameObject is added to the scene, if there is no <span class="negrita">Canvas</span> in the scene, one will be created to contain the UI GameObject.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-26-10-09-35.png" /><br><figcaption></figcaption></figure>

  <h3>UI - Text</h3>
  <p>There are two GameObjects for adding text to the scene:
    <ul>
      <li><span class="negrita">Text</span>: basic text with limited configuration options.</li>
      <li><span class="negrita">TextMeshPro</span>: advanced text with many configuration options.</li>
    </ul>
  </p>
  
  <p>There are other MeshPro GameObjects that enhance the primitive types.</p>
  
  <p>It is recommended to use MeshPro whenever available.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-11-13.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>When adding a <span class="negrita">TextMeshPro</span> for the first time to the project, a window will appear indicating that the necessary packages must be imported. Click on the "<span class="cursiva">Import TMP Essentials</span>" button.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-12-31.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>It also indicates that example and extra packages can be imported.</p>
  
  <p>To correctly display Canvas elements on the screen, some configuration changes must be made in the inspector.</p>
  
  <p>Select "<span class="negrita">Render Mode</span>" as "<span class="negrita">Screen Space - Camera</span>" and then drag the camera from the hierarchy to the "<span class="negrita">Render Camera</span>" box.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-14-41.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-26-10-15-02.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>UI - Images</h3>
  <p>To add images to the user interface, the images must be <span class="d-word">sprites</span>.</p>
  
  <p>Sprites are bitmap images that contain a minimal unit of information, such as a button image or a character image.</p>
  
  <p>An image may contain one or more sprites.</p>
  
  <p>Each sprite can be added to the scene directly as an independent GameObject.</p>
  
  <p>If an image contains multiple sprites, it optimizes image loading in the game.</p>
  
  <p>Sprites can be used to form a complete character and animate each sprite independently.</p>
  
  <p>They can also be used to create the animation of a character or object by changing the sprite of a GameObject as it moves.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-26-10-28-46.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>An image with multiple sprites is also useful for containing different world or UI elements.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-29-31.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>The first step to adding sprites to the Unity project is to add the 2D Sprite package from the <span class="negrita">Menu &rarr; Window &rarr; Package Manager</span>.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-30-33.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>This installs the <span class="negrita">Unity Sprite Editor</span> tool.</p>
  
  <p>The next step is to drag the images into the file manager into a folder called <span class="inline-folder">Sprites</span>.</p>
  
  <p>By selecting an image from the file manager, you can indicate its texture type in the inspector. To convert it into a sprite, select the <span class="negrita">Sprite (2D and UI)</span> option.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-26-10-31-40.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>By doing this, the <span class="negrita">Sprite Editor</span> button will become available. Clicking it will open the editor, allowing you to create the sprite from the image.</p>
  
  <p>If the image contains only one sprite, with the default "<span class="cursiva">Single</span>" mode selected, opening the editor will automatically convert the image into a sprite.</p>
  
  <p>Once an image is converted into a sprite, a small arrow will appear on it in the file manager.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-32-54.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>The sprite editor allows you to modify the sprite.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-33-21.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>If an image contains multiple sprites, set the <span class="negrita">Sprite Mode</span> option to <span class="negrita">Multiple</span> in the inspector.</p>
  
  <p>It's important that the background of the image is transparent for better results with the sprites.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-34-18.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>This way, the sprite editor allows multiple sprites to be created from the image.</p>
  
  <p>In the sprite editor, you can manually select the different sprites with the mouse. Once a sprite is selected, you need to name it for future reference:</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-35-15.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Once a sprite is created, the <span class="negrita">Trim</span> option adjusts the sprite to fit the content of the image (the background should be transparent).</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-35-48.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can change the way the sprite is selected if you want to better fit the image.</p>
  
  <p>With <span class="negrita">Outline Tolerance</span>, the outline can be adjusted to the image. <span class="negrita">Generate</span> creates the outline, and <span class="negrita">Apply</span> finalizes the sprite with that outline.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-37-14.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>If the sprites are organized in the image in an orderly manner, in the editor's <span class="negrita">Slice</span> dropdown, you can select how the image will be divided so the editor can automatically create the sprites:</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-37-42.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p><ul>
    <li><span class="negrita">Automatic</span>: The editor detects the sprites based on the content.</li>
    <li><span class="negrita">Grid By Cell Size</span>: The sprites in the image are organized in a grid, and this option requires specifying the size of each cell in the grid.</li>
    <li><span class="negrita">Grid By Cell Count</span>: The sprites in the image are organized in a grid, and this option requires specifying the number of rows and columns.</li>
  </ul></p>
  
  <p>After selecting the desired option, click the Slice button to generate all the sprites.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-26-10-39-10.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-26-10-39-17.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-26-10-40-12.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>If the image contains sprites for character animations, like in the example, when using the options in the <span class="negrita">Slice</span> button, you must consider the content of the image to ensure the pivot is correct for the animation to work properly.</p>
  
  <p>In most cases, the sprites are arranged in a grid, and the pivot is in the center, although this may vary between sprite sheets.</p>
  
  <p>Once the sprites are created, clicking the arrow on the image in the file manager will display all the sprites along with their names.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-41-11.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Once an image is converted into one or more sprites, you can drag one of the sprites into the hierarchy or scene view to add a GameObject displaying that sprite.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-52-04.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can also add a <span class="negrita">UI &rarr; Image</span> GameObject and assign the sprite by dragging it to the Source Image field.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-52-56.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-26-10-53-10.png" /><br><figcaption></figcaption></figure>
  <br>
</section><!-- End section UI (User Interface) -->

  
  <!--*********************************************************Prefabs***********************************************************-->
<section class="apartado">
  <a name="sPrefabs"></a>
  <h2>Prefabs</h2>
  <p>A <span class="r-word">Prefab</span> is a GameObject with all its characteristics (size, rotation, scale, material, textures, physics, etc.) stored as an asset.</p>
  
  <p>Once a GameObject is saved as a prefab, it <span class="negrita">can be instantiated from a script</span>.</p>
  
  <p>A typical example of a prefab in a game would be objects dropped by enemies when they disappear after being hit.</p>
  
  <p>Prefabs are also easy to export for use in other projects.</p>
  
  <p>To create a prefab, drag the object from the hierarchy to the file manager.</p>
  
  <p>For better organization, all prefabs should be placed in a folder called <span class="inline-folder">Prefabs</span>.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-55-31.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>In the hierarchy, it is indicated that the GameObject originates from a prefab by displaying its name in blue.</p>
  
  <p>A preview of the prefab appears in the file manager.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-56-18.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>When selecting the prefab in the inspector, you can view its characteristics and components.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-56-46.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>A GameObject in the hierarchy that comes from a prefab can be edited in the current scene without affecting the prefab itself.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-57-23.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>To edit a prefab, double-click on it in the file manager.</p>
  
  <p>Changes to the prefab will be replicated in all GameObjects in the project that were created from the prefab.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-57-56.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can add as many copies of a prefab to a scene as needed.</p>
  
  <p>From a script, you can also add GameObjects that are prefabs.</p>
  <figure><img src="UD2/images/ud2-2024-01-26-10-58-35.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <br>
  <hr>
  <br>
  <div class="tarea">
    <p><span class="subrayado negrita">Activity 6. Images and Prefabs</span> <br>
  Open the project <span class="subrayado">EscenaTuNombre</span>. <br>
  Add a Cube GameObject, create a new material for it, and assign it. <br>
  Create 5 copies of this cube and arrange them into a figure however you'd like (you can rotate and scale them). <br>
  Create an empty GameObject and add the 6 cubes that form the figure, being careful with the coordinates. <br>
  Create a Prefab from this empty GameObject. <br>
  Add text to the scene with your name. <br>
  Add a passport-style photo of yourself to the scene (current). <br>
  
  <div class="oculto">Take a screenshot of the entire Unity window during execution, showing the prefab in the file manager, and the GameObjects in the scene in the scene view. Name it TuNombreUnity7.png. <br>
    Compress the screenshot into a rar or zip file named TuNombre and attach the compressed file to the assignment.</div>
  </p>
    
  </div>
</section><!-- End section Prefabs-->

<!--*********************************************************The GameObject Class***********************************************************-->
<section class="apartado">
  <a name="sLa_Clase_GameObject"></a>
  <h2>The GameObject Class</h2>
  <h3>Accessing GameObject Properties</h3>
  <p>From a script added to a GameObject, you can access the properties of the GameObject itself and all the components added to it.</p>
  
  <p>To access this information, you use the <span class="r-word">gameObject</span> variable, which <span class="negrita">is directly injected</span> when inheriting from the <span class="r-word">MonoBehaviour</span> class.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-10-56-27.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <figure><img src="UD2/images/ud2-2024-01-29-10-56-54.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-29-10-57-11.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-29-10-57-50.png" /><br><figcaption>Changing the name property through code</figcaption></figure>
  <br>
  
  <p>All GameObjects have at least one <span class="negrita">Transform</span> component, which <span class="negrita">indicates the position, rotation, and size of the GameObject</span>.</p>
  
  <p>Since it is a component present <span class="subrayado">in all</span> GameObjects, Unity directly injects the <span class="negrita">transform property</span>, which can be used directly, or accessed through the gameObject property.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-00-07.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>To access a <span class="negrita">component other than Transform</span>, you need to create a property to store that component using the <span class="negrita">GetComponent</span> method, allowing you to access it.</p>
  
  <p>For example, to access the <span class="negrita">Collider</span> component:</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-01-57.png" /><br><figcaption>Disabling the collider during execution</figcaption></figure>
  <br>
  <h3>Accessing Other GameObjects</h3>
  <p>To access other GameObjects from a script, you <span class="negrita">declare a GameObject property</span> and then <span class="negrita">assign the desired GameObject to it</span> (e.g., Sphere<span class="negrita">GO</span>  &rarr; <span class="negrita">G</span>ame<span class="negrita">O</span>bject).</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-03-58.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>There are several ways to assign the GameObject to the property:
    <ul>
      <li>If the property is <span class="negrita">public</span>, you can <span class="negrita">drag and drop</span> the GameObject from the hierarchy to the variable in the Inspector.
        <figure><img src="UD2/images/ud2-2024-01-29-11-06-10.png" /><br><figcaption></figcaption></figure>     
      </li>
      <li>From the script itself, using the <span class="negrita">Find</span> method of the <span class="negrita">GameObject</span> class to search by <span class="negrita">name</span> (in these cases, the property is usually private).
         <figure><img src="UD2/images/ud2-2024-01-29-11-07-41.png" /><br><figcaption>Searching for GameObjects with that tag and filling the array during execution</figcaption></figure>
      </li>
      <li><span class="negrita">Assign tags</span> to GameObjects and use the <span class="r-word">FindGameObjectsWithTag</span> method of the <span class="negrita">GameObject</span> class to search by <span class="negrita">tag</span>.
         <figure><img src="UD2/images/ud2-2024-01-29-11-09-22.png" /><br><figcaption></figcaption></figure>
         <br>
         <p>In this case, the variable should be declared as an array because there could be more than one GameObject with that tag (the property is usually private).</p>
         <figure><img src="UD2/images/ud2-2024-01-29-11-11-20.png" /><br><figcaption></figcaption></figure>  
         <br>    
         
         <figure><img src="UD2/images/ud2-2024-01-29-11-12-54.png" /><br><figcaption>Filling the array with GameObjects with that tag during execution</figcaption></figure>
         <br>
         
        </li>
    </ul>
  </p>
  
  <p>When accessing other GameObjects, you can access their properties. For example, the following script, added to the MainCamera, would access the <span class="negrita">Text</span> property of a GameObject of type TextMeshPro and modify its value.</p>
  
  <p>To access the GameObject, you must drag it to the appropriate slot in the Inspector after selecting the MainCamera.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-14-25.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Accessing Components of Other GameObjects</h3>
  <p>Once you have a reference to another GameObject using any of the techniques mentioned earlier, you can access the components of that GameObject using the <span class="negrita">GetComponent</span> method, just as you would access components of the current GameObject.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-15-43.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>If the property to access the component is declared as public, <span class="negrita">when you drag the GameObject</span> to the slot in the Inspector, <span class="negrita">the specified component type will be automatically assigned</span> to the property.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-16-38.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can access scripts on other GameObjects by referencing the target GameObject and specifying the <span class="negrita">script name</span>.</p>
  
  <p>You can use any of the techniques mentioned earlier to obtain the reference to the other GameObject.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-18-28.png" /><br><figcaption></figcaption></figure>
  <br>
</section><!-- End section The GameObject Class-->

  
  <!--*********************************************************The Transform Component***********************************************************-->
<section class="apartado">
  <a name="sEl_componente_Transform"></a>
  <h2>The Transform Component</h2>
  <p>The <span class="r-word">Transform</span> component is structured into three elements:
    <ul>
      <li><span class="negrita">Position</span></li>
      <li><span class="negrita">Rotation</span></li>
      <li><span class="negrita">Scale</span></li>
    </ul>
  </p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-20-46.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Each element specifies a value for each coordinate, which can be accessed as shown earlier.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-20-54.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>To modify <span class="negrita">position</span>, <span class="negrita">rotation</span>, and <span class="negrita">scale</span>, 
     you use objects of the <span class="r-word">Vector3</span> class.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-22-06.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>The code in the image represents the coordinates: x=3, y=8, z=1.</p>
  
  <p>The accepted parameters are decimal numbers (float), although integers can also be used.</p>
  
  <p>If you indicate a decimal number, you must add the letter "f" at the end:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-22-20.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Changing a GameObject's Position</h3>
  
  <p>To <span class="negrita">change the position</span> of a GameObject:
  <ul>
    <li>
      Assign <span class="negrita">a new Vector3</span> to the <span class="negrita">position</span> property of its <span class="negrita">Transform</span>:
      <figure><img src="UD2/images/ud2-2024-01-29-11-23-18.png" /><br><figcaption></figcaption></figure>
    </li>
    <li>
      Perform operations on the <span class="negrita">position</span> property of the <span class="negrita">Transform</span> using a <span class="negrita">Vector3</span>:
      <figure><img src="UD2/images/ud2-2024-01-29-11-24-03.png" /><br><figcaption></figcaption></figure>
    </li>
    <li>
      Use the <span class="r-word">Translate</span> method on the <span class="negrita">Transform</span>:
      <figure><img src="UD2/images/ud2-2024-01-29-11-24-40.png" /><br><figcaption></figcaption></figure>
      <br>
      <p>With <span class="r-word">Translate</span>, you can specify whether to use the object's own transform (default) or the world origin (0, 0, 0):</p>
      <figure><img src="UD2/images/ud2-2024-01-29-11-25-39.png" /><br><figcaption></figcaption></figure>
      <br>
      
    </li>
  </ul>
  </p>
  
  <p>Additionally, the <span class="r-word">Vector3</span> class includes some properties that return Vector3 objects aligned with the unit axes:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-26-32.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can find everything available in the documentation:
  <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Vector3.html">https://docs.unity3d.com/ScriptReference/Vector3.html</a>
  </p>
  
  <p><span class="r-word">Vector3</span> objects can also be operated on:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-27-08.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Rotating a GameObject</h3>
  <p class="sub-section">Around Its Own Axis</p>
  
  <p>Assign a <span class="negrita">new Vector3</span> to the <span class="negrita">rotation</span> property of its <span class="negrita">Transform</span>
     using the <span class="negrita">Euler</span> method of the <span class="negrita">Quaternion</span> class:</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-29-15.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Use the <span class="negrita">eulerAngles</span> property (similar behavior to the method above):</p>
  
  <figure><img src="UD2/images/ud2-2024-01-29-11-30-49.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Use the <span class="negrita">Rotate</span> method on the <span class="negrita">Transform</span>.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-30-56.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>With <span class="negrita">Rotate</span>, you can specify whether to use the object's own transform (default) or the world origin (0, 0, 0).</p>
  
  <p class="sub-section">Rotating Around Another Object</p>
  
  <p>With the <span class="r-word">RotateAround(origin, axis, speed)</span> method, you can make a GameObject rotate around another:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-32-50.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Using the <span class="r-word">LookAt(transformOtherGameObject)</span> method, you can make a GameObject always face another GameObject:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-33-16.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>These two techniques should be used within the script's Update method.</p>
  
  <h3>Scaling a GameObject</h3>
  <p>To <span class="negrita">scale</span> a GameObject, it only makes sense to scale it relative to its pivot point.</p>
  <p>For this reason, you use the <span class="r-word">localScale</span> property:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-34-06.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>The Transform Component in the Hierarchy</h3>
  <p>When GameObjects are grouped, the Transform component allows access to all the Transforms and GameObjects in the group.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-35-02.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-29-11-35-14.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>The access order of child GameObjects is the same as the order in which they appear in the hierarchy.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-38-33.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>You can also access the parent from a grouped GameObject.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-39-18.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Movement Using the Update and FixedUpdate Methods</h3>
  <p class="sub-section">Update Method</p>
  
  <p>The <span class="r-word">Update</span> method runs once per frame.</p>
  
  <p>When a modification is applied to the Transform component of a GameObject in the Update method, <span class="negrita">movement occurs</span>, for example: 
    adding 0.01 units to the x position in each Update.</p>
  
    <figure><img src="UD2/images/ud2-2024-01-29-11-40-35.png" /><br><figcaption>Moving the GameObject</figcaption></figure>
    <br>
    
    <p>The problem with using the <span class="negrita">Update</span> method is that the number of FPS generated depends on many factors, 
      from the capabilities of the computer running the game to the number of elements displayed at any given moment.</p>
    <figure><img src="UD2/images/ud2-2024-01-29-11-41-57.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>For this reason, it is not advisable to move objects directly in this way.</p>
    
    <p>There are two ways to solve this problem:
      <ul>
        <li>The <span class="r-word">Time</span> class and its <span class="r-word">deltaTime</span> method. <br>
  If you multiply a movement by <span class="negrita">Time.deltaTime</span>, the movement will be consistent regardless of the frame rate at any given time.
  <span class="negrita">Time.deltaTime</span> returns the value 0.02 (corresponding to 20 milliseconds).
  (This technique was used until the introduction of the next method).</li>
  <li>The <span class="r-word">FixedUpdate</span> method of the <span class="negrita">MonoBehaviour</span> class.
    It runs at regular intervals of 20 ms (50 times per second).</li>
      </ul>
    </p>
    
  <p>It is also common to create a float property called <span class="negrita">speed</span> to use as a multiplier to control the speed.</p>
  
  <p>Move an object along the x-axis based on the value of the <span class="negrita">speed</span> property from the <span class="negrita">Update</span> method.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-44-47.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p class="sub-section">FixedUpdate Method</p>
  <p>By default, the <span class="negrita">FixedUpdate</span> method runs every 20 ms, but this behavior can be adjusted from <span class="negrita">Menu &rarr; Edit &rarr; Project Settings</span>… under the <span class="negrita">Time</span> section.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-45-47.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Move an object along the x-axis based on the value of the <span class="negrita">speed</span> property from the <span class="r-word">FixedUpdate</span> method.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-46-19.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>Both methods, Update and FixedUpdate, can achieve the same result if multiplied by the same value.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-11-47-06.png" /><br><figcaption>speed * Time.deltaTime</figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-29-11-47-21.png" /><br><figcaption>speed</figcaption></figure>
  <br>
  <p>The advantage of FixedUpdate is that it can be configured from the project settings.</p>
  
</section><!-- End section The Transform Component-->

  
  <!--*********************************************************The Input Class***********************************************************-->
<section class="apartado">
  <a name="sLa_clase_Input"></a>
  <h2>The Input Class</h2>
  <p>With the <span class="r-word">Input</span> class, <span class="negrita">input events</span> from the user’s device (keyboard, mouse, gamepad, etc.) can be captured.</p>
  
  <p>The <span class="negrita">Input class unifies</span> all available input devices into a single point of control.</p>
  
  <p>Unity provides a tool to configure input devices.</p>
  
  <p>In many games, users are also allowed to change this configuration for a personalized experience.</p>
  
  <p>From the <span class="negrita">Menu &rarr; Edit &rarr; Project Settings…</span>, 
     the project settings open, and in the <span class="negrita">Input Manager</span> section, input devices can be viewed and configured:</p>
  <figure><img src="UD2/images/ud2-2024-01-29-19-19-18.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>The <span class="r-word">MonoBehaviour</span> class provides some methods that allow code execution when mouse events occur:
  <ul>
    <li><span class="negrita">OnMouseDown</span></li>
    <li><span class="negrita">OnMouseDrag</span></li>
    <li><span class="negrita">OnMouseEnter</span></li>
    <li><span class="negrita">OnMouseExit</span></li>
    <li><span class="negrita">OnMouseOver</span></li>
    <li><span class="negrita">OnMouseUp</span></li>
    <li><span class="negrita">OnMouseUpAsButton</span></li>
  </ul>
  </p>
  <p>The <span class="negrita">Input class</span> has a series of methods that return a boolean value when the user interacts with a <span class="negrita">key</span>, 
    <span class="negrita">mouse button</span>, or a <span class="negrita">virtual button</span> like "<span class="cursiva">Fire1</span>".</p>
  
  <p>These methods are typically used inside the script's Update method, as it runs much more frequently than other methods.</p>
  <figure><img src="UD2/images/ud2-2024-01-29-19-21-12.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>
    <ul>
      <li>Input.GetKeyDown(KeyCode.E)<br>
  Input.GetKey(KeyCode.V)<br>
  Input.GetKeyUp(KeyCode.Space)<br>
  Input.GetMouseButtonDown(0)<br>
  Input.GetMouseButton(1)<br>
  Input.GetMouseButtonUp(2)<br>
  Input.GetMouseButtonUp("Fire1")<br>
  Input.GetMouseButton("Jump")</li>
    </ul>
  </p>
  
  <p>All methods can be found in the <a class="enlace" target="_blank" href="https://docs.unity3d.com/ScriptReference/Input.html">documentation</a>.</p>
  
  <p>The <span class="negrita">Input class</span> also has methods to capture movement axis values.</p>
  
  <p>These methods return a float decimal value. When the axis is at rest, the value is 0, and when pressed, it returns a value between -1 and 1, depending on acceleration (duration of key press or joystick movement range).</p>
  <p>There are axes:
    <ul>
      <li>Horizontal and Vertical: w, a, s, d, arrows, joystick, d-pad.
        <ul>
            <li>Input.GetAxis("Horizontal")</li>
            <li>Input.GetAxis("Vertical")</li>
        </ul>
      </li>
      <li>Mouse X and Mouse Y: assigned to mouse movement.
        <ul>
  <li>Input.GetAxis("Mouse X")</li>
  <li>Input.GetAxis("Mouse Y")</li>
        </ul>
      </li>
    </ul>
  </p>
  
  
  <h3>Movement Using the Input Class</h3>
  <p>Thanks to the <span class="negrita">Input class</span>, <span class="negrita">GameObjects can be moved</span> when the user interacts with the <span class="negrita">input devices</span>.</p>
  
  <p>In the code, with the camera oriented as indicated by the gizmo:
    <ul>
      <li>up arrow or w	 &rarr;	<span class="negrita">move</span> forward (away from the camera).</li>
      <li>down arrow or s	 &rarr;	<span class="negrita">move</span> backward (toward the camera).</li>
      <li>left arrow or a &rarr;	<span class="negrita">move</span> left.</li>
      <li>right arrow or d &rarr;	<span class="negrita">move</span> right.</li>
    </ul>
  </p>
  <figure><img src="UD2/images/ud2-2024-01-31-12-50-54.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-01-31-12-51-05.png" /><br><figcaption></figcaption></figure>
  <br>
  <p><ul>
    <li>up arrow or w		&rarr;	<span class="negrita">move</span> forward.</li>
    <li>down arrow or s		&rarr;	<span class="negrita">move</span> backward.</li>
    <li>left arrow or a	&rarr;	<span class="negrita">rotate</span> left.</li>
    <li>right arrow or d	&rarr;	<span class="negrita">rotate</span> right.</li>
  </ul></p>
  
  <figure><img src="UD2/images/ud2-2024-01-31-12-55-05.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>With either of the two codes above, if the camera is positioned behind the GameObject in the same x-orientation and is added as a child of the GameObject, 
    the camera will follow the GameObject as it moves.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-31-12-55-32.png" /><br><figcaption></figcaption></figure>
  <br>
  <br>
  <hr>
  <br>
  <div class="tarea">
    <p>
      <span class="subrayado negrita">Activity 7. Modifying GameObjects via Inputs</span> <br>
  Create a 3D project in Unity called <span class="subrayado">InputsYourName</span>. <br>
  Set the camera view as if a 2D game is being developed (z-axis facing backward). <br>
  Add a plane to the scene and modify its size to be 15x15x15, positioned at coordinates (0, 0, 0). <br>
  Add a Capsule GameObject and place it at coordinates (0, 1, 0). <br>
  Add a Cube GameObject and place it at coordinates (3, 0.5, 0). <br>
  Add a Sphere GameObject and place it at coordinates (6, 0.5, 0). <br>
  Create an orange material and assign it to the Capsule GameObject. <br>
  Create a blue material and assign it to the Cube. <br>
  Create a green material and assign it to the Sphere. <br>
  Duplicate the Cube and move them across the plane (you can make about 20 copies). <br>
  Create a script for the capsule and add the necessary code to perform the following actions:
  <ul>
    <li>Pressing the Horizontal and Vertical axes should move the capsule across the plane.</li>
    <li>Pressing the E key should scale the sphere up by 0.5 on all axes.</li>
    <li>Pressing the Q key should scale the sphere down by -0.5 on all axes. Ensure that the sphere never scales smaller than 0.5.</li>
  </ul>
   <br>
  Create a script for the camera and add code to make it always face the capsule.
  
    </p>
  </div>
  
</section><!-- End section The Input Class-->

  <!--*********************************************************Kinematic and Physical Movement***********************************************************-->
<section class="apartado">
  <a name="sMovimiento_cinematico_y_movimiento_fisico"></a>
  <h2>Kinematic and Physical Movement</h2>
  <p>Types of movement in Unity:
    <ul>
      <li><span class="negrita">Kinematic</span>:
        <ul>
          <li>Movement applied directly to the GameObject's transform component.</li>
          <li>These movements are independent of the game's physics (gravity, acceleration, impulses, inertia, friction…).</li>
        </ul>
      </li>
      <li><span class="negrita">Physical</span>:
        <ul>
          <li>Movements that use the game’s physics engine.</li>
          <li>The GameObject must have the <span class="negrita">Rigidbody</span> component.</li>
        </ul>
      </li>
    </ul>
  </p>
  
  <p>When adding the <span class="r-word">Rigidbody</span> component to a GameObject, its configuration can be seen in the inspector.</p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-00-16.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Properties of <span class="negrita">Rigidbody</span>:
  <ul>
      <li><span class="negrita">Mass</span>: the object's weight in kilograms.</li>
    <li><span class="negrita">Drag</span>: resistance to linear movement.</li>
    <li><span class="negrita">Angular Drag</span>: resistance to rotations.</li>
    <li><span class="negrita">Use Gravity</span>: indicates whether it is affected by gravity.</li>
    <li><span class="negrita">Is Kinematic</span>: if enabled, the GameObject will not be affected by the physics engine.
      It is often enabled to detect collisions. (It can only be manipulated using its Transform).</li>
    <li><span class="negrita">Constraints</span>: allows locking coordinates.</li>
  </ul>
  </p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-02-08.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>With kinematic movements (without physics), when moving a GameObject, what happens is that the GameObject is <span class="negrita">teleported</span> to the new position.</p>
  
  <p>When a GameObject has the <span class="negrita">Rigidbody</span> component, it is not recommended to modify its position using its Transform, as teleporting to the new position could cause it to partially appear inside another object, causing unwanted collisions.</p>
  
  <p>To move a GameObject with a Rigidbody, <span class="negrita">forces need to be applied to push</span> the GameObject in a direction.</p>
  
  <p>If the <span class="negrita">forces are applied without interaction with Input</span>, the <span class="negrita">FixedUpdate</span> method is used.</p>
  
  <p>If the <span class="negrita">forces are applied with Input interaction</span>, the <span class="negrita">Update</span> method is used.</p>
  
  <h3>Physical Movement</h3>
  <p>Example of physical movement:</p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-29-35.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>With the above code, care must be taken with the physical materials of the GameObjects as friction can cause the GameObject not to behave as expected.</p>
  
  <p>The floor provides friction, and when pushing the GameObject, it tips forward.</p>
  
  <p>Additionally, due to friction, when applying forces, the GameObject takes some time to move, and when stopping the force, it slows down gradually.</p>
  
  <figure><img src="UD2/images/ud2-2024-01-31-13-30-46.png" /><br><figcaption></figcaption></figure>
  <br>
  <p>To solve these problems, you can choose one of the following options:
    <ul>
      <li>Create <span class="negrita">Physical Materials</span> for more realism.
        These physical materials should be properly configured and assigned to GameObjects that affect movement, such as surfaces or characters.</li>
      <li>Add <span class="negrita">Constraints</span> to the Rigidbody component to lock position and/or rotation on any of the three axes.</li>
    </ul>
  </p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-32-07.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>As mentioned, to apply forces, you need a Rigidbody property in the code.</p>
  
  <p>Some of the methods that can be used are:
    <ul>
      <li><span class="negrita">AddForce</span>: applies push forces in world coordinates.</li>
      <li><span class="negrita">AddTorque</span>: applies rotational forces in world coordinates.</li>
      <li><span class="negrita">AddRelativeForce</span>: applies push forces in local coordinates.</li>
      <li><span class="negrita">AddRelativeTorque</span>: applies rotational forces in local coordinates.</li>
      <li><span class="negrita">AddForceAtPosition</span>: applies push forces at a specific position.</li>
      <li><span class="negrita">AddExplosionForce</span>: simulates explosions.</li>
    </ul>
  </p>
  
  <p>These methods have a version that, in addition to receiving a Vector3, can also specify the type of force to apply using the following properties:
    <ul>
      <li><span class="negrita">ForceMode.Force</span>: depends on the object. Force = mass * acceleration.</li>
      <li><span class="negrita">ForceMode.Acceleration</span>: acceleration, ignoring the GameObject's mass.</li>
      <li><span class="negrita">ForceMode.Impulse</span>: applies the force instantly in one frame (used in Update).</li>
      <li><span class="negrita">ForceMode.VelocityChange</span>: directly applies a velocity.</li>
    </ul>
  </p>
  
  <p>By using only physical movements, inertia of movements can be maintained on any axis.</p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-35-11.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <h3>Combining Kinematic and Physical Movements</h3>
  <p>Although not recommended, both types of movement can be combined:
    <ul>
      <li><span class="negrita">Kinematic</span>: move the character/enemies along surfaces.</li>
      <li><span class="negrita">Physical</span>: apply upward force to make the character jump.</li>
    </ul>
  </p>
  <figure><img src="UD2/images/ud2-2024-01-31-13-36-07.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>The problem with this code is that if the character stops moving mid-jump, it won't retain its jump inertia.</p>
   <br><br>
   <hr>
   <br>
   <div class="tarea">
    <p>
      <span class="subrayado negrita">Activity 8. Rigidbody and Camera Tracking</span> <br>
      Open the project <span class="subrayado">InputsYourName</span>.
      Add the Rigidbody component to the capsule. <br>
      Configure the Rigidbody constraints for the capsule so it doesn’t tip over when colliding. <br>
      When programming the capsule's movement, there were two options: one that rotated with the a and d keys and one that didn’t. 
      If you used the non-rotating option, change the code to use the rotating option. <br>
      Add the Rigidbody component to the sphere. <br>
      Disable the camera script. <br>
      Position the view behind the capsule as shown in the image (z-axis pointing backward). <br>
       <figure><img src="UD2/images/ud2-2024-02-01-10-37-56.png" /><br><figcaption></figcaption></figure>
       <br>
       
      Select the camera and choose the option Menu &rarr; GameObject &rarr; Align With View. <br> <br>
      Make the camera a child of the capsule. <br> <br>
      Run the game and move the capsule to observe that the camera now follows the capsule and that the capsule collides with other GameObjects thanks to the Rigidbody.
      
    </p>
   </div>
  
  
</section><!-- End section Kinematic and Physical Movement-->

<!--*********************************************************Collisions***********************************************************-->
<section class="apartado">
<a name="sColisiones"></a>
<h2>Collisions</h2>
<p>To detect collisions between GameObjects, they must have a <span class="r-word">Collider</span> component 
  (usually present on all GameObjects).</p>

<p>Unity offers two mechanisms to detect collisions between GameObjects:
  <ul>
    <li>Via <span class="negrita">Collider</span>.</li>
    <li>Via <span class="negrita">Trigger</span> (Collider marked as Is Trigger, generally used for GameObjects without a graphical representation on screen).</li>
  </ul>
</p>

<p>It is common to use the GameObject's name or <span class="negrita">Tag</span> to detect collisions.</p>

<h3>Collisions with Collider</h3>
<p><span class="negrita">Collider collisions</span> are used when one GameObject touches another.</p>

<p>For example:
  <ul>
    <li>The player pushes another GameObject.</li>
    <li>A GameObject impacts another GameObject, such as a shot.</li>
    <li>…</li>
  </ul>
</p>

<p>Colliders can be 3D or 2D, and thus the MonoBehaviour class offers methods that will be triggered when a collision between colliders is detected.</p>

<p class="sub-section">3D Versions:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter(Collision collision)</span>: triggers on the frame the collision starts.</li>
    <li><span class="negrita">void OnCollisionStay(Collision collision)</span>: active while the collision persists.</li>
    <li><span class="negrita">void OnCollisionExit(Collision collision)</span>: triggers on the frame the collision ends.</li>
  </ul>
</p>

<p class="sub-section">2D Versions:</p>
<p>
  <ul>
    <li><span class="negrita">void OnCollisionEnter2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionStay2D(Collision collision)</span></li>
    <li><span class="negrita">void OnCollisionExit2D(Collision collision)</span></li>
  </ul>
</p>

<p>In the methods, a Collision object is received, allowing access to all aspects of the collision and the other GameObject.</p>

<p>Actions can be executed upon colliding with other GameObjects.</p>
<figure><img src="UD2/images/ud2-2024-01-31-13-40-49.png" /><br><figcaption></figcaption></figure>
<br>

<p>Through the collision object, you can access all elements of the GameObject involved in the collision.</p>
<figure><img src="UD2/images/ud2-2024-01-31-13-41-02.png" /><br><figcaption></figcaption></figure>
<br>

<h3>Collisions with Trigger</h3>
<p><span class="negrita">Trigger collisions</span> are used to determine if a GameObject is in a specific zone.</p>
<p>For example:
  <ul>
    <li>A GameObject has a collider larger than its size to detect if the player is within range so that when a key is pressed, it can be collected (consumable) or activated (switch).</li>
    <li>An empty GameObject has a collider to detect if the player is inside it.</li>
    <li>…</li>
  </ul>
</p>

<p>To act as a Trigger, a GameObject must have the <span class="negrita">Is Trigger</span> option checked in the Inspector within the Collider component.</p>

<p>Sometimes GameObjects that act as Triggers only have the Transform and Collider components, as they don't need to be visible on screen.</p>

<p>If a collider is set as Is Trigger, the MonoBehaviour class offers the following methods:</p>


<p class="sub-section">3D Versions:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter(Collider other)</span>: triggers on the frame the collision starts.</li>
    <li><span class="negrita">void OnTriggerStay(Collider other)</span>: active while the collision persists.</li>
    <li><span class="negrita">void OnTriggerExit(Collider other)</span>: triggers on the frame the collision ends.</li>
  </ul>
</p>


<p class="sub-section">2D Versions:</p>
<p>
  <ul>
    <li><span class="negrita">void OnTriggerEnter2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerStay2D(Collider other)</span></li>
    <li><span class="negrita">void OnTriggerExit2D(Collider other)</span></li>
  </ul>
</p>

<p>In these cases, the other object is received in the methods as a Collider object, which is the Collider of the other GameObject involved.</p>
<p>For the GameObject that moves:</p>
<figure><img src="UD2/images/ud2-2024-01-31-13-44-02.png" /><br><figcaption></figcaption></figure>
<br>


<p>For the GameObject set as <span class="negrita">is Trigger</span>:</p>
<figure><img src="UD2/images/ud2-2024-01-31-13-44-10.png" /><br><figcaption></figcaption></figure>
<br>

<p>In the following example, an invisible GameObject with a Collider applies a force to make another GameObject float inside it, 
  provided the other GameObject has a Rigidbody component:</p>
<figure><img src="UD2/images/ud2-2024-01-31-13-45-12.png" /><br><figcaption></figcaption></figure>
<br>



</section><!-- End section Collisions-->

  
  <!--*********************************************************Interesting Methods***********************************************************-->
  <section class="apartado">
    <a name="sMetodos_Intersantes"></a>
    <h2>Interesting Methods</h2>
    <h3>Destroy Method</h3>
    <p>The <span class="r-word">Destroy</span> method removes the GameObject. If no time is specified, it will be removed immediately. If time is specified, it will be removed after those seconds have passed.</p>
    <figure><img src="UD2/images/ud2-2024-01-31-13-47-43.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <h3>Instantiate Method</h3>
    <p>The <span class="r-word">Instantiate</span> method allows creating GameObjects during runtime.</p>
    
    <p>Examples of usage:
      <ul>
        <li>When the player shoots, the projectile should be created at that point and move in the direction they are aiming.</li>
        <li>In a zone of the scene, an enemy appears at the top, falls, and disappears when it reaches the bottom 
          (loop with Instantiate, movement, detection by trigger upon reaching the bottom, and Destroy).</li>
      </ul>
    </p>
    
    <p>An object is created when the "<span class="cursiva">Fire1</span>" button (left mouse button) is pressed.</p>
    <figure><img src="UD2/images/ud2-2024-01-31-13-49-03.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>When the player touches the GameObject, it replicates itself 10 times.</p>
    <figure><img src="UD2/images/ud2-2024-01-31-13-49-19.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>An object is created at fixed time intervals without any action required.
    A force is applied to the created GameObject at the moment of creation, launching it forward.
    </p>
    <figure><img src="UD2/images/ud2-2024-01-31-13-49-37.png" /><br><figcaption>Generating GameObject</figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-01-31-13-49-55.png" /><br><figcaption>Generated GameObject</figcaption></figure>
    <br>
    
    <h3>Utilities</h3>
    <p>With the <span class="r-word">Invoke</span> and <span class="r-word">InvokeRepeating</span> methods, you can specify the waiting time before calling another method.</p>
    
    <figure><img src="UD2/images/ud2-2024-01-31-13-50-28.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Active invocations can be canceled with the <span class="r-word">CancelInvoke</span> method.</p>
    <p>If no parameter is provided, all invocations will be canceled. If a method name is passed as a parameter, that specific invocation will be canceled.</p>
    
    <figure><img src="UD2/images/ud2-2024-01-31-13-50-52.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Another way to perform tasks similar to <span class="r-word">InvokeRepeating</span> is through the use of <span class="negrita">Coroutines</span>.</p>
    <figure><img src="UD2/images/ud2-2024-01-31-13-51-28.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Coroutines can be canceled using the methods <span class="negrita">StopAllCoroutines</span> and <span class="negrita">StopCoroutine("MethodName")</span>.</p>
    
    
    <br><br>
    <hr>
    <br>
    <div class="tarea">
      <p><span class="subrayado negrita">Practice 6 – Pachinko</span></p>
      
    <p>A Pachinko is a Japanese arcade machine in which the player has a large number of steel balls that are introduced into the machine. <br>
    The pachinko machine has a system that launches the balls from below through a side to reach the top, from where they begin to fall. <br>
    On the board, there are a series of pins where the metallic balls bounce, taking random paths. <br>
    Additionally, on the board, there can be different gates through which the balls can fall to earn points, and sometimes gates that return the ball to the player for reuse. <br>
    Lastly, the balls that reach the bottom do not award prizes. <br></p>
    
    
    <p>Below, you can see some real examples and video game versions.</p>
    <figure><img src="UD2/images/ud2-2024-02-01-11-00-27.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-02-01-11-00-52.png" /><br><figcaption></figcaption></figure>
    <br>
    
    
            
    <p>Create a 3D project in Unity called <span class="subrayado">PachinkoYourName</span>. <br>
    Install the Unity package that is <a class="enlace" target="_blank" href="./UD9/resources/pr-pachinko.unitypackage">attached</a> 
    to the task in one of the following ways: 
    <ul>
      <li>Double-clicking the package file will open the dialog to import all elements of the package. </li>
      <li>Dragging the package file will open the dialog to import all elements of the package.</li>
    </ul> <br>
    </p>
    <p>The package includes, besides the board, an image with sprites and 
      a series of materials that you can apply to the board and the metal balls. <br> 
    
    All elements of the board include a Collider to prevent balls from passing through them. Additionally, a Collider 
    is included in front to prevent balls from being shot forward (leaving space for the metallic balls).</p>
    <figure><img src="UD2/images/ud2-2024-02-01-11-04-26.png" /><br><figcaption></figcaption></figure>
    <br>
    
     <p>In the following link, you can find the same metallic materials package that is included with the task. 
    You can use any of these materials for the metallic balls. 
    <a class="enlace" target="_blank" href="https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949">https://assetstore.unity.com/packages/2d/textures-materials/metals/yughues-free-metal-materials-12949</a></p>
    
    
    <p>First, you should create the following prefabs (pay attention to the scale of the elements to avoid collision issues):
    <ul>
      <li>A metallic ball with physics and collisions.</li>
      <li>A static pin (it could be a cylinder) with metallic material and physical material for the balls to bounce off.</li>
      <li>A rotating pin (it could be a cylinder with an elongated cube or two elongated cubes forming a cross, or anything else you can think of) 
        that won't have a bouncing material. When the ball hits this pin, it should rotate around its center.</li>
       <figure><img src="UD2/images/ud2-2024-02-01-11-09-34.png" /><br><figcaption></figcaption></figure>
       <br>
       
      <li>A gate that awards 5 points if the ball falls into it.</li>
      <li>A gate that awards 10 points if a ball falls into it. This gate should be smaller than the previous one.</li>
      <li>A gate that grants an extra ball if the ball falls into it.</li>
    </ul></p>
    
    
    <p>The gate prefabs should have sprites included to indicate to the player what happens when the ball falls into them.
    In the scene, you should add:
    <li>At the top center, a current passport-like photo of yourself, your name, the current points, and the number of remaining balls should be displayed.</li>
     <figure><img src="UD2/images/ud2-2024-02-01-11-12-11.png" /><br><figcaption></figcaption></figure>
     <br>
     
    <li>As many static and rotating pins as you want to make the game look dynamic.</li>
    <li>Two 5-point gates.</li>
    <li>One 10-point gate.</li>
    <li>Two extra ball gates.</li></p>
    
    
    
    <p><span class="subrayado">Game Mechanics:</span> 
    <ul>
      <li>The game will start with 100 balls and 0 points.</li>
      <li>Pressing the left arrow key will release a ball from the top left slot, and one ball will be deducted from the remaining count.</li>
      <li>Pressing the right arrow key will release a ball from the top right slot, and one ball will be deducted from the remaining count.</li>
      <li>When a ball falls into any gate, the corresponding points or an extra ball should be added to the remaining count.</li>
      <li>When a ball falls into any gate or the bottom, it should be destroyed.</li>
      <li>The HUD should always be updated with the current points and the remaining number of balls.</li>
    </ul></p>
    
    
    
    <p>All GameObjects in the scene should have appropriate names. <br>
    Create and assign all the necessary tags. <br>
    Create the necessary scripts and add them to the GameObjects or Prefabs for the game to work correctly.</p>
    
    
    <p>
    <span class="subrayado">Extras:</span>
    <ul>
      <li>Each time a ball is created, it will have a random material from all the metallic ball materials included in the package.</li>
      <li>Create a gate prefab that rewards the player with 50 extra balls. This should be a gate that's difficult for a ball to fall into. 
        Once created, add the gate to the board.</li>
      <li>Modify the board to resemble the original pachinko machines, where the ball is launched from the bottom through the side toward the top of the board. 
        In this case, the arrow keys will be replaced by the spacebar, and pressing it will launch a ball. 
        You should create a mechanism to adjust the force of the ball, such as a wheel that rotates with the arrow keys to indicate power.</li>
    </ul></p>
    
    
    
    </div>
    
    </section><!-- End section Interesting Methods-->
  
  
  <!--*********************************************************CharacterController Component***********************************************************-->
  <section class="apartado">
    <a name="sComponenteCharacterController"></a>
    <h2>CharacterController Component</h2>
    <p>In many first- or third-person games, physics is needed to control certain collisions, such as ensuring the character doesn't pass through the floor or walls.</p>
    
    <p>Additionally, in these games, the movement is intentionally unrealistic, allowing the character to start moving or change direction instantly, without being affected by inertia.</p>
    
    <p>For these cases, Unity offers the <span class="r-word">CharacterController</span> class, which has its own functions, is affected by collisions, and doesn't require a <span class="r-word">Rigidbody</span>, making it easier to use.</p>
    
    <p>When adding the <span class="negrita">CharacterController</span> component to a GameObject, a <span class="subrayado">capsule-shaped collider</span> is automatically added to the GameObject and is associated with the <span class="negrita">CharacterController</span> component.</p>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-19-30.png" /><br><figcaption>Empty GameObject</figcaption></figure>
    <br>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-19-46.png" /><br><figcaption>Composite GameObjects</figcaption></figure>
    <br>
    <p>All GameObjects that are graphically represented in the scene have a <span class="negrita">Collider</span> component. It may be useful to remove or disable it if the capsule-shaped collider from the CharacterController is sufficient.</p>
    <figure><img src="UD2/images/ud2-2024-02-20-18-21-17.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>The <span class="negrita">properties of the CharacterController component</span> are as follows:
      <ul>
        <li><span class="negrita">Slope Limit</span>: the character can climb slopes up to the specified degree.</li>
        <li><span class="negrita">Step Offset</span>: the character can climb steps up to 0.3 meters high.</li>
        <li><span class="negrita">Skin Width</span>: the collider's skin width (margin where collisions don't apply).</li>
        <li><span class="negrita">Min Move Distance</span>: the minimum value for the character to move.</li>
        <li><span class="negrita">Center</span>: the position of the collider relative to the GameObject.</li>
        <li><span class="negrita">Radius</span>: the capsule's radius.</li>
        <li><span class="negrita">Height</span>: the capsule's height.</li>
      </ul>
    </p>
    <figure><img src="UD2/images/ud2-2024-03-05-09-59-36.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Since <span class="negrita">CharacterController is not affected by physics</span>, 
      the component provides several properties and methods to gather information about the 
      GameObject, such as the <span class="r-word">isGrounded</span> property, which indicates if the character
       touched the ground during its last movement.</p>
    
    <p>The ground will be any other GameObject with a collider that the CharacterController can stand on.</p>
    
    <p>To move the character, two methods are available:
      <ul>
        <li><span class="negrita">Move</span>: allows full control of the character's movement, including gravity, jumping, horizontal movement, etc.</li>
        <li><span class="negrita">SimpleMove</span>: moves the character while automatically applying gravity.</li>
      </ul>
    </p>
    
    <p>The technique used with the <span class="r-word">Move</span> method involves gathering data from <span class="negrita">Input</span> and other GameObjects in the scene that affect movement and using them to calculate the movement vector to be applied to the character.</p>
    
    <p>Some data that should be gathered include:
      <ul>
        <li>Is the character touching the ground?</li>
        <li>Is any key or button being pressed?</li>
        <li>Should an upward force be applied because the character is jumping?</li>
        <li>…</li>
      </ul>
    </p>
    
    <p>An initial approach for character movement using CharacterController, where the character can move on a surface, could be the following:</p>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-26-04.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>The properties are public so their values can be checked in the <span class="cursiva">Inspector</span> when the script is executed.</p>
    
    <p>This approach is very basic since it doesn't account for the camera, gravity, or other important factors. 
      Additionally, when moving diagonally, the two forces add up, making the movement faster, which doesn't make sense.</p>
    
    <h3>Character Control with CharacterController</h3>
    
    <p>Below is a series of scripts for:
      <ul>
        <li>Full player movement, including jumping and sliding on steep slopes.</li>
        <li>Camera following the player.</li>
        <li>Being able to push GameObjects affected by physics (with Rigidbody).</li>
      </ul>
    </p>
    <p>These scripts are based on Unity tutorials and can be improved in various ways.</p>
    <p class="sub-section">PlayerController.cs</p>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-37-45.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-37-54.png" /><br><figcaption>PlayerController.cs</figcaption></figure>
    <br>
    
    <figure><img src="UD2/images/ud2-2024-02-20-18-38-58.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-02-20-18-39-20.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-02-20-18-39-46.png" /><br><figcaption>PlayerController.cs cont.</figcaption></figure>
    <br>
    <p class="sub-section">PushRigidBody.cs</p>
    <figure><img src="UD2/images/ud2-2024-02-20-18-40-38.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-02-20-18-40-47.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p class="sub-section">ThirdPersonCamera.cs</p>
    <figure><img src="UD2/images/ud2-2024-02-20-18-41-06.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-02-20-18-41-19.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <h3>CharacterController vs Physical Movement</h3>
    <p>When implementing character movement, the choice is between:
      <ul>
        <li>Implementing movement using physics with Rigidbody. <br>
          Using physics makes the movement more realistic, which can be an added value in simulators. <br>
          Player control will be more challenging.</li>
          <li>Implementing movement using kinematics with CharacterController. <br>
    Using CharacterController provides easier use for developers, 
    precise control of collisions, and overall more efficiency as it is optimized for characters. <br>
    Additionally, the player will have more precise control, which is very useful for performing complex actions. <br>
    In most cases, implementing with CharacterController is sufficient.</li>
      </ul>
    </p>
    
    </section><!-- End section CharacterController Component-->
  
  
  <!--*********************************************************Professional Camera***********************************************************-->
  <section class="apartado">
    <a name="sCamaraprofesional"></a>
    <h2>Professional Camera</h2>
    <p>Unity offers a package called <span class="r-word">Cinemachine</span> which provides tools and 
      virtual cameras that simulate a film studio, allowing full control of the camera.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-24-06.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-24-16.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Once the package is installed, you can find the virtual camera settings in the <span class="negrita">Menu &rArr; Component &rArr; Cinemachine</span>, 
       which can be added to the camera in the scene.</p>
    
    <figure><img src="UD2/images/ud2-2024-03-11-10-25-13.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-25-32.png" /><br><figcaption></figcaption></figure>
    <br>
    
    </section><!-- End section Professional Camera-->
    
    <!--*********************************************************Programmed Movement***********************************************************-->
    <section class="apartado">
    <a name="sMovimientoProgramado"></a>
    <h2>Programmed Movement</h2>
    
    <p>In a video game, there may be elements that have pre-programmed movement, 
      for example, an enemy that moves from side to side along the same path, or a platform that moves from one point to another.</p>
    
    <p>In these cases, the mechanics are always the same:
      <ul>
        <li>Create an empty GameObject.</li>
        <li>Add the GameObject that will move (enemy, platform…) to that empty GameObject.</li>
        <li>Add as many empty GameObjects as there are points the moving object must reach.</li>
        <li>In a script added to the object that will move, indicate the point-to-point movement.</li>
      </ul>
    </p>
    <p>The previous setup would look like this if the platform only needs to move between two points:</p>
    <figure><img src="UD2/images/ud2-2024-03-05-10-03-16.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <br>
    <p>Add a script to the GameObject that needs to move with the following code:</p>
    <figure><img src="UD2/images/ud2-2024-02-20-18-53-12.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>This code uses kinematic movement to move the platform from one place to another.</p>
    
    <p>The code can be improved by creating an array of destination positions, 
      allowing the GameObject to move through all positions repeatedly.</p>
    
    <p>You can also specify that the GameObject pauses when it reaches a destination.</p>
    
    <p>If you add a <span class="negrita">RigidBody to the platform</span> (without using gravity and set as kinematic), 
      the player or any other GameObject can stand on the platform and move with it.</p>
    
    <p>When the platform has a Rigidbody, the movement should be done using physics.</p>
    
    <p>In this case, the script should be placed on the parent GameObject of the platform.</p>
    
    <p>This code should be added to the parent GameObject of the moving platform.</p>
    <figure><img src="UD2/images/ud2-2024-03-05-10-55-07.png" /><br><figcaption></figcaption></figure>
    <br>
    <p>Additionally, you should drag the platform and the points it should pass through into the inspector.</p>
    
    <figure><img src="UD2/images/ud2-2024-03-11-10-28-20.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Since the platform has a Rigidbody, the movement must be physical.</p>
    
    <figure><img src="UD2/images/ud2-2024-03-11-10-28-38.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>If the character's movement has been implemented using the <span class="negrita">CharacterController</span> component, 
       and the previous example is used to move a platform, the character will not stay on the platform.</p>
    
    <p>This happens because the platform has a Rigidbody and moves with physics, but the character doesn't have a Rigidbody.</p>
    
    <p>To solve this, you need to detect the surface the character is standing on, and 
      when they are on the platform, move the character along with the platform.</p>
    
    <p>You can use <span class="negrita">Raycasts</span> to achieve this.</p>
    </section><!-- End section Programmed Movement-->
  
  
  <!--*********************************************************Raycast***********************************************************-->
  <section class="apartado">
  <a name="s"></a>
  <h2>Raycast</h2>
  
  <p>Un <span class="negrita">Raycast</span>  consiste en la emisión de un rayo.</p>
  
  <p>Un <span class="negrita">rayo</span>  es una línea <span class="negrita">imaginaria</span>  que sale desde un punto y va en una dirección determinada.</p>
  
  <p>Al realizar emisiones de rayos con Raycast se puede detectar los GameObjects y los triggers que se encuentran en la trayectoria del rayo.</p>
  
  <p>Para emitir un rayo se necesita:
    <ul>
      <li>Un objeto de la clase <span class="negrita">Ray</span> .</li>
  
      <li>Un objeto de la clase <span class="negrita">RaycastHit</span>  que indicará en qué GameObject impacta el rayo.</li>
      
      <li>Emitir el rayo con el método <span class="negrita">Raycast</span>  de la clase <span class="negrita">Physics</span> .</li>
    </ul>
  </p>
  
  <p>Algunas utilidades de Raycast son:
    <ul>
      <li>Detectar colisiones.</li>
      <li>Detectar si un GameObject está en la trayectoria de otro.</li>
      <li>Seleccionar elementos con el ratón.</li>
      <li>Realizar disparos.</li>
      <li>…</li>
    </ul>
  </p>
  
  <p>En el siguiente ejemplo se emite un rayo y cuando impacta se muestra un mensaje:</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-29-22.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-03-11-10-29-32.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Si los rayos no se visualizan al ejecutar se deberán activar en la parte de la derecha de la visualización de la Scene o del Game en el apartado Gizmos:</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-29-55.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>El método <span class="negrita">Raycast</span>  tiene varias versiones.</p>
  
  <figure><img src="UD2/images/ud2-2024-03-11-10-30-21.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Una de las versiones admite un segundo parámetro de la clase <span class="negrita">RaycastHit</span>,
    en este objeto se almacenará toda la información sobre el impacto, incluido el GameObject en el que impacta el rayo.</p>
  
  <p>Se debe declarar el objeto de la clase <span class="negrita">RaycastHit</span> antes de realizar la llamada al método 
    <span class="negrita">Raycast</span>.</p>
  
    <figure><img src="UD2/images/ud2-2024-03-11-10-30-58.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-31-08.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Se pueden aplicar <span class="negrita">filtros</span> para que el rayo solo impacte en los GameObjects afectados por ese filtro.
      <ul>
        <li><span class="negrita">Por distancia</span>: menor o igual a 7
          <figure><img src="UD2/images/ud2-2024-03-11-10-33-47.png" /><br><figcaption></figcaption></figure>       
        </li>
        <li><span class="negrita">Por capas</span>: igual que se pueden crear etiquetas (tags) se pueden crear capas  (layers) y 
          asignarlas a los GameObjects. Las capas se pueden indicar creando una variable de la clase LayerMask. 
          En el inspector se podrán selecciona varias capas.
        <figure><img src="UD2/images/ud2-2024-03-11-10-34-16.png" /><br><figcaption></figcaption></figure>
        <br>
        
        </li>
      </ul>
    </p>
    
    <p>Se puede indicar que el rayo no impacte en los Collider tipo Trigger.</p>
  
    <figure><img src="UD2/images/ud2-2024-03-11-10-34-47.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Por defecto un rayo solo impacta en el primer GameObject con el que se encuentra, 
      este comportamiento se puede cambiar si se utiliza el método <span class="negrita">RaycastAll</span> de la clase <span class="negrita">Physics</span> .</p>
    <p>Este método devuelve un array con todos los GameObjects en los que impacta el rayo.</p>
     <figure><img src="UD2/images/ud2-2024-03-11-10-35-12.png" /><br><figcaption></figcaption></figure>
     <br>
     
    <p>Se pueden emitir rayos desde la cámara, esto permite funciones como seleccionar objetos con el ratón.</p>
    
  <p>El siguiente script se debe añadir a la cámara. 
    Este script no puede llamarse Camera porque sobre escribiría la clase <span class="negrita">Camera</span>  de Unity.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-36-10.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-03-11-10-36-19.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
    <p>En muchos videojuegos se utilizan los Raycast para detectar colisiones, por ejemplo, para saber si el personaje está tocando el suelo.</p>
    
    <p>Para detectar colisiones entre GameObjects usando Raycast se debe lanzar un rayo cuya distancia no supere mucho al GameObject 
      desde el que se emite.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-36-40.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-36-48.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>En algunos videojuegos se emiten rayos desde diferentes puntos del personaje para controlar así su movimiento.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-37-07.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-03-11-10-37-15.png" /><br><figcaption></figcaption></figure>
  <br>
  
    <p>Con el método Raycast se emite un rayo, que es una línea.</p>
    
  <p>La clase Physics ofrece otros tipos de emisión con otras formas:
    <ul>
      <li><span class="negrita">BoxCast</span>: emite un rayo cuyo haz tiene forma de cubo</li>
      <li><span class="negrita">CapsuleCast</span>: emite un rayo cuyo haz tiene forma de cápsula</li>
      <li><span class="negrita">SphereCast</span>: emite un rayo cuyo haz tiene forma de esfera</li>
      <li><span class="negrita">LineCast</span>: devuelve true si hay algún objeto con el que el rayo impacte</li>
    </ul>
  </p>
  
  <p>A continuación, se muestra un script que amplía la funcionalidad del control del personaje con <span class="negrita">CharacterController</span> 
     en el que se comprueba si el GameObject está tocando el suelo usando un <span class="negrita">SphereCast</span> .</p>
  
     <h3>Control de personaje – Sobre plataformas móviles</h3>    
     <p>Así, para que un personaje con CharacterController pueda moverse junto con una plataforma con Rigidbody que está pisando, 
      se debe añadir el siguiente script al personaje:</p>
  
      <figure><img src="UD2/images/ud2-2024-03-11-10-37-55.png" /><br><figcaption></figcaption></figure>
      <br>
      <figure><img src="UD2/images/ud2-2024-03-11-10-38-03.png" /><br><figcaption></figcaption></figure>
      <br>
      
  </section><!-- End section Raycast-->
  
  
  <!--*********************************************************sNPCs***********************************************************-->
  <section class="apartado">
  <a name="sNPCs"></a>
  <h2>NPC's</h2>
  <p>Los <span class="negrita">NPC</span>  (<span class="negrita">N</span>on <span class="negrita">P</span>layable 
  <span class="negrita">C</span>haracters) son aquellos personajes que los controla el propio videojuego 
  y sobre los cuales el jugador no puede indicarle qué acciones debe realizar.</p>
  
  <p>Los NPC se pueden clasificar en:
    <ul>
      <li><span class="negrita">Enemigos</span>: presentan un desafío que se debe superar para poder continuar.</li>
      <li><span class="negrita">Aliados</span>: acompañan al jugador pudiendo aportar ayuda en puzles y combates.</li>
      <li><span class="negrita">Influenciables</span>: dependiendo de las acciones pueden convertirse en aliados o enemigos.</li>
      <li><span class="negrita">Comerciantes</span>: ofrecen la posibilidad de intercambiar objetos para mejorar y/o avanzar.</li>
      <li><span class="negrita">Informativos</span>: solo proporcionan información con o sin importancia para la misión.</li>
      <li><span class="negrita">Decorativos</span>: existen para dotar al juego de un ambiente más realista completando las escenas.</li>
    </ul>
  </p>
  
  <p>En general un NPC puede ser:
    <ul>
      <span class="negrita">Activo</span>: ofrece misiones, información, objetos que cambian a medida que el jugador avanza.
      <span class="negrita">Pasivos</span>: repiten la misma información o comportamiento cada vez que el jugador interactúa con ellos.
    </ul>
  </p>
  
  <p>A los NPC se les presupone un mínimo de <span class="negrita">IA</span> (<span class="negrita">I</span>nteligencia 
    <span class="negrita">A</span>rtificial), esta IA consiste en programar el comportamiento que debe tener el NPC.
    Se pueden programar IA's más simples y más complejas.</p>
  
  <p>En el siguiente ejemplo se va a estudiar como 
    <span class="negrita">implementar que un NPC vaya de un punto a otro por el camino más óptimo</span>.</p>
  
  <p>Esta técnica también se puede utilizar para que el personaje vaya a un punto seleccionado con el ratón 
    o que un enemigo realice una ronda por el escenario y que al ver al jugador le persiga.</p>
  
  
  
  <p>Se necesita instalar el paquete <span class="r-word">AI Navigation</span>.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-38-48.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Al instalar el paquete AI Navigation se añadirá una nueva opción: <span class="negrita">Menú</span>  &rarr; <span class="negrita">Window</span>  &rarr;
  <span class="negrita">AI</span>  &rarr; <span class="negrita">Navigation</span> .</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-38-59.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Al pulsar la opción <span class="negrita">Menú</span>  &rarr; <span class="negrita">Window</span>  &rarr; <span class="negrita">AI</span> 
     &rarr; <span class="negrita">Navigation</span>  aparece la ventana Navigation.</p>
  
  <p>En la pestaña <span class="negrita">Agents</span>  se pueden definir las características del GameObject 
    que se va a mover por la ruta más óptima.</p>
  
    <figure><img src="UD2/images/ud2-2024-03-11-10-39-33.png" /><br><figcaption></figcaption></figure>
    <br>
    
  <p>Se pueden crear tantos agentes como se quiera, por ejemplo, puede haber enemigos que no pueden saltar sobre un muro y otros que sí.</p>
  
  <p>En la pestaña <span class="negrita">Areas</span>  se pueden definir las diferentes áreas y su prioridad (Cost),
    a menor número mayor prioridad de pasar por esa área.</p>
  
    <figure><img src="UD2/images/ud2-2024-03-11-10-39-43.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>A los GameObjects que se deben mover se les debe añadir el componente <span class="negrita">NavMeshAgent</span> .</p>
    
    <p>En el ejemplo, la cápsula se moverá hasta la posición de la esfera por el camino más óptimo.</p>
    
    <p><span class="negrita">Se ha añadido el componente NavMeshAgent a la cápsula</span> , en el inspector se puede ver las opciones de configuración que tiene.</p>
    
    <figure><img src="UD2/images/ud2-2024-03-11-10-40-08.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-40-16.png" /><br><figcaption></figcaption></figure>
    <br>
    
  
  <p>Ahora se debe añadir el componente <span class="negrita">NavMeshSurface</span>  sobre los GameObjects de la escena y asignarle el área que se quiera.</p>
  
  <p>Este componente permite definir <span class="negrita">por dónde podrá moverse el agente</span> .</p>
  
  <p>En el ejemplo, el suelo y todos los bloques están dentro de un GameObject y en ese GameObject se añade el componente NavMeshSurface.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-40-43.png" /><br><figcaption></figcaption></figure>
  <br>
  <figure><img src="UD2/images/ud2-2024-03-11-10-40-50.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
  <p>Una vez configurado el NavMeshSurface se debe pulsar la opción <span class="negrita">Bake</span> .</p>
  
  <p>Esta opción genera la superficie por la que el personaje se podrá mover. 
    Se puede observar que se deja un margen alrededor de los obstáculos para evitar comportamientos imprevistos. 
    Esta superficie se puede modificar cambiando los ajustes del <span class="negrita">Agent</span>  y pulsando <span class="negrita">Clear</span> 
     y <span class="negrita">Bake</span>  de nuevo.</p>
  
     <figure><img src="UD2/images/ud2-2024-03-11-10-41-12.png" /><br><figcaption></figcaption></figure>
     <br>
     
  
    <p>Como la esfera no es un elemento del escenario se le debe añadir el componente <span class="negrita">NavMeshObstacle</span> .</p>
       
    <p>El componente <span class="negrita">NavMeshObstacle</span>  se suele utilizar para los GameObject que pueden moverse por la escena.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-41-42.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-41-55.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>El componente <span class="negrita">NavMeshObstacle</span>  se utiliza para personajes que se mueven por la escena y 
      para GameObjects que al moverse pueden afectar a la superficie de navegación.</p>
    
    <p>Los enemigos tendrán el componente <span class="cursiva">NavMeshObstacle</span>  y no deben afectar a la superficie de navegación.</p>
    
    <p>GameObjects como piedras que pueden caer y entorpecer el paso o puertas 
      que pueden cerrarse sí que deben afectar a la superficie de navegación.</p>
    
    <p>Para configurar un <span class="negrita">NavMeshObstacle</span>  y que afecte a la superficie debe marcarse la opción <span class="negrita">Carve</span>, 
      si se quiere que solo afecte a la superficie cuando el GameObject se queda estático (por ejemplo una piedra grande que cae) 
      se debe desmarcar la opción <span class="negrita">Carve Only Stationary</span>.</p>
  
      <figure><img src="UD2/images/ud2-2024-03-11-10-42-37.png" /><br><figcaption></figcaption></figure>
      <br>
      
    <p>En el ejemplo, hay un cubo con el componente NavMeshObstacle y la opción Carve activada.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-42-56.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-43-06.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-43-22.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>En la navegación se pueden crear <span class="negrita">enlaces</span>.</p>
    <p>Existen dos tipos de enlaces:
      <ul>
        <li><span class="negrita">NavMeshLink</span> : permite unir zonas de navegación de la misma superficie, por ejemplo, para permitir que el jugador baje un escalón más grande del permitido.</li>
        <li><span class="negrita">OffMeshLink</span> : permite unir dos zonas de navegación separadas físicamente.</li>
      </ul>
    </p>
    <p>Los enlaces pueden ser unidireccionales o bidireccionales.</p>
    
    <h3>NavMeshLink</h3>
    <p>Un NavMeshLink tiene dos puntos y una superficie visible entre los dos puntos.</p>
    <p>Si por ejemplo, se quiere que el personaje pueda bajar el escalón pero no pueda subirlo se debe desmarcar la opción <span class="negrita">Bidireccional</span> .</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-43-51.png" /><br><figcaption></figcaption></figure>
  <br>
  
    <h3>OffMeshLink</h3>
    <p>Un OffMeshLink necesita dos GameObjects como referencia para la navegación.</p>
    
    <p>En este punto solo falta asignar al GameObject que se debe mover (cápsula) el siguiente script.</p>
    <p>Se debe añadir la librería en la parte superior del script.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-44-24.png" /><br><figcaption></figcaption></figure>
    <br>
    <figure><img src="UD2/images/ud2-2024-03-11-10-44-32.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>A partir del script anterior se puede conseguir que un GameObject realice una ruta:
      <ul>
        <li>En la escena se deben crear GameObjects vacíos con un collider tipo trigger y situarlos donde se quiera.</li>
        <li>En el script se debe declarar un array de objetivos.</li>
        <li>En el método Start se indica que el primer objetivo sea la posición cero del array.</li>
        <li>En el método Update se comprueba si se ha alcanzado el objetivo.</li>
        <li>Si se ha alcanzado se actualiza el objetivo a la siguiente posición del array.</li>
        <li>Si la siguiente posición del array es igual a longitud del array se actualiza el objetivo a la posición cero del array.</li>
        <li>En el inspector se deben añadir todos los GameObject vacíos al script en el orden que se quiere que tenga la ruta de movimiento.</li>
      </ul>
    </p>
    
    <p>Si se quiere que el enemigo que realiza la ruta persiga al jugador se deben añadir los siguientes elementos:
      <ul>
        <li>En el script se debe declarar un Transform para el jugador.  </li>
        <li>Se debe añadir al funcionalidad de que se cree un Raycast desde el enemigo en la dirección en la que camina y con una longitud (se puede simular la vista humana haciendo que el Raycast gire algunos grados a cada lado).</li>
        <li>Si el Raycast impacta en el jugador se guarda el objetivo actual en una variable y se cambia el objetivo por el transform del jugador.</li>
        <li>Si el Raycast deja de impactar en el jugador (el jugador se aleja más que la longitud del rayop) se actualiza el objetivo por el objetivo guardado en el paso anterior (se puede mejorar actualizando el objetivo por el punto más cercano actual de la ruta del enemigo).</li>
      </ul>
    </p>
    
  <p>Si se quiere implementar que el personaje del jugador vaya al punto de la pantalla donde se realice clic, se puede utilizar el siguiente script:</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-45-08.png" /><br><figcaption></figcaption></figure>
  <br>
  
    
    </section><!-- End section sNPCs-->
  
    <!--*********************************************************Cambio de escenas***********************************************************-->
    <section class="apartado">
    <a name="sCambiodeescenas"></a>
    <h2>Cambio de escenas</h2>
  <p>En un videojuego es habitual que haya más de una escena, principalmente porque cada nivel del juego suele ser una escena diferente.</p>
  
  <p>Además, en los juegos también suele haber un menú inicial y un menú de opciones, que también son escenas.</p>
  
  <p>Para poder cambiar a una escena, esta debe añadirse en las preferencias del build del juego.</p>
  
  <p>Los cambios entre escenas se pueden realizar en diferentes momentos:
  <ul>
    <li>Al pulsar el botón Jugar en el menú principal.</li>
    <li>Al superar un nivel.</li>
    <li>Dentro de un nivel al entrar a una zona nueva.</li>
    <li>...</li>
  </ul>
  </p>
  
  <p>El primer paso es añadir todas las escenas a las preferencias del build del juego: 
    <span class="negrita">File</span> &rarr; <span class="negrita">Build Settings…</span>.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-45-40.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Pulsando el botón <span class="negrita">Add Open Scenes</span>  se añadirá la escena abierta.</p>
  
  <p>Para añadir el resto de escenas se deben arrastrar desde el gestor de archivos.</p>
  
  <p>La escena que esté en primera posición (0) será la que se cargue cuando se ejecute el juego (tras compilarlo y generar el ejecutable).</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-46-03.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Para realizar el cambio de escena desde un script, en el script se debe añadir la librería en la parte superior del script.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-46-23.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>La instrucción para cambiar de escena es la siguiente:</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-46-31.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>También se puede indicar el identificador de la escena (Build settings):</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-46-41.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Al realizar un cambio de escena se puede indicar a los GameObjects que no se destruyan y se mantengan en la escena nueva.</p>
  
  <p>Esto permite pasar datos entre escenas y ahorrar tiempo al estar ya los GameObjects cargados en memoria.</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-46-55.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
    </section><!-- End section Cambio de escenas-->
  
  
    <!--*********************************************************PlayerPrefs***********************************************************-->
    <section class="apartado">
    <a name="sPlayerPrefs"></a>
    <h2>PlayerPrefs</h2>
    <p>Las <span class="negrita">PlayerPrefs</span>  permiten almacenar información en el ordenador donde se ejecute el juego.</p>
    
  
  <p>Con las PlayerPrefs se suelen guardar:
  <ul>
    <li>El nombre del jugador.</li>
    <li>Puntuaciones.</li>
    <li>Vidas.</li>
    <li>Opciones de juego como la resolución o teclas definidas por el usuario.</li>
    <li>Último nivel (escena) jugado.</li>
  <li>…</li>
  </ul>
  </p>
  
  <p><span class="negrita">PlayerPrefs</span>  ofrece varios métodos para almacenar/recuperar información según el tipo de dato:
    <ul>
      <li>SetFloat</li>
      <li>SetInt</li>
      <li>SetString</li>
    </ul>
    <figure><img src="UD2/images/ud2-2024-03-11-10-47-30.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <ul>
      <li>GetFloat</li>
      <li>GetInt</li>
      <li>GetString</li>
    </ul>
    <figure><img src="UD2/images/ud2-2024-03-11-10-47-40.png" /><br><figcaption></figcaption></figure>
    <br>
    
  </p>
  
  <p>Los métodos <span class="negrita">Get</span> pueden tener uno o dos parámetros, 
    el segundo será el valor por defecto para el caso en el que no exista la preferencia.</p>
    
  
  <p>Para comprobar si una preferencia existe se usa el método <span class="negrita">HasKey</span> :</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-48-02.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Para eliminar una preferencia se utiliza el método <span class="negrita">DeleteKey</span> :</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-48-11.png" /><br><figcaption></figcaption></figure>
  <br>
  
  <p>Para eliminar todas las preferencias se utiliza el método <span class="negrita">DeleteAll</span> :</p>
  <figure><img src="UD2/images/ud2-2024-03-11-10-48-18.png" /><br><figcaption></figcaption></figure>
  <br>
  
    
    </section><!-- End section PlayerPrefs-->
  
    <!--*********************************************************Menús***********************************************************-->
    <section class="apartado">
    <a name="sMenus"></a>
    <h2>Menús</h2>
    
    <p>Para crear menús hay dos opciones:
      <ul>
        <li>
          Menú <span class="negrita">principal</span>  (cuando no existe ningún nivel cargado): <br>
          Suele crearse en una escena propia utilizando elementos de UI.
        </li>
        <li>Menú <span class="negrita">ingame</span>:<br>
          Puede crearse igual que el menú principal, 
          pero al cambiar de escena entre el nivel actual y el menú se deberá almacenar toda la situación actual.</li>
      </ul>
      </p>
    
  <p>Se puede crear dentro de la escena del nivel creando una cámara secundaria con los elementos de la UI. 
    Esta cámara estará lejos de los elementos del nivel. 
    Al acceder al menú se pondrán en pausa todos los elementos de la escena y 
    se cambiará la cámara activa para que sea la que tiene asociado el menú.</p>
  
    <p>Aunque se puede crear un menú con GameObjects como si fuera una escena del juego, 
      lo más habitual es utilizar GameObjects de UI (Interfaz de Usuario).</p>
      <figure><img src="UD2/images/ud2-2024-03-11-10-48-49.png" /><br><figcaption></figcaption></figure>
      <br>
      
    <p>El manejo de eventos en GameObjects de UI es diferente al del resto de GameObjects, 
      a continuación, se estudiarán los pasos a seguir para interactuar con ellos.</p>
    
      <p>Cada tipo de GameObject de UI dispone de unos eventos que se pueden consultar en el inspector.</p>
      <figure><img src="UD2/images/ud2-2024-03-11-10-49-25.png" /><br><figcaption></figcaption></figure>
      <br>
      
    <p>Estos eventos se deben enlazar con un método en un script de Unity.</p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-49-52.png" /><br><figcaption></figcaption></figure>
    <br>
    
    <p>Tras crear el script y añadir los métodos necesarios, que pueden tener el nombre que se quiera, 
      se debe añadir ese script al GameObject Canvas para poder seleccionar sus métodos posteriormente desde el inspector de los GameObject de UI.</p>
    
    <p>Una vez añadido el script al <span class="negrita">Canvas</span>, 
      para seleccionar un método desde un GameObject de UI se debe seleccionar el GameObject de UI y
      en el inspector realizar las siguientes acciones:
    <ul>
      <li>Pulsar <span class="negrita">+</span> en el evento que se quiera.</li>
      <li>En el bloque que aparece, arrastrar el GameObject Canvas desde la jerarquía.</li>
      <li>Seleccionar el método que se quiere que se ejecute al ejecutarse el evento.</li>
    </ul></p>
    <figure><img src="UD2/images/ud2-2024-03-11-10-50-22.png" /><br><figcaption></figcaption></figure>
    <br>
    
      
  
  <p>De esta manera se enlaza el método con el evento en el GameObject de UI.</p>
  
  <figure><img src="UD2/images/ud2-2024-03-11-10-51-21.png" /><br><figcaption></figcaption></figure>
  <br>
  
  
    </section><!-- End section Menús-->

  <!---BTM_MENU--->
  <script src="../script/prism.js"></script>
</body>

</html>